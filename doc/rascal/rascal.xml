<?xml version="1.0" encoding="US-ASCII"?>
<article version="5.0" xmlns="http://docbook.org/ns/docbook"
         xmlns:xlink="http://www.w3.org/1999/xlink"
         xmlns:xi="http://www.w3.org/2001/XInclude"
         xmlns:svg="http://www.w3.org/2000/svg"
         xmlns:mml="http://www.w3.org/1998/Math/MathML"
         xmlns:html="http://www.w3.org/1999/xhtml"
         xmlns:db="http://docbook.org/ns/docbook">
  <info>
    <title>Rascal Requirements and Design Document</title>

    <authorgroup>
      <author>
        <personname><firstname>Paul</firstname><surname>Klint</surname></personname>
      </author>

      <author>
        <personname><firstname>Tijs</firstname><surname>van der
        Storm</surname></personname>
      </author>

      <author>
        <personname><firstname>Jurgen</firstname><surname>Vinju</surname></personname>
      </author>
    </authorgroup>
  </info>

  <note>
    <para>This document is a braindump of ideas that is slowly converging to a
    coherent design. See <xref linkend="section.issues" /> for the issues that
    have to be resolved. Updated according to status as of April 6,
    2009.</para>
  </note>

  <section>
    <title>Introduction</title>

    <para>We have identified the need for better language support for
    specifying and implementing software analysis and transformation tools. In
    this document we embark on a design of a domain-specific language that is
    intended to provide a comprehensive and easy to use set of concepts for
    that domain. The goals of the envisaged language (with working name
    Rascal) are:</para>

    <itemizedlist>
      <listitem>
        <para>Providing a successor of ASF+SDF that has of all its benefits
        and fixes all of its shortcomings.</para>
      </listitem>

      <listitem>
        <para>Separating pure syntax definitions (SDF) from function
        definitions.</para>
      </listitem>

      <listitem>
        <para>Easy syntax-directed analysis of programming languages.</para>
      </listitem>

      <listitem>
        <para>Easy fact extraction.</para>
      </listitem>

      <listitem>
        <para>Easy connection of fact extraction with fact manipulation and
        reasoning.</para>
      </listitem>

      <listitem>
        <para>Easy feedback of analysis results in source code
        transformation.</para>
      </listitem>

      <listitem>
        <para>Efficient and scalable implementation.</para>
      </listitem>

      <listitem>
        <para>Unsurprising concepts, syntax and semantics for a wide audience.
        Where possible we will stay close to C and Java notation.</para>
      </listitem>

      <listitem>
        <para>Easy integration of existing tools.</para>
      </listitem>
    </itemizedlist>

    <para>Many of the above goals are to a certain extent already met in the
    current design of ASF+SDF, and the current design of RScript. What is
    missing is the connection (and to be honest: an efficient implementation
    of relational operators). Alas, any bridge between the two languages is
    both complex to manage and an efficiency bottleneck. This work is an
    attempt to consolidate this engineering trade-off. This basically means
    that we include most features of the RScript language into ASF+SDF.
    Although we take these languages as conceptual starting point, Rascal is a
    completely new design that has an imperative semantics at it's core rather
    than a functional semantics. As a whole, Rascal is a simpler but more
    expressive language.</para>
  </section>

  <section>
    <title>Rascal for various audiences</title>

    <para>In this section we enumerate numerous facts about Rascal that
    advertise it to different audiences</para>

    <section>
      <title>Generic arguments</title>

      <para>What is good about Rascal in a few words?</para>

      <itemizedlist>
        <listitem>
          <para>Rascal is a DSL for source code analysis and transformation.
          It provides a pletora of high level statements and expressions,
          taking away the boilerplate of implementing and debugging tools that
          manipulate programs.</para>
        </listitem>

        <listitem>
          <para>Rascal combines the best features of imperative programming
          with the best features of functional programming and term rewriting.
          <itemizedlist>
              <listitem>
                <para>Simple structured statements for control flow and
                variable assignments for data flow are powerful and simple
                features of the imperative programming paradigm. They allow
                control flow and data flow to be understandable and
                traceable.</para>
              </listitem>

              <listitem>
                <para>From functional programming we borrow that all values
                are immutable and non-null. Issues with aliasing and
                referential integrity, such as frequently occur in imperative
                and OO programming therefore do not exist in Rascal.</para>
              </listitem>

              <listitem>
                <para>The Rascal type system is as powerful as most functional
                languages (higher-order polymorphic functions), however to
                make the language debuggable and understandable it, in
                principle, does not provide type inference.</para>
              </listitem>

              <listitem>
                <para>From term rewriting we inherit powerful pattern matching
                facilities, integration with context-free parsing and concrete
                syntax.</para>
              </listitem>
            </itemizedlist></para>
        </listitem>

        <listitem>
          <para>Rascal supports both a scripting experience, and a compiled
          program experience.</para>
        </listitem>

        <listitem>
          <para>Rascal is type safe, but flexible. It's type system prevents
          common programming errors, but still allows ample opportunity for
          reusable code. The reasons are that we allow co-variance in the
          sub-typing relationship, high-order polymorphic functions and
          parameterized data-types.</para>
        </listitem>

        <listitem>
          <para>Rascal allows different styles of programming. From extremely
          high level specification, down to straight imperative
          programming.</para>
        </listitem>

        <listitem>
          <para>Rascal was inspired by and borrows from several other DSL's
          for program analysis and transformation in academia and industry,
          namely ASF+SDF, Rscript, TXL, TOM, DMS, Stratego, Elan, Maude, Grok,
          Haskell, ML and SETL.</para>
        </listitem>

        <listitem>
          <para>Rascal integrates seemlessly with Eclipse IMP and The
          Meta-Environment.</para>
        </listitem>
      </itemizedlist>
    </section>

    <section>
      <title>Rascal for ASF+SDF programmers</title>

      <para>Rascal is the successor of ASF+SDF. What's the difference? What's
      the same?</para>

      <itemizedlist>
        <listitem>
          <para>Rascal has roughly all the high level features of ASF+SDF and
          some more. Old ASF+SDF specifications can be transformed to Rascal
          programs using a conversion tool.<note>
              <para>Such a conversion tool is not yet available.</para>
            </note></para>
        </listitem>

        <listitem>
          <para>Rascal still uses SDF for syntax definition and parser
          generation.</para>
        </listitem>

        <listitem>
          <para>Rascal has a module system that is independent of SDF. Rascal
          modules introduce a namespace scope for variables and functions,
          which can be either private or public. Rewrite rules are global as
          in ASF+SDF. Modules can have type parameters as in SDF, which are
          instantiated by import statements.</para>
        </listitem>

        <listitem>
          <para>In Rascal, patterns and variables in concrete syntax may
          optionally be quoted and escaped, and support explicit declaration
          of the top non-terminal to solve ambiguity.</para>
        </listitem>

        <listitem>
          <para>In ASF+SDF the execution order of the elements of equations is
          left-hand side (for matching), conditions, and right-hand side (for
          constructing a normal form). In Rascal the elements of rules read in
          a more natural order that corresponds with the order of
          execution.</para>
        </listitem>

        <listitem>
          <para>Rascal has primitive and efficient implementations for lists,
          sets, relations and maps.</para>
        </listitem>

        <listitem>
          <para>Rascal can be used without SDF, supporting for example regular
          expressions and abstract data types (pure ATerms)</para>
        </listitem>

        <listitem>
          <para>Rascal has primitive support for functions, which have a fixed
          syntax, always return a value and have a body consisting of
          imperative control flow statements. Adding a function will not
          trigger the need for regenerating parse tables as is the case in the
          current ASF+SDF implementation. Function types can be polymorphic in
          their parameters and also allow functions as arguments to implement
          reusable algorithms.</para>
        </listitem>

        <listitem>
          <para>The imperative nature of Rascal allows you to factor out
          common code and nest conditionals, unlike in ASF+SDF where
          alternative control flow paths have to be encoded by enumerating
          equations with non-overlapping conditions.</para>
        </listitem>

        <listitem>
          <para>Rascal is an imperative language, which natively supports I/O
          and other side-effects without work-arounds. When backtracking
          occurs, for example during list matching, Rascal makes sure that
          side-effects are undone, and that I/O is delayed until no more
          backtracking can occur. Even rewrite rules support side-effects in
          Rascal.</para>
        </listitem>

        <listitem>
          <para>Rascal has native support for traversals, instead of the
          add-on it used to be in ASF+SDF. The visit statement is comparable
          to a traversal function, and is as type-safe as the previous, and
          more programmeable.</para>
        </listitem>

        <listitem>
          <para>Instead of accumulator values of traversal functions in
          ASF+SDF, Rascal simply supports lexically scoped variables that can
          be updated using assignments.</para>
        </listitem>

        <listitem>
          <para>Rascal adds specific expressions for relational calculus, all
          borrowed directly from RScript.</para>
        </listitem>

        <listitem>
          <para>When programming using Rascal functions, instead of rules, the
          control flow of a program becomes easily traceable and debuggable.
          It is simply like stepping through well structured code.</para>
        </listitem>

        <listitem>
          <para>Rascal is based on a Java interpreter, or a Java run-time when
          compiled. So the code is more portable.</para>
        </listitem>

        <listitem>
          <para>Rascal can easily call any Java method.</para>
        </listitem>
      </itemizedlist>
    </section>

    <section>
      <title>Rascal for imperative and object-oriented programmers</title>

      <para>Rascal is an imperative DSL with high-level statements and
      expressions specifically targeted at the domain of analysis and
      transformation of source code:</para>

      <itemizedlist>
        <listitem>
          <para>Rascal is safe: there are no null values, and all values are
          immutable. Source code and abstract syntax trees, and the facts
          extracted from them are immutable. The Rascal interpreter and
          compiler make sure this is implemented efficiently. Without
          mutability it is easy to combine stages of your programs that
          analyse or annotate with stages that transform. Sharing a value does
          not introduce a coupling like in OO, simply because changes are only
          visible to the code that changes the values.</para>
        </listitem>

        <listitem>
          <para>Rascal is extra safe: it has a type system that prevents
          casting exceptions and other run-time failures. Still the type
          system specifically allows many kinds of combinations. It provides
          subtyping which allows you to reuse algorithms. It also provides
          true polymorphic and functions (no erasure), and functions can
          safely be parameters to other functions.</para>
        </listitem>

        <listitem>
          <para>Rascal provides high-level statements and expressions
          for:</para>

          <itemizedlist>
            <listitem>
              <para>Visitors in all kinds of orders, expressed very concisely,
              and type safe.</para>
            </listitem>

            <listitem>
              <para>Pattern matching and construction (with concrete
              syntax!).</para>
            </listitem>

            <listitem>
              <para>Equation/constraint solving.</para>
            </listitem>

            <listitem>
              <para>Relational calculus.</para>
            </listitem>

            <listitem>
              <para>Rewrite rules for normalization/canonicalization of any
              kind of data-structure.</para>
            </listitem>

            <listitem>
              <para>Support for parsing using context-free grammars (via
              importing modules from the SDF language).</para>
            </listitem>

            <listitem>
              <para>(de)Serialization of values</para>
            </listitem>

            <listitem>
              <para>Communication with databases.</para>
            </listitem>
          </itemizedlist>
        </listitem>

        <listitem>
          <para>Rascal provides typed data constructors for common
          mathematical structures, such as:</para>

          <itemizedlist>
            <listitem>
              <para>lists</para>
            </listitem>

            <listitem>
              <para>sets</para>
            </listitem>

            <listitem>
              <para>maps</para>
            </listitem>

            <listitem>
              <para>tuples</para>
            </listitem>

            <listitem>
              <para>relations</para>
            </listitem>

            <listitem>
              <para>graphs</para>
            </listitem>

            <listitem>
              <para>terms (a.k.a. abstract data types, tree nodes)</para>
            </listitem>

            <listitem>
              <para>parse trees (derivations of context-free grammars, for
              concrete syntax and direct manipulation of source code)</para>
            </listitem>
          </itemizedlist>
        </listitem>

        <listitem>
          <para>In Rascal you can implement high-fidelity source-to-source
          transformations. Without too much overhead, programs can do
          extensive rewriting of the source code without the loss of
          particular layout standards or source code comments.</para>
        </listitem>

        <listitem>
          <para>Rascal is syntax-safe. When you use Rascal to generate or
          transform source code, it statically detects whether the resulting
          source code is syntactically correct.</para>
        </listitem>

        <listitem>
          <para>Rascal is executed by an interpreter written in Java, or it
          can be compiled to Java classes.<note>
              <para>Currently only an interpreter is available.</para>
            </note></para>
        </listitem>
      </itemizedlist>
    </section>
  </section>

  <section>
    <title>Requirements</title>

    <para><itemizedlist>
        <listitem>
          <para>R1: Runtime speed: large-scale analysis of facts is expensive
          (frequently high-polynominal and exponential algorithms). A factor
          speedup can mean the difference between a feasible and an unfeasible
          case.</para>
        </listitem>

        <listitem>
          <para>R2: Old ASF+SDF programs are translatable to Rascal.</para>
        </listitem>

        <listitem>
          <para>R3: Edit Rascal and SDF and compile complex programs within a
          few minutes maximally (parsetable generation is a major bottleneck
          in current ASF+SDF. This needs to be fixed.)</para>
        </listitem>

        <listitem>
          <para>R4: Concrete syntax: for readability and easy parsing of a
          wide range of source languages.</para>
        </listitem>

        <listitem>
          <para>R5: File I/O.</para>
        </listitem>

        <listitem>
          <para>R6: Easily accessible fact storage (similar to a heap, but
          remember the details of backtracking, see R19).</para>
        </listitem>

        <listitem>
          <para>R7: List matching (because of R2, also very handy for
          manipulating lists in concrete syntax).</para>
        </listitem>

        <listitem>
          <para>R8: Nesting of data-structures: relations can be nested to
          model nested features of programming languages (such as scoping),
          allowing to factor out common code.</para>
        </listitem>

        <listitem>
          <para>R9: Syntax trees can be elements of the builtin
          data-structures (but not vice versa).</para>
        </listitem>

        <listitem>
          <para>R10: Try to keep features orthogonal: try to keep the number
          of ways to write down a program minimal, this is not a law since
          other requirements take precedence</para>
        </listitem>

        <listitem>
          <para>R11: Minimize possible syntactic ambiguities; resolve them by
          type checking.</para>
        </listitem>

        <listitem>
          <para>R12: Integrates well with refactoring infra-structure (i.e.
          can provide appropriate interfaces with pre-condition checking,
          previews and commits as found in interactive refactoring
          contexts)</para>
        </listitem>

        <listitem>
          <para>R13: No 'null' values, preventing common programming
          errors</para>
        </listitem>

        <listitem>
          <para>R14: All values immutable, preventing common programming
          errors and allowing for certain kinds of optimizations</para>
        </listitem>

        <listitem>
          <para>R15: Should be able to match and construct strings using
          regular expressions (for making the simpler things simple, if you
          can do without a grammar, why not?)</para>
        </listitem>

        <listitem>
          <para>R16: Can get/set data from databases, such as the pdb from
          Eclipse IMP, but possibly also from ODBC/JDBC data sources.</para>
        </listitem>

        <listitem>
          <para>R17: Type safe, but flexible. We want a type system that
          prevents common programming errors, but still allows ample
          opportunity for reuse.</para>
        </listitem>

        <listitem>
          <para>R18: Syntax safe, programmers should not be allowed to
          construct programs that are syntactically incorrect w.r.t a certain
          context-free grammar.</para>
        </listitem>

        <listitem>
          <para>R19: Backtracking safe, programmers should not have to deal
          with the mind boggling feature interactions between side-effects and
          backtracking.</para>
        </listitem>

        <listitem>
          <para>R20: Traceable/debuggable, programmers should be able to
          easily trace through the execution of a Rascal program using the
          simplest of debugging tools, like printf statements, and the use of
          a simple debugging interface which allows to step through the source
          code and inspect values in a transparent fashion.</para>
        </listitem>

        <listitem>
          <para>R21: Minimize the use of type inference, such that the
          programmer must always declare her intentions by providing types for
          functions, data-types and variables. This makes debugging easier and
          providing clear error messages too. When variables are implicitly
          bound by pattern matching or related functionality, exceptions to
          this requirement might be made in favor of conciseness.</para>
        </listitem>

        <listitem>
          <para>R22: Allow the implementation of reusable modules and
          functions (i.e. parametric polymorphism and or functions as
          parameters).</para>
        </listitem>

        <listitem>
          <para>R23: We need something like rewrite rules for implementing
          data-types that are always canonicalized/normalized. For some
          analysis algorithms this allows the programmer to implement domain
          specific optimizations over plain relational calculus or tree
          visiting that actually needed for scalability.</para>
        </listitem>
      </itemizedlist></para>
  </section>

  <section>
    <title>Rascal at a glance</title>

    <para>Rascal consists of the following elements:</para>

    <itemizedlist>
      <listitem>
        <para>Modules to group definitions, proving scopes and visibility
        constructs.</para>
      </listitem>

      <listitem>
        <para>A type system and corresponding values, providing parameterized
        types, polymorphic functions and higher-order parameters.</para>
      </listitem>

      <listitem>
        <para>Variables to associate a name with a value in some scope.</para>
      </listitem>

      <listitem>
        <para>Parameterized functions.</para>
      </listitem>

      <listitem>
        <para>Abstract patterns, regular expression patterns and syntax
        patterns to deconstruct (match) values and to construct (make)
        them.</para>
      </listitem>

      <listitem>
        <para>Expressions provide the elementary computations on
        values.</para>
      </listitem>

      <listitem>
        <para>Statements provide structured control flow and more advanced
        control flow in computations, such as visitors and fixed point
        computations</para>
      </listitem>
    </itemizedlist>

    <para>These elements are summarized in the following subsections.</para>

    <section>
      <title>Modules</title>

      <para>Modules are the organizational unit of Rascal.</para>

      <para>Declarations may be either private to a module or public to all
      modules that import the current module. Rules are always public and are
      globally applied.</para>

      <para>Modules introduce a namespace and qualified names (using the
      <literal>::</literal> operator) may be used to uniquely identify
      elements of a module from the outside. Inside the module, this
      qualification is implicit. The qualified name consists of two parts: a
      directory name (a list of names separated by <literal>::</literal>) and
      a module name.</para>

      <para>Rascal modules are located in a file with the name of the module,
      with suffix <literal>.rascal</literal>. They should be located in a
      directory corresponding to the directory part of the module name. The
      qualified name of a module should correspond to its location in the
      filesystem. From other modules,
      <literal><replaceable>M</replaceable>::<replaceable>F</replaceable></literal>
      denotes function <replaceable>F</replaceable> from module
      <replaceable>M</replaceable>.</para>

      <para>Modules may:</para>

      <itemizedlist>
        <listitem>
          <para>Import another Rascal module (suffix:
          <literal>.rascal</literal>) using <literal>import</literal>. Suppose
          that module M imports another module N. All public names declared in
          imported module N become available in the importing module M. Import
          is not transitive regarding visibility, i.e., only the public names
          declared in M are visible outside M, but the public names of N are
          invisible outside M. We do allow circular imports.</para>

          <note>
            <para>The current implementation still uses the
            <literal>.rsc</literal> suffix.</para>
          </note>
        </listitem>

        <listitem>
          <para>The following options exist to locate Rascal modules:</para>

          <itemizedlist>
            <listitem>
              <para>The environment variable <literal>RASCALPATH</literal>
              contains a colon-separated list of directories to be searched
              for when a module is to be imported.</para>
            </listitem>

            <listitem>
              <para>At the command line, this same path can be given via the
              argument:
              <literal>--RASCALPATH=<replaceable>colon-separated-list.</replaceable></literal></para>
            </listitem>

            <listitem>
              <para>The command line argument
              <literal>-I<replaceable>directory</replaceable></literal> adds
              <replaceable>directory</replaceable> to the current
              <literal>RASCALPATH</literal>.</para>
            </listitem>
          </itemizedlist>
        </listitem>

        <listitem>
          <para>Import SDF modules (suffix: <literal>.sdf</literal>) using
          <literal>import</literal>.</para>
        </listitem>

        <listitem>
          <para>Extend another Rascal module using <literal>extend</literal>.
          Extend is similar to import but treats visibility differently.
          Suppose that module M extends another module N. All private and
          public names declared in imported module N become available in the
          importing module M. Extend is are transitive regarding visibility,
          i.e., only the public names declared in M are visible outside M, but
          the private and public names of N are invisible outside M. We do
          allow circular imports. We allow redefinitions of declared names. We
          do not allow circular extension.<caution>
              <para>Not yet implemented.</para>
            </caution></para>
        </listitem>

        <listitem>
          <para>Define data, views on data, types, rules or functions.<caution>
              <para>Views are not yet implemented.</para>
            </caution></para>
        </listitem>

        <listitem>
          <para>Be parameterized with the names of formal types that are
          instantiated with an actual type when the module is imported.</para>
        </listitem>

        <listitem>
          <para>May contain a main function that is the starting point of
          execution. We allow one flavour of main function<programlisting>public void main(list[str] argv) { ... }</programlisting></para>

          <para>that gives access to all program arguments. We may add extra
          types that help in parsing command line arguments. When invoked at
          the command line, another function (with the same signature) may be
          called.</para>
        </listitem>

        <listitem>
          <para>Another common idiom is for a module to have a test
          function<programlisting>public void test() { ... }</programlisting></para>

          <para>that can be called for the purpose of unit testing.</para>
        </listitem>
      </itemizedlist>
    </section>

    <section>
      <title>Names</title>

      <para>Rascal aims at seamless integration with Java and its names adhere
      to the following conventions:</para>

      <itemizedlist>
        <listitem>
          <para>A Rascal Name is identical to a Java Identifier except that we
          do <emphasis>not</emphasis> allow the dollar sign
          (<literal>$</literal>) in names. To maintain compatibility with SDF
          names , we map dashes (<literal>-</literal>) in SDF names to
          underscores (<literal>_</literal>). In the initial implementation
          all reserved words in both Java and Rascal cannot be used as a Name.
          <remark>For better syntax errors it is probably better to warn for
          Java keywords later on.</remark></para>
        </listitem>

        <listitem>
          <para>Sorts and Symbols are inherited from SDF but we extend sort
          (that may only start with an uppercase letter in SDF) to be a more
          liberal, and allow Names instead.</para>
        </listitem>
      </itemizedlist>
    </section>

    <section>
      <title>Types and Subtypes</title>

      <section>
        <title>Types</title>

        <para>The type system (and notation) are mostly similar to that of
        Rscript, but</para>

        <itemizedlist>
          <listitem>
            <para>We have a type hierarchy that defines a partial order on
            types.</para>
          </listitem>

          <listitem>
            <para>There is a single top for this type hierarchy, it is called
            "<literal>value</literal>" and a single bottom that is called
            "<literal>void</literal>".</para>
          </listitem>

          <listitem>
            <para>There are built-in elementary types
            (<literal>bool</literal>, <literal>int</literal>,
            <literal>real</literal>, <literal>str</literal>,
            <literal>loc</literal>).</para>
          </listitem>

          <listitem>
            <para>Symbols (as defined by an SDF module) are also types.<note>
                <para>There is no automatic mapping between the built-in types
                and types generated by an SDF module. The programmer is
                responsible for conversion. Typical library functions that are
                helpfull are:</para>

                <itemizedlist>
                  <listitem>
                    <para><literal>toString</literal> converts any value of an
                    SDF type to a string.</para>
                  </listitem>

                  <listitem>
                    <para><literal>toInt</literal> converts strings to
                    integers.</para>
                  </listitem>

                  <listitem>
                    <para><literal>toReal</literal> converts strings to
                    reals.</para>
                  </listitem>
                </itemizedlist>
              </note></para>
          </listitem>

          <listitem>
            <para>All syntactic types are a subtype of the type
            <literal>"node"</literal> that corresponds to an Universal Parse
            Tree Representation (UPTR). We will use AsFix as UPTR. Up casts
            from a subtype to an enclosing type are automatic. The type
            <literal>tree</literal> is "special" in the following
            sense:</para>

            <itemizedlist>
              <listitem>
                <para>Parsers generate values of type
                <literal>node</literal>.</para>
              </listitem>

              <listitem>
                <para>Although the type <literal>node</literal> can be defined
                in Rascal, its definition is built-in in order to preserve the
                consistency with the parser.</para>
              </listitem>
            </itemizedlist>
          </listitem>

          <listitem>
            <para>Types for lists, sets, maps, tuples, and relations can be
            formed from types; maps, tuples and relations can have optional
            column names. Note that a map resembles a function and differs
            from a binary relation: for each domain value in a map only a
            single range value is allowed.</para>
          </listitem>

          <listitem>
            <para>Functions can be polymorphic in their parameters.</para>
          </listitem>

          <listitem>
            <para>Function parameters can be function types, meaning that the
            name of a properly typed function or a locally defined anonymous
            function can be passed as a parameter.</para>
          </listitem>

          <listitem>
            <para>The last parameter of a function may be of the form
            <literal><replaceable>Type</replaceable>
            <replaceable>Name</replaceable>...</literal> and indicates a
            variable list of remaining parameters of type
            <replaceable>Type</replaceable>.</para>
          </listitem>

          <listitem>
            <para>Data declarations may introduce new structured types and
            have the form<programlisting>data N = Pat1 | Pat2 | ...</programlisting>where
            N is the name of the datatype and Pat1, Pat2, are prefix patterns
            describing the variants of the datatype. For instance,
            <programlisting>data Bool = btrue | bfalse | band(Bool L, Bool R)  | bor(Bool L, Bool R);  </programlisting>defines
            the datatype <literal>Bool</literal> that contains various
            constants and constructor functions.<note>
                <para>We assume that all constructors for a datatype lead to a
                corresponding function to construct a term of that datatype.
                This eliminates the need to quote abstract terms in
                statements.</para>
              </note></para>

            <note>
              <para>Constructor names of datatypes may be quoted using a
              backslash (<literal>\</literal>) in order to avoid clashes with
              reserved words.</para>
            </note>

            <note>
              <para>There is no support for nameless constructors: every
              alternative of a datatype needs to define an explicit
              constructor.</para>
            </note>
          </listitem>

          <listitem>
            <para>We have <emphasis>views</emphasis> on data types that define
            templates or overlays over an existing type. A view defines a
            (possibly complex) pattern that matches the structure of another
            datatype. A view provides an alternative (and possibly simplified)
            access mechanism for existing data structures. A standard example
            is to define a view on a parse tree that suppresses all auxiliary
            information and better reflects the actual abstract tree that is
            represented as in<programlisting>view Bool &lt;: tree = and appl(...) | or appl(...)</programlisting></para>

            <para>This defines the type <literal>Bool</literal> as a view on
            trees with two alternatives named <literal>and</literal> and
            <literal>or</literal>. Each view should be of type
            <literal>tree</literal>. Views for the same type are
            exclusive.<caution>
                <para>Views are not yet implemented.</para>
              </caution></para>
          </listitem>

          <listitem>
            <para>Parse trees are implicitly defined by a data declaration and
            we provide APIGEN-like functionality to access their elements by
            automatically providing views for each SDF rule:</para>

            <itemizedlist>
              <listitem>
                <para>Elements of an SDF syntax rule may be explicitly
                labelled as in:<programlisting> lhs1:EXP "+" lhs2:EXP -&gt; EXP {left}</programlisting>In
                this case the selectors <literal>lhs1</literal> and
                <literal>lhs2</literal> are provided that can be used to
                select (or replace) one of the subtrees of this rule.</para>
              </listitem>

              <listitem>
                <para>If these labels are absent, an automatic naming scheme
                is used:</para>

                <itemizedlist>
                  <listitem>
                    <para>For each sort in the SDF rule, a selector with the
                    same name is provided.</para>
                  </listitem>

                  <listitem>
                    <para>Syntactic lists get the name of the element sort,
                    followed by "<literal>-list</literal>".</para>
                  </listitem>

                  <listitem>
                    <para>Optionals get the name of the element sort, followed
                    by "<literal>-opt</literal>".</para>
                  </listitem>
                </itemizedlist>

                <para>In case there are more occurrences of the same syntactic
                element, the provided selector names are consecutively
                numbered, e.g., <literal>EXP1</literal>,
                <literal>EXP2</literal> or <literal>STATEMENT-list1</literal>,
                <literal>STATEMENT-list2</literal>.</para>
              </listitem>
            </itemizedlist>

            <caution>
              <para>Parsing and Parse trees are not yet implemented.</para>
            </caution>
          </listitem>

          <listitem>
            <para>Types may include type variables like
            <literal>&amp;<replaceable>T</replaceable></literal> as in Rscript
            with the following refinement:</para>
          </listitem>

          <listitem>
            <para>An alias declaration introduces a new name for an existing
            type, e.g.,<programlisting>alias Graph = rel[Node,Node];</programlisting>introduces
            the name <literal>Graph</literal> as a shorthand for
            <literal>rel[Node,Node]</literal>.</para>
          </listitem>

          <listitem>
            <para>The name that is introduced by an alias declaration may even
            be parameterized with one or more type variables,
            e.g.,<programlisting>alias Graph[&amp;Node] = rel[&amp;Node, &amp;Node];</programlisting></para>

            <para>Of course, the type variables that are used in the type in
            the left part should occur as parameters in the right part of the
            definition and vice versa.</para>
          </listitem>

          <listitem>
            <para>Types may be declared only once and are mutually
            exclusive.</para>
          </listitem>
        </itemizedlist>
      </section>

      <section>
        <title>Subtypes</title>

        <para><note>
            <para>This section has to be checked for compatibility with the
            current situation.</para>
          </note>The type hierarchy leads to a subtype relation &lt;: that can
        be defined (in ASF+SDF) as follows:<programlisting>%% Subtyping rules (&lt;:) on Types

[let00] void &lt;: T                          = true

[let01] T &lt;: value                         = true

[let02] T &lt;: T                             = true

[let03] T &lt;: &amp; N                           = true

[let04] T &lt;: &amp;N &lt;: T'                      = T &lt;: T'

[let05] N[&amp;T] &lt;: N[&amp;U]                     = true

[let06] list[T] &lt;: list[T']                = T &lt;: T'

[let07] set[T] &lt;: set[T']                  = T &lt;: T'

[let08] tuple[ONTs] &lt;: tuple[ONTs']        = ONTs &lt;: ONTs'

[let09] map[T1, T2] &lt;: map[T1', T2']       = T1 &lt;: T1' &amp;  T2 &lt;: T2'

[let10] map[T1, T2] &lt;: rel[T1', T2']       = T1 &lt;: T1' &amp;  T2 &lt;: T2'

[let11] rel[ONTs] &lt;: rel[ONTs']            = ONTs &lt;: ONTs'

[let12] rel[ONTs] &lt;: set[tuple[ONTs']]     = ONTs &lt;: ONTs'

[let13] set[tuple[ONTs]] &lt;: rel[ONTs']     = ONTs &lt;: ONTs'

[let14] T &lt;: T' == true,        %% covariant
        ONTs' &lt;: ONTs == true   %% contravariant
        =========================================
        fun T N (ONTs) &lt;: fun T' N (ONTs') = true
[default-let]
        T &lt;: T'                            = false
</programlisting></para>

        <para>Here T, T1, T2, T' etc represent types, and ONTs, ONTs' etc
        represented lists of OptionallyNamedTypes, e.g., a type that
        optionally followed by a name. We omit the definition of &lt;= on
        OptionallyNamedTypes. The above rules also describe certain
        equivalences between types, e.g., a map can be compared with a
        relation, a relation can be compared with a set of tuples, and the
        like.</para>

        <para>We throw the names in types away in the subtype relation.</para>

        <para>The subtyping relation for function types is tricky and treats
        result type and argument types differently. We have, for instance,
        that</para>

        <para><programlisting>set[int] f(int i) &lt;: fun set[&amp;T] f(int i)  %% since int &lt;: &amp;T

int f(number x) &lt;: fun number f (int x)    %% assuming int &lt;: number</programlisting>but
        <emphasis>not</emphasis> that</para>

        <para><programlisting>number f(int x) &lt;: fun number f (number x) %% assuming int &lt;: number</programlisting></para>
      </section>
    </section>

    <section>
      <title>Type Equivalence</title>

      <para><warning>
          <para>OUTDATED</para>
        </warning>Types are compatible if they occur on the same path from
      void to value in the type lattice. This is a middle road between
      structural and nominal type equivalence, we call it
      <emphasis>intensional structural type equivalence</emphasis>. An example
      can illustrate this. Assume we have the following definitions for
      general graphs, control flow graphs and data flow
      graphs:<programlisting>alias Graph = rel[node,node];
alias CFGRaph = Graph;
alias DFGRaph = Graph;</programlisting></para>

      <para><literal>CFGraph</literal> and <literal>Graph</literal> are
      compatible, and the same holds for <literal>DFGraph</literal> and
      <literal>Graph</literal>. This implies that the types
      <literal>CFGraph</literal> and <literal>Graph</literal> (resp.
      <literal>DFGraph</literal> and <literal>Graph</literal>) can be freely
      passed as parameter, assigned, returned and value. This is, however, not
      true for CFGraph and DFGraph since they are incompatible. Passing a
      value from the one to the other type can only be done via the common
      type <literal>Graph</literal>. This unconventional type scheme allows
      flexible conversion between subtypes (without casting or runtime checks)
      while preserving the opaqueness of disjoint subtypes of the same
      ancestor type.</para>
    </section>

    <section>
      <title>Attributes</title>

      <para>Attributes are adornments of data and programs and come in two
      flavours:</para>

      <itemizedlist>
        <listitem>
          <para><emphasis>node annotations</emphasis> that allow associating
          one or more named values with nodes in a tree.</para>
        </listitem>

        <listitem>
          <para><emphasis>declaration tags</emphasis> that allow associating
          one or more named values to a declaration in a Rascal
          program.</para>
        </listitem>
      </itemizedlist>

      <para>The former are intended to attach application data to values, like
      adding position information or control flow information to source code
      or adding visualization information to a relation. The latter are
      intended to add metadata to a Rascal program and allow to influence the
      execution of the Rascal program, for instance, by adding memoization
      hints or database mappings for relations.</para>

      <section>
        <title>Node annotations</title>

        <para>An annotation may be associated with any node value. An
        annotation has a name and the type of its value is explicitly
        declared. Any value of any named type can be annotated and the type of
        these annotations can be declared precisely.</para>

        <para>For instance, we can add to certain syntactic constructs of
        programs (e.g., <literal>EXPRESSION</literal>) an annotation with name
        <literal>posinfo</literal> that contains location
        information:<programlisting>anno loc EXPRESSION @ posinfo;</programlisting>or
        location information could be added for all syntax
        trees:<programlisting>anno loc node @ posinfo;</programlisting></para>

        <para>We can add to the graph datatype introduced earlier, the
        annotation with name <literal>LayoutStrategy</literal> that defines
        which graph layout algorithm to apply to a particular graph,
        e.g.,<programlisting>data LayoutStrategy = "dot" | "tree" | "force" | 
                      "hierarchy" | "fisheye";

anno LayoutStrategy Graph @ strategy;</programlisting></para>

        <para>The folllowing constructs are provided for handling
        annotations:</para>

        <itemizedlist>
          <listitem>
            <para><literal><replaceable>Val</replaceable> @
            <replaceable>Anno</replaceable></literal>: get the value of
            annotation <replaceable>Anno</replaceable> of value
            <replaceable>Val</replaceable> (may be undefined!).</para>
          </listitem>

          <listitem>
            <para><literal><replaceable>Val1</replaceable>[@<replaceable>Anno</replaceable>
            = <replaceable>Val2]</replaceable></literal>: set the value of
            annotation <replaceable>Anno</replaceable> of the value
            <replaceable>Val</replaceable><replaceable>1</replaceable> to
            <replaceable>Val2</replaceable>.</para>
          </listitem>

          <listitem>
            <para><literal><replaceable>Var</replaceable> @
            <replaceable>Anno</replaceable> =
            <replaceable>Val</replaceable></literal>: set the value of
            annotation <replaceable>Anno</replaceable> of the value of
            variable <replaceable>Var</replaceable> to
            <replaceable>Val</replaceable>.</para>
          </listitem>
        </itemizedlist>
      </section>

      <section>
        <title>Declaration tags</title>

        <para><warning>
            <para>Tags are not yet implemented.</para>
          </warning><warning>
            <para>The syntax of tags has to be aligned with the syntax of
            annotations. This is done in the examples below but not yet in the
            synyax.</para>
          </warning>All declarations in a Rascal program may contain (in fixed
        positions depending on the declaration type) one or more declaration
        tags (<literal>tag</literal>). A tag is defined by declaring its name,
        the declaration type to which it can be attached, and the name and
        type of the annotation. The declaration type <literal>all</literal>,
        makes the declaration tag applicable for all possible declaration
        types. All declaration tags have the generic format
        <literal>@<replaceable>Name</replaceable>{ ... }</literal>, with
        arbitrary text between the brackets that is further constrained by the
        declared type. Here is an example of a license tag:<programlisting>tag str license on module;</programlisting>This
        will allow to write things like:<programlisting>module Booleans
@license{This module is distributed under the GPL}
...</programlisting>Other examples of declaration tags are:<programlisting>tag str todo on all             %% a todo note for all declaration types
tag void deprecated on function %% marks a deprecated function
tag int memo on function        %% bounded memoization of 
                                %% function calls
tag str doc on all              %% documentation string
tag str primitive on function   %% a primitive, built-in, function</programlisting>Here
        is an example of a documentation string as used in the Rascal standard
        library:<programlisting>public &amp;T max(set[&amp;T] R)
  @doc{Maximum of a set: max}
{
  &amp;T result = arb(R);
  for(&amp;T E : R){
    result = max(result, E);
  }
  return result;
}</programlisting></para>
      </section>
    </section>

    <section>
      <title>Variables</title>

      <para>Variables are names that have an associated scope and in that
      scope they have a value. A variable declaration consists of a type
      followed by the variable name and---depending on the syntactic
      position---they are followed by an initialization. There are no null
      values, which implies that all variables must be initialized at
      declaration time. Also, this implies that all expressions must return a
      value. Especially for functions, this means that all execution paths of
      a function must have a return statement.</para>

      <para>Variables may be introduced at the following syntactic
      positions:</para>

      <itemizedlist>
        <listitem>
          <para>As formal parameters of a function. Their scope is the
          function and they get their initial value when the function is
          called.</para>
        </listitem>

        <listitem>
          <para>Local variables in a function body maybe declared and
          initialized. Their scope is the function body. If a local variable
          is not declared, it is implicitly declared at first use and has as
          type the type of its initial value. From then on it behaves like a
          declared variable of that type.</para>
        </listitem>

        <listitem>
          <para>Variables in patterns. For patterns in match positions,
          <emphasis>declared</emphasis> variables are initialized during the
          match and their scope is the rule in which they occur. For
          <emphasis>used</emphasis> variables, their value is substituted
          during the match.</para>
        </listitem>

        <listitem>
          <para>For variables introduced by pattern matching in conditional
          statements (if-then, and while), if the condition succeeds, the
          scope of the variables are the block of code that is executed
          conditionally.</para>
        </listitem>

        <listitem>
          <para>Variables in anti-patterns are never visible, but nevertheless
          their names are reserved in the scope that they would have had when
          the pattern was a normal positive matching pattern.</para>
        </listitem>

        <listitem>
          <para>Variables that are introduced by generators in comprehensions
          or for statement, have the comprehension, respectively, for
          statement as scope.</para>
        </listitem>

        <listitem>
          <para>Global variables are declared and ALWAYS initialized at the
          top level of each module and <emphasis role="bold">these
          initialization may not contain circular
          dependencies.</emphasis></para>
        </listitem>

        <listitem>
          <para>Functions that use a global variable have to be explicitly
          declare it as well. The value of a global variable can be used and
          replaced by all functions that have locally declared it.<caution>
              <para>Shadowing?</para>
            </caution></para>
        </listitem>
      </itemizedlist>

      <para>We will see below that there are certain contexts in which
      assignments to variables are undone in the case of failure.</para>
    </section>

    <section>
      <title>Functions</title>

      <section>
        <title>Overview</title>

        <para>A function declaration consists of a visibility declaration,
        result type, a function name, typed arguments and a function body.
        Functions without a result type have type
        <literal>void</literal>.</para>

        <para>A visibility declaration is one of the keywords
        <literal>public</literal> or <literal>private</literal>
        (default).</para>

        <para>A function body is a list of statements, each terminated by a
        semi-colon. Each unique control flow path through a function must have
        a return statement, such that each function always returns a proper
        value.</para>

        <para>Functions can raise exceptions and these may -- for
        documentation purposes -- optionally be declared as part of the
        function signature (i.e., we have unchecked exceptions in contrast
        with checked exceptions in Java).</para>

        <para>Functions with the tag <literal>@memo</literal> are memo
        functions that cache previous arguments/result combinations.</para>

        <caution>
          <para>The @memo tag is not yet implemented.</para>
        </caution>
      </section>

      <section>
        <title>Overloading</title>

        <para>Functions may be <emphasis>overloaded</emphasis>, i.e.,
        functions with the same name but with different argument and result
        types can be declared. Overloading is subject to the restriction that
        if several versions of a function are declared with the same name,
        then one or more of the following conditions should hold:</para>

        <itemizedlist>
          <listitem>
            <para>the number of parameters differs;</para>
          </listitem>

          <listitem>
            <para>there is at least one parameter position with incomparable
            types w.r.t. the type hierarchy, i.e., not (A &lt;: B) and not
            (B&lt;:A).</para>
          </listitem>
        </itemizedlist>

        <para>The result type does not play a role in these conditions and
        overloading on result types is thus forbidden.</para>

        <para>Here are some examples.</para>

        <para><programlisting>%% OK, since int and real are incomparable 

int +(int a, int b) { ... }
real +(real a, real b) { ... }

%% NOT OK, since int is comparable to value 
%% (int is -- like all types -- a subtype of value)

int +(value a, value b) { ... }
int +(int a, int b) { ... }

%% OK since for every two definitions selected from this
%% set there is at least one parameter position different;
%% in this example the overloading on result types will never 
%% be used to select the function

int  +(int a, int b)
real +(int a, real b)
real +(real a, int b)
real +(real a, real b)

%% NOT OK, since arguments cannot be resolved.

int randomValue()
str randomValue()</programlisting></para>

        <para>How should overloading be resolved in the presence of type
        parameters? Our approach is simple but effective: a type parameter
        <literal>&amp;<replaceable><replaceable>T</replaceable></replaceable></literal>
        is taken to be of type <literal>value</literal>, unless it is
        explicitly constrained to be smaller than (or smaller than or equal
        to) another type U by writing
        <literal>&amp;<replaceable>T</replaceable> &lt;:
        <replaceable>U</replaceable></literal>. For the sake of overloading
        resolution, a constrained type parameter will be considered to have
        the type of the constraint, i.e., in <literal>fun
        F(&amp;<replaceable>T</replaceable> &lt; U)</literal> we assume the
        <literal>&amp;<replaceable>T</replaceable></literal> to be of type
        <literal>U</literal>.</para>

        <para>Here are more examples:</para>

        <para><programlisting>%% NOT OK, because &amp;T might be any type (i.e. value),
%% which is comparable to int

str f(int x)
str f(&amp;T x)

%% NOT OK, since both T's may bind to comparable types and
%% value and int are comparable

int f(&amp;T x, value y)
int f(&amp;T y, int x)

%% OK, since the second arguments have incomparable types

int f(&amp;T x, int y)
int f(&amp;T y, real x)</programlisting></para>
      </section>

      <section>
        <title>Formal description of overloading</title>

        <para>Given the subtype relation <literal>&lt;:</literal> defined
        earlier, we can easily formalize overloading resolution by defining
        two predicates: <literal>incomparable</literal> describes when two
        lists of OptionallyNamedTypes can be compared and
        <literal>may-overload</literal> describes when two function types
        satisfy the overloading restrictions:<programlisting>%% Incomparable

[com1] incomparable(ONTs, ONTs') = 
       not((ONTs &lt;: ONTs') | (ONTs' &lt;: ONTs))

%% May-overload

[mo-1] may-overload(fun T N (ONTs), fun T' N' (ONTs')) = 
       not(N == N') | 
       incomparable(ONTs, ONTs')</programlisting></para>
      </section>

      <section>
        <title>Anonymous Functions</title>

        <para>We also allow <emphasis>anonymous functions</emphasis>, i.e.,
        functions that are declared locally and can be passed as argument to
        another function, be returned as value of a function, or even be
        stored as value in a set or relation. <caution>
            <para>Causes aliasing; How does this interfere with backtracking?
            We may forbid write access to globals outside the current
            context.</para>
          </caution>When such functions are called they are called in the
        lexical scope in which they were defined. For instance, the Rascal
        standard Library defines a <literal>mapper</literal> function that
        applies a function to a list or set. An anonymous function can be used
        to define such function arguments. Here is a function
        <literal>addOne</literal>, that adds 1 to each element of its argument
        list:<programlisting>list[int] addOne(list[int] L)
    return mapper(L, int (int N) { return N + 1 })</programlisting></para>
      </section>

      <section>
        <title>Java Functions</title>

        <para>Functions with the tag "<literal>java</literal>" have a body
        written in Java. These functions come in two flavours: inline and
        offline definitions.</para>

        <para>Both have the following properties:</para>

        <itemizedlist>
          <listitem>
            <para>Arguments and result are pure Rascal values.</para>
          </listitem>

          <listitem>
            <para>Java functions cannot acces the global state of the Rascal
            program. Their only interface is via input parameters and a result
            value. They cannot access Rascal global variables.</para>
          </listitem>

          <listitem>
            <para>Side effects caused by Java functions in the Java state, are
            not undone in the case of backtracking.</para>
          </listitem>
        </itemizedlist>

        <note>
          <para>These Java functions are primarily intended for implementing
          library functions and for interfacing with Eclipse.</para>
        </note>

        <para>An <emphasis>inline</emphasis> definition includes the relevant
        Java code as part of the Rascal code. The body may be preceeded by a
        <literal>java-imports</literal> annotation that defines the Java
        classes needed by the body Here is the reverse function on strings as
        defined in the library:</para>

        <programlisting>public str java reverse(str s)
@doc{reverse -- return string with all characters in reverse order.}
@java-imports{import java.lang.String;}
{
   String sval = s.getValue();
   char [] chars = new char[sval.length()];
   int n = sval.length();

   for(int i = 0; i &lt; n; i++){
     chars[n - i  - 1] = sval.charAt(i);
   }
   return values.string(new String(chars));
}</programlisting>

        <para>An offline definition of a Java functions just contains a
        reference to the class that contains the methods to be called. Here is
        the offline version of the same reverse function:<programlisting>public str java reverse(str s)
@doc{reverse -- return string with all characters in reverse order.}
@javaClass{org.rascalmpl.std.String};</programlisting>Both
        styles have their merit, but the offline style wins in most cases
        since all the functionality of the Java IDE is available while writing
        the Java code.</para>
      </section>
    </section>

    <section>
      <title>Patterns</title>

      <para>We distinguish four kinds of patterns:</para>

      <itemizedlist>
        <listitem>
          <para><emphasis>Regular expression</emphasis> patterns: conventional
          regular expressions</para>
        </listitem>

        <listitem>
          <para><emphasis>Abstract</emphasis> patterns: prefix dataterms that
          are generated by a signature.</para>
        </listitem>

        <listitem>
          <para><emphasis>Syntax</emphasis> patterns: textual fragments that
          are generated by a context-free grammar.</para>
        </listitem>

        <listitem>
          <para><emphasis>Lexical</emphasis> patterns: a special case of
          syntax patterns dealing with lexical notions like identifiers,
          numeric constants, and the like.</para>
        </listitem>
      </itemizedlist>

      <para>Patterns may contain variables and can occur in two syntactic
      positions:</para>

      <itemizedlist>
        <listitem>
          <para><emphasis>Match</emphasis> positions where the patterns is
          matched against another term and the variables in the pattern are
          bound when the match is successfull. Examples of match positions
          are:</para>

          <itemizedlist>
            <listitem>
              <para>In a case construct, immediately after the
              <literal>case</literal> keyword.</para>
            </listitem>

            <listitem>
              <para>The left-hand side of a <literal>rule</literal>.</para>
            </listitem>

            <listitem>
              <para>In a generator, where generated values are matched against
              the pattern.</para>
            </listitem>
          </itemizedlist>
        </listitem>

        <listitem>
          <para><emphasis>Make</emphasis> positions where the pattern is used
          to construct a new term (after replacing any variables in the
          pattern by their values. Examples of make positions are:</para>

          <itemizedlist>
            <listitem>
              <para>In a case construct, immediately after the
              <literal>=&gt;</literal> operator.</para>
            </listitem>

            <listitem>
              <para>The right-hand side of a <literal>rule</literal>.</para>
            </listitem>

            <listitem>
              <para>As an ordinary expression in the form of a quoted syntax
              pattern, or a call to a constructor for a dataterm.</para>
            </listitem>
          </itemizedlist>
        </listitem>
      </itemizedlist>

      <para>In make positions, patterns may also contain function calls
      (written between <literal>&lt;</literal> and <literal>&gt;</literal>)
      that are replaced by their value during the construction of the pattern.
      Example:<programlisting>&lt;subst(V1, E1, Ea)&gt;</programlisting><caution>
          <para>Not yet implemented. Only string interpolation is
          available.</para>
        </caution></para>

      <para>A pattern may be turned into an <emphasis>anti-pattern</emphasis>
      by prefixing it with the symbol <literal>!</literal>. An anti-pattern
      matches in all cases where the original pattern does not match. A match
      of an anti-pattern cannot bind any variables but these variables are
      nonetheless reserved in the corresponding scope.</para>

      <caution>
        <para>Anti-patterns are not yet implemented.</para>
      </caution>

      <section>
        <title>Regular Expression Patterns</title>

        <para>Regular expression patterns are ordinary regular expressions
        that are used to match a string value and to decompose it in parts and
        also to compose new strings. Regular expression patterns bind
        variables of type <literal>str</literal> when the match succeeds,
        otherwise they do not bind anything. Their syntax and semantics
        parallels abstract and concrete syntax patterns as much as possible.
        This means that they can occur in cases of <literal>visit</literal>
        and <literal>switch</literal> statements, on the left-hand side of the
        match operator (<literal>:= or !:=</literal>) and as declarator in
        generators.</para>

        <para>We use a regular expression language that slightly extends the
        Java Regex language with the following exceptions:</para>

        <itemizedlist>
          <listitem>
            <para>Regular expression are delimited by / and / optionally
            followed by a modifier (see below).</para>
          </listitem>

          <listitem>
            <para>We allow named groups, syntax
            <literal>&lt;<replaceable>Name</replaceable>:<replaceable>Regex</replaceable>&gt;</literal>,
            which introduce a variable of type <literal>str</literal> named
            <replaceable>Name</replaceable>. Currently, these names have to
            unique in the pattern.</para>
          </listitem>

          <listitem>
            <para>Java regular expressions might have optional groups, which
            may introduce null bindings. Since null pointers are not allowed
            in Rascal, we limit the kinds of expressions one can write here by
            not allowing nesting of named groups.</para>
          </listitem>

          <listitem>
            <para>Named groups have to be outermost, such that they can only
            bind in one way.</para>
          </listitem>

          <listitem>
            <para>Unlike Perl, Java uses the notation
            <literal>(?<replaceable>Option</replaceable>)</literal> inside the
            regular expression to set options like multi-line matching
            <literal>(?m)</literal>, case-insensitive matching
            <literal>(?i)</literal> etc. We let these options follow the
            regular expression.</para>
          </listitem>

          <listitem>
            <para>We allow name use in a regular expression:
            <literal>&lt;<replaceable>Name</replaceable>&gt;</literal> which
            inserts the string value of <replaceable>Name</replaceable> in the
            pattern.</para>
          </listitem>
        </itemizedlist>

        <para>Here are some examples of regular patterns.<programlisting>/\brascal\b/i</programlisting>does
        a case-insensitive match (<literal>i</literal>) of the word rascal
        between word boundaries (<literal>\b</literal>). And<programlisting>/^.*?&lt;word:\w+&gt;&lt;rest:.*$&gt;/m</programlisting>does
        a multi-line match (<literal>m</literal>), matches the first
        consecutive word characters (<literal>\w</literal>) and assigns them
        to the variable <literal>word</literal>. The remainder of the string
        is assigned to the variable <literal>rest</literal>.</para>
      </section>

      <section>
        <title>Abstract Patterns</title>

        <para>Data declarations introduce a signature of abstract terms and
        abstract patterns can be used to perform matching on them. The same
        terms that occur in a data declaration, possibly including typed
        variables that play a similar role as pattern variables in syntax
        patterns, may be used as abstract patterns at the same position where
        concrete patterns are allowed. Lists, sets and tuples may also occur
        in abstract patterns. Here are some examples of abstract
        patterns:<programlisting>%% Assuming:
%% data Bool = band(Bool L, Bool R);
%% Bool B2;
%% An abstract pattern matching a band node:

band(btrue, B2)

%% The variable B2 can also be declared inside the pattern:

band(true, Bool B2)

%% Assuming:
%% data PICO_VALUE = intval(int) | strval(str);
%% An abstract pattern matching an intval:

intval(int n1)

%% Assuming:
%% int P, Q; 
%% list[int] Nums1, Nums2;

[Nums1, P, Q, Nums2]

%% This can also be written as:
[list[int Nums1], int P, int Q, list[int] Nums2]

%% Mixtures of variables declared outside the pattern 
%% and inside the pattern are also allowed:

[Nums1, int P, int Q, Nums2]</programlisting></para>

        <para>An abstract pattern may be preceeded by the key word
        <literal>abs</literal>, in order to resolve ambiguities with syntax
        patterns.<caution>
            <para>abs currently not implemented.</para>
          </caution><caution>
            <para>Is it wise to mix declarations in a pattern and declarations
            before hand? Considerations:</para>

            <itemizedlist>
              <listitem>
                <para>A typed declaration in a pattern is completely
                unambiguous.</para>
              </listitem>

              <listitem>
                <para>Using the value of a variable defined outside the
                pattern is also unambiguous.</para>
              </listitem>

              <listitem>
                <para>Identifying a declared but unitialized variable with a
                local declaration in a pattern is dangerous, since the meaning
                depends on the control flow outside the pattern. Proposal:
                forbid this case.</para>
              </listitem>
            </itemizedlist>
          </caution></para>
      </section>

      <section xml:id="section.patterns">
        <title>Syntax Patterns</title>

        <para><caution>
            <para>Not yet implemented.</para>
          </caution>There is a notation of a <emphasis>syntax
        pattern</emphasis>: a (possibly quoted) concrete syntax fragment that
        may contain variables. We want to cover the whole spectrum from
        maximally quoted patterns that can unambiguously describe <emphasis
        role="bold">any</emphasis> syntax fragment to minimally quoted
        patterns as we are used to in ASF+SDF. Therefore we support the
        following mechanisms:</para>

        <itemizedlist>
          <listitem>
            <para>A <emphasis>pattern variable declaration</emphasis>, written
            as <literal>&lt;<replaceable>TYPE</replaceable>
            <replaceable>NAME</replaceable>&gt;</literal> declares a new
            variable with a scope determined by the syntactic context of the
            pattern.</para>
          </listitem>

          <listitem>
            <para>A <emphasis>pattern variable use</emphasis>, written as
            <literal>&lt;<replaceable>NAME</replaceable>&gt;</literal>, uses
            the value of an already declared variabele during the use of the
            pattern.</para>
          </listitem>

          <listitem>
            <para>Quoted patterns enclosed between <literal>[|</literal> and
            <literal>|]</literal>. Inside a fully quoted string, the
            characters <literal>&lt;</literal>, <literal>&gt;</literal> and
            <literal>|</literal> can be escaped as <literal>\&lt;</literal>,
            <literal>\&gt;</literal>, <literal>\|</literal>. Fully quoted
            patterns may contain pattern variable declarations and pattern
            variable uses.</para>
          </listitem>

          <listitem>
            <para>A quoted pattern may be optionally preceeded by an SDF
            symbol to define its desired syntactic type.</para>
          </listitem>

          <listitem>
            <para>Unquoted patterns are (unquoted) syntax fragments that may
            contain pattern variable declarations and pattern variable
            uses.</para>
          </listitem>

          <listitem>
            <para>Inside syntax patterns, layout is ignored.</para>
          </listitem>
        </itemizedlist>

        <para>Quoted and unquoted patterns form the syntax patterns that are
        supported in Rascal.</para>

        <para>Examples are:</para>

        <itemizedlist>
          <listitem>
            <para>Quoted syntax pattern with two pattern variable
            declarations:<programlisting>[| while &lt;EXP Exp&gt; do &lt;{STATEMENT ";"}* Stats&gt; od |]</programlisting></para>
          </listitem>

          <listitem>
            <para>Quoted syntax pattern with two pattern variable
            uses:<programlisting>[| while &lt;Exp&gt; do &lt;Stats&gt; od |]</programlisting></para>
          </listitem>

          <listitem>
            <para>Identical to the previous example, but with a declaration of
            the desired syntactic type:<programlisting>STATEMENT [| while &lt;Exp&gt; do &lt;Stats&gt; od |]</programlisting></para>
          </listitem>

          <listitem>
            <para>Unquoted syntax pattern with two pattern variable
            declarations:<programlisting>while &lt;EXP Exp&gt; do &lt;{STATEMENT ";"}* Stats&gt; od</programlisting></para>
          </listitem>

          <listitem>
            <para>Unquoted syntax pattern with two pattern variable
            uses:<programlisting>while &lt;Exp&gt; do &lt;Stats&gt; od</programlisting></para>
          </listitem>
        </itemizedlist>

        <para>Obviously, with less quoting and type information, the
        probability of ambiguities increases. Our assumption is that a type
        checker can resolve them.</para>

        <note>
          <para>Implementation hint (used to check the examples in this
          document). For every sort S in the syntax definition add the
          following rules:</para>

          <programlisting><replaceable>S</replaceable>                   -&gt; Pattern
"&lt;<replaceable>" "S</replaceable>"? Name "&gt;"   -&gt; <replaceable>S</replaceable>      </programlisting>
        </note>
      </section>

      <section>
        <title>Lexical Patterns</title>

        <para><caution>
            <para>Not yet implemented.</para>
          </caution>A special case of syntax patterns, are lexical patterns
        that describe lexical notions such as identifiers, numeric constants
        and the like. Lexical patterns can appear as part of a concrete syntax
        pattern. Our solution is a middle road between the original solution
        used in ASF+SDF (simple but not type safe) and the current solution in
        ASF+SDF (complex but type safe). The key idea is that a constructor
        function is implicitly created for every lexical definition, i.e.,
        when the SDF definition defines the lexical sort
        <literal>LS</literal>, then the following lexical constructor function
        <literal>ls</literal> (the sort name in lower case) is implicitly
        defined:<programlisting>    ls( LEXARGS ) -&gt; LS</programlisting></para>

        <para><literal>LEXARGS</literal> consist of zero or more:</para>

        <itemizedlist>
          <listitem>
            <para>String constants.</para>
          </listitem>

          <listitem>
            <para>Typed Variables enclosed in angle brackets (as used in other
            patterns).</para>
          </listitem>
        </itemizedlist>

        <para>The <literal>LEXARGS</literal> argument combined should form a
        strings of sort <literal>LS</literal>.<note>
            <para>The current solution in ASF+SDF requires that all
            intermediate lexical constructors are explicitly written in the
            pattern. Here we relax this requirement.</para>
          </note></para>

        <para>For instance, given a lexical syntax for numbers (part of an SDF
        definition):<programlisting>sorts DIGIT NAT-CON
lexical syntax
   [0-9]    -&gt; DIGIT
   DIGIT+   -&gt; NAT-CON</programlisting></para>

        <para>A rule that would remove leading zeros looks like
        this:<programlisting>  natcon("0" &lt;DIGIT+ Ds&gt;) =&gt; natcon(&lt;Ds&gt;)</programlisting><note>
            <para>Unlike the ASF+SDF solution, it is not necessary to make a
            distinction between ordinary variables, lexical variables, and
            layout variables. Here, all variables are treated equal and their
            syntactic position determines how they are used.</para>
          </note>We also allow arbitrary character classes as type in a
        pattern variable, e.g., one could also write:<programlisting>  natcon("0" &lt;[0-9]+ Ds&gt;) =&gt; natcon(&lt;Ds&gt;)</programlisting></para>

        <para><caution>
            <para>Make lexical patterns and regular patterns more similar to
            each other.</para>
          </caution></para>

        <para>According to conventions imposed by the SDF implementation, for
        each lexically defined sort <replaceable>S</replaceable> the sorts
        <literal><replaceable>S</replaceable>-Lex</literal> (lexical
        definition of <replaceable>S</replaceable>) and
        <literal><replaceable>S</replaceable>-CF</literal> (context-free
        definition of <replaceable>S</replaceable>) are created together with
        the inclusion rule<programlisting><replaceable>S</replaceable>-Lex -&gt; <replaceable>S</replaceable>-CF</programlisting></para>

        <para>For precise typing of lexical patterns, one may have to resort
        to these generated types.<caution>
            <para>How do we parameterize layout?<programlisting>import Java[LAYOUT =&gt; JAVA-LAYOUT]</programlisting></para>
          </caution></para>
      </section>
    </section>

    <section>
      <title>Statements</title>

      <para>The different statement types are described in the following
      subsections.</para>

      <section>
        <title>Declaration and assignment</title>

        <para>Rascal provides variable declarations with optional
        initialization. If the initialization is missing, no control flow path
        may exist with use before definition. An assignment statement assigns
        a value to a variable. The left-hand side is of syntactic type
        <replaceable>Assignable</replaceable>, and may be a simple variable,
        index of variable, field selection of variable, or a combination of
        these. Assignments may be undone in the context of a failing case of a
        switch or visit statement.</para>

        <para>An assignment may also contain one of the assignment operators
        <literal>+=</literal>, <literal>-=</literal>, <literal>*=</literal>,
        <literal>/=</literal>, <literal>&amp;=</literal>,
        <literal>|=</literal> and <literal>?=</literal>.</para>
      </section>

      <section>
        <title>Standard control statements</title>

        <para>Rascal supports the following standard control
        statements:</para>

        <itemizedlist>
          <listitem>
            <para>If-then statement and if-then-else statement.</para>
          </listitem>

          <listitem>
            <para>A <literal>while</literal> statement to repeat a block of
            code while a given predicate is true.</para>
          </listitem>

          <listitem>
            <para>A do-while statement to repeat a block of code while a given
            predicate is true.</para>
          </listitem>

          <listitem>
            <para>A <literal>for</literal> statement repeats a block of code
            for each value produced by a list of generators.</para>
          </listitem>

          <listitem>
            <para>A <literal>return</literal> statement returns a value from a
            function, or just returns (for functions with result type void).
            Note that return jumps out of an entire function, even if it is
            nested in a complicated control flow statement such as
            visit.</para>
          </listitem>
        </itemizedlist>
      </section>

      <section>
        <title>Exception handling</title>

        <para>A <literal>try</literal> statement can be used to execute a
        statement and to catch any exception raised by that statement and
        resembles the corresponding Java construct:<programlisting>try
<replaceable>    Statement</replaceable>
catch <replaceable>Pattern</replaceable> : <replaceable>Body1</replaceable>
catch <replaceable>Body2</replaceable>
...
finally: Body3</programlisting>A throw statement can raise an exception. There
        are two kinds of exceptions:</para>

        <itemizedlist>
          <listitem>
            <para><emphasis>soft</emphasis> exceptions that can be raised and
            caught by the Rascal program.</para>
          </listitem>

          <listitem>
            <para><emphasis>hard</emphasis> exceptions that cannot be caught
            by the Rascal program and cause termination of the program.</para>
          </listitem>
        </itemizedlist>

        <para>The Rascal Standard Library contains the module
        <literal>Exception</literal> that defines a data type
        <literal>RunTimeException</literal> that lists all soft
        exceptions:</para>

        <para><programlisting>data RuntimeException = 
      EmptyList
    | EmptyMap 
    | EmptySet
    | IndexOutOfBounds(int index)
    | AssertionFailed 
    | AssertionFailed(str label)
    | NoSuchElement(value v)
    | IllegalArgument(value v)
    | IllegalArgument
    | IO(str message)
    | FileNotFound(str filename)
    | LocationNotFound(loc location)
    | PermissionDenied
    | PermissionDenied(str message)
    | ModuleNotFound(str name)
    | NoSuchKey(value key)
    | NoSuchAnnotation(str label)
    | Java(str message)
    ;</programlisting></para>

        <para>Rascal code that uses exceptions must import the
        <literal>Exception</literal> module.</para>

        <para>New exceptions can be added by extending the
        <literal>RunTimeException</literal> data type, for instance:</para>

        <para><programlisting>data RunTimeException =
     MyUserException(str message);</programlisting></para>
      </section>

      <section>
        <title>Switch and fail statement</title>

        <para>A <literal>switch</literal> statement is similar to a switch
        statement in C or Java and has the form:<programlisting>switch ( <replaceable>Expression</replaceable> ) {
case <replaceable>Rule</replaceable>1;
case <replaceable>Rule</replaceable>2;
...
default: ...
}</programlisting></para>

        <para>The value of the expression is the subject term that will be
        matched by the successive cases in the switch statement. This
        corresponds to the matching provided by the left-hand sides of a set
        of rewrite rules. However, the switch statement provides <emphasis
        role="bold">only</emphasis> matching at the top level of the subject
        term and does not traverse it. The type of the pattern in each case
        must be identical to the type of the subject term (or be a subtype of
        it). If no case matches, the switch acts as a dummy statement. There
        is no fall through from one case to the next.</para>

        <para>Each case contains a Rule that can have one of the following
        forms:</para>

        <itemizedlist>
          <listitem>
            <para><programlisting><replaceable>Pattern</replaceable><replaceable>1</replaceable> =&gt; <replaceable>Pattern2</replaceable></programlisting>When
            the subject matches
            <replaceable>Pattern</replaceable><replaceable>1</replaceable>,
            <replaceable>Pattern</replaceable><replaceable>2</replaceable> is
            returned from the enclosing function (after proper
            substitution).</para>
          </listitem>

          <listitem>
            <para><programlisting><replaceable>Pattern</replaceable> : <replaceable>Statement</replaceable></programlisting></para>

            <para>This is the most general case. When the subject matches
            <replaceable>Pattern</replaceable>, the
            <replaceable>Statement</replaceable> is executed. The execution of
            <replaceable>Statement</replaceable> should lead to one of the
            following:</para>

            <itemizedlist>
              <listitem>
                <para>Execution of a <literal>return</literal> statement that
                returns a value from the enclosing function.</para>
              </listitem>

              <listitem>
                <para>Execution of a <literal>fail</literal> statement: all
                side effects of <replaceable>Statement</replaceable> are
                undone and the next case is tried.</para>
              </listitem>

              <listitem>
                <para>None of the above: execution continues with the
                statement following the switch.</para>
              </listitem>
            </itemizedlist>
          </listitem>
        </itemizedlist>
      </section>

      <section>
        <title>Flow of control and local alternatives</title>

        <para>The flow of control in Rascal is more or less traditional,
        except that in some situations local alternatives may exist. This is
        in particular the case when using patterns that contain list or set
        patterns. In those cases, more than one match may be possible and the
        flow of control is such that these matches can be handled
        appropriately. We have the following:</para>

        <itemizedlist>
          <listitem>
            <para>The "if", "while" and do-while statement provide ordinary
            flow of control. If their condition contains a pattern match or
            generator, only the first alternative is taken.</para>
          </listitem>

          <listitem>
            <para>If the pattern in a generator provides more alternatives,
            they are all produced as values of the generator.</para>
          </listitem>

          <listitem>
            <para>The for-statement also provides ordinary flow of control and
            its condition is a list of generators.</para>
          </listitem>

          <listitem>
            <para>We have break and continue statements. <caution>
                <para>Not yet implemented. How about dropping them?</para>
              </caution></para>
          </listitem>

          <listitem>
            <para>The "switch" and "visit" construct introduce a save/commit
            barrier before and after each case. Executing a fail in the code
            associated with a case leads to undoing side-effects and
            continuation with the next case.</para>
          </listitem>

          <listitem>
            <para>We have "all" and "any" as predicates that test that all (or
            at least one element) satisfies a predicate.</para>
          </listitem>
        </itemizedlist>
      </section>

      <section>
        <title>Solve statement</title>

        <para>Rascal provides a solve statement for the solution of sets of
        simultaneous linear equations. The format is:<programlisting>with {
  <replaceable>Assignable1</replaceable> = <replaceable>Expression1</replaceable>;
  <replaceable>Assignable2</replaceable> = <replaceable>Expression2</replaceable>;
  ...
} solve
  <replaceable>Statement</replaceable></programlisting></para>

        <para>The solve statement is executed by performing the assignments in
        its body as long as the value of at least one assignable at the
        left-hand side of an assignment changes. Optionally, an
        <replaceable>Expression</replaceable> directly following the
        <literal>solve</literal> keyword, gives an upperbound on the number of
        iterations.</para>
      </section>
    </section>

    <section>
      <title>Expressions</title>

      <table xml:id="table.operators-on-datatypes">
        <title>Operators on Datatypes</title>

        <tgroup cols="11">
          <colspec align="center" />

          <thead>
            <row>
              <entry align="center">&#160;</entry>

              <entry align="center">bool&#160;</entry>

              <entry align="center">int</entry>

              <entry align="center">real</entry>

              <entry align="center">str</entry>

              <entry align="center">loc</entry>

              <entry align="center">list</entry>

              <entry align="center">tuple</entry>

              <entry align="center">set</entry>

              <entry align="center">map</entry>

              <entry align="center">rel</entry>
            </row>
          </thead>

          <tbody>
            <row>
              <entry>equal</entry>

              <entry>==</entry>

              <entry>==</entry>

              <entry>==</entry>

              <entry>==</entry>

              <entry>==</entry>

              <entry>==</entry>

              <entry>==</entry>

              <entry>==</entry>

              <entry>==</entry>

              <entry>==</entry>
            </row>

            <row>
              <entry>nequal</entry>

              <entry>!=</entry>

              <entry>!=</entry>

              <entry>!=</entry>

              <entry>!=</entry>

              <entry>!=</entry>

              <entry>!=</entry>

              <entry>!=</entry>

              <entry>!=</entry>

              <entry>!=</entry>

              <entry>!=</entry>
            </row>

            <row>
              <entry>less</entry>

              <entry>&lt;</entry>

              <entry>&lt;</entry>

              <entry>&lt;</entry>

              <entry>&lt;</entry>

              <entry>&lt;</entry>

              <entry>&lt;</entry>

              <entry>&lt;</entry>

              <entry>&lt;</entry>

              <entry>&lt;</entry>

              <entry>&lt;</entry>
            </row>

            <row>
              <entry>lesseq</entry>

              <entry>&lt;=</entry>

              <entry>&lt;=</entry>

              <entry>&lt;=</entry>

              <entry>&lt;=</entry>

              <entry>&lt;=</entry>

              <entry>&lt;=</entry>

              <entry>&lt;=</entry>

              <entry>&lt;=</entry>

              <entry>&lt;=</entry>

              <entry>&lt;=</entry>
            </row>

            <row>
              <entry>greater</entry>

              <entry>&gt;</entry>

              <entry>&gt;</entry>

              <entry>&gt;</entry>

              <entry>&gt;</entry>

              <entry>&gt;</entry>

              <entry>&gt;</entry>

              <entry>&gt;</entry>

              <entry>&gt;</entry>

              <entry>&gt;</entry>

              <entry>&gt;</entry>
            </row>

            <row>
              <entry>greatereq</entry>

              <entry>&gt;=</entry>

              <entry>&gt;=</entry>

              <entry>&gt;=</entry>

              <entry>&gt;=</entry>

              <entry>&gt;=</entry>

              <entry>&gt;=</entry>

              <entry>&gt;=</entry>

              <entry>&gt;=</entry>

              <entry>&gt;=</entry>

              <entry>&gt;=</entry>
            </row>

            <row>
              <entry>and/inter</entry>

              <entry>&amp;&amp;</entry>

              <entry></entry>

              <entry></entry>

              <entry></entry>

              <entry></entry>

              <entry>&amp;</entry>

              <entry></entry>

              <entry>&amp;</entry>

              <entry>&amp;</entry>

              <entry>&amp;</entry>
            </row>

            <row>
              <entry>or/union</entry>

              <entry>||</entry>

              <entry></entry>

              <entry></entry>

              <entry></entry>

              <entry></entry>

              <entry></entry>

              <entry></entry>

              <entry>|</entry>

              <entry>|</entry>

              <entry>|</entry>
            </row>

            <row>
              <entry>not</entry>

              <entry>!</entry>

              <entry></entry>

              <entry></entry>

              <entry></entry>

              <entry></entry>

              <entry></entry>

              <entry></entry>

              <entry></entry>

              <entry></entry>

              <entry></entry>
            </row>

            <row>
              <entry>Implication</entry>

              <entry>==&gt;</entry>

              <entry></entry>

              <entry></entry>

              <entry></entry>

              <entry></entry>

              <entry></entry>

              <entry></entry>

              <entry></entry>

              <entry></entry>

              <entry></entry>
            </row>

            <row>
              <entry>Equivalence</entry>

              <entry>&lt;==&gt;</entry>

              <entry></entry>

              <entry></entry>

              <entry></entry>

              <entry></entry>

              <entry></entry>

              <entry></entry>

              <entry></entry>

              <entry></entry>

              <entry></entry>
            </row>

            <row>
              <entry>add/conc</entry>

              <entry></entry>

              <entry>+</entry>

              <entry>+</entry>

              <entry>+</entry>

              <entry></entry>

              <entry>+</entry>

              <entry>+</entry>

              <entry></entry>

              <entry></entry>

              <entry></entry>
            </row>

            <row>
              <entry>sub/diff</entry>

              <entry></entry>

              <entry>-</entry>

              <entry>-</entry>

              <entry></entry>

              <entry></entry>

              <entry>-</entry>

              <entry></entry>

              <entry>-</entry>

              <entry>-</entry>

              <entry>-</entry>
            </row>

            <row>
              <entry>prod</entry>

              <entry></entry>

              <entry>*</entry>

              <entry>*</entry>

              <entry></entry>

              <entry></entry>

              <entry></entry>

              <entry>*</entry>

              <entry>*</entry>

              <entry>*</entry>

              <entry>*</entry>
            </row>

            <row>
              <entry>div</entry>

              <entry></entry>

              <entry>/</entry>

              <entry>/</entry>

              <entry></entry>

              <entry></entry>

              <entry></entry>

              <entry></entry>

              <entry></entry>

              <entry></entry>

              <entry></entry>
            </row>

            <row>
              <entry>uminus</entry>

              <entry></entry>

              <entry>-</entry>

              <entry></entry>

              <entry></entry>

              <entry></entry>

              <entry></entry>

              <entry></entry>

              <entry></entry>

              <entry></entry>

              <entry></entry>
            </row>

            <row>
              <entry>in</entry>

              <entry></entry>

              <entry></entry>

              <entry></entry>

              <entry>in</entry>

              <entry></entry>

              <entry>in</entry>

              <entry>in</entry>

              <entry>in</entry>

              <entry>in</entry>

              <entry>in</entry>
            </row>

            <row>
              <entry>notin</entry>

              <entry></entry>

              <entry></entry>

              <entry></entry>

              <entry>notin</entry>

              <entry></entry>

              <entry>notin</entry>

              <entry>notin</entry>

              <entry>notin</entry>

              <entry>notin</entry>

              <entry>notin</entry>
            </row>

            <row>
              <entry>*-closure</entry>

              <entry></entry>

              <entry></entry>

              <entry></entry>

              <entry></entry>

              <entry></entry>

              <entry></entry>

              <entry></entry>

              <entry></entry>

              <entry></entry>

              <entry>*</entry>
            </row>

            <row>
              <entry>+-closure</entry>

              <entry></entry>

              <entry></entry>

              <entry></entry>

              <entry></entry>

              <entry></entry>

              <entry></entry>

              <entry></entry>

              <entry></entry>

              <entry>+</entry>

              <entry>+</entry>
            </row>

            <row>
              <entry>project</entry>

              <entry></entry>

              <entry></entry>

              <entry></entry>

              <entry>[ _ ]</entry>

              <entry></entry>

              <entry>[ _ ]</entry>

              <entry>[ _ ]</entry>

              <entry></entry>

              <entry>[ _ ]</entry>

              <entry>[_]</entry>
            </row>
          </tbody>
        </tgroup>
      </table>

      <para><note>
          <para>Some operators do not fit nicely in this scheme since they do
          not operate on the basic data types:</para>

          <itemizedlist>
            <listitem>
              <para><literal>@</literal> get annotation value</para>
            </listitem>

            <listitem>
              <para><literal>:=</literal> match</para>
            </listitem>

            <listitem>
              <para><literal>!:=</literal> no match</para>
            </listitem>

            <listitem>
              <para><literal>_ ? _ : _</literal> conditional expression</para>
            </listitem>

            <listitem>
              <para><literal>?</literal> isdefined operator.</para>
            </listitem>
          </itemizedlist>
        </note></para>

      <section>
        <title>Basic values</title>

        <para>Constants of type <literal>bool</literal>,
        <literal>int</literal> , <literal>real</literal>,
        <literal>str</literal> and <literal>loc</literal> are expressions. All
        operators for all datatypes are summarized in <xref
        linkend="table.operators-on-datatypes" />. The datatypes
        <literal>int</literal> and <literal>real</literal> have arbitrary
        precision.</para>

        <para>String literals permit <emphasis>interpolation</emphasis> of
        variable values: when
        <literal>&lt;<replaceable>X</replaceable>&gt;</literal> occurs inside
        a string literal, the value of the variable X is converted to string
        and replaces &lt;<replaceable>X</replaceable>&gt;. As a consequence,
        the character <literal>&lt; </literal>has to be escaped as<literal>
        \&lt;</literal> in string literals.</para>

        <para>Source locations (<literal>loc</literal>) have the following
        syntax:</para>

        <para><programlisting>loc(<replaceable>Url</replaceable>?offset=<replaceable>O</replaceable>&amp;length=<replaceable>L</replaceable>&amp;begin=<replaceable>BL</replaceable>,<replaceable>BC</replaceable>&amp;end=<replaceable>EL</replaceable>,<replaceable>EC)</replaceable></programlisting>where:</para>

        <itemizedlist>
          <listitem>
            <para><replaceable>Url</replaceable> is an arbitrary URL.</para>
          </listitem>

          <listitem>
            <para><replaceable>O</replaceable> and
            <replaceable>L</replaceable> are integer expressions giving the
            offset of this location to the begin of file, respectively , its
            length.</para>
          </listitem>

          <listitem>
            <para><replaceable>BL</replaceable> and
            <replaceable>BC</replaceable> are integers expressions giving the
            begin line and begin column.</para>
          </listitem>

          <listitem>
            <para><replaceable>EL</replaceable> and
            <replaceable>EC</replaceable> are integers expressions giving the
            end line and end column.</para>
          </listitem>
        </itemizedlist>

        <para>This element of a location value can be accessed and modified
        using the standard mechanism of field selection and field assignment.
        The corresponding field names are:</para>

        <itemizedlist>
          <listitem>
            <para><literal>url</literal></para>
          </listitem>

          <listitem>
            <para><literal>offset</literal></para>
          </listitem>

          <listitem>
            <para><literal>length</literal></para>
          </listitem>

          <listitem>
            <para><literal>beginLine</literal>,
            <literal>beginColumn</literal></para>
          </listitem>

          <listitem>
            <para><literal>endLine</literal>,
            <literal>endColumn</literal>.</para>
          </listitem>
        </itemizedlist>

        <para>Here is an example of loc value:</para>

        <para><programlisting>loc(file:/home/paulk/pico.trm?offset=0&amp;length=1&amp;begin=2,3&amp;end=4,5)</programlisting>Note
        that loc values are usually created by tools such as parsers and
        editors.</para>
      </section>

      <section>
        <title>Structured values</title>

        <para>Values of the structured types <literal>list</literal>,
        <literal>set</literal>, <literal>map,tuple</literal>, and <literal>rel
        </literal>are expressions and can be constructed as follows:</para>

        <itemizedlist>
          <listitem>
            <para>Lists are enclosed between [ and ] and the elements are
            separated by comma's, e.g.<literal> ["abc", "def"]</literal> or
            <literal>[true, false, false, true]</literal>. For lists of
            integers, a special shorthand exists to describe ranges of
            integers:</para>

            <itemizedlist>
              <listitem>
                <para><literal>[<replaceable>F</replaceable>..<replaceable>L</replaceable>]</literal>
                ranges from first element <replaceable>F</replaceable> to (and
                including) last element <replaceable>L</replaceable> with
                increments of 1.</para>
              </listitem>

              <listitem>
                <para><literal>[<replaceable>F</replaceable>,<replaceable>S</replaceable>,..<replaceable>E</replaceable>]</literal>,
                ranges from first element <replaceable>F</replaceable>, second
                element S to (and including) last element
                <replaceable>L</replaceable> with increments of
                <literal>S</literal> - <replaceable>F</replaceable>.</para>
              </listitem>
            </itemizedlist>

            <para>When variables of type list occur inside a list, their
            elements are automatically spliced into the surrounding list. This
            can be prevented by surrounding them with extra [ and ]
            brackets.</para>
          </listitem>

          <listitem>
            <para>Sets are enclosed between { and } and the elements are
            separated by comma's, e.g.<literal> {"abc", "def"}</literal> or
            <literal>{true, false}</literal>. In a similar fashion as with
            lists, sets variables are automatically spliced into a surrounding
            set. This can be prevented by surrounding them with extra { and }
            brackets.</para>
          </listitem>

          <listitem>
            <para>Tuples are enclosed between &lt; and &gt; and the elements
            are separated by comma's, e.g. <literal>&lt;1, "twee",
            3&gt;</literal>.</para>
          </listitem>

          <listitem>
            <para>Relations are sets of tuples.</para>
          </listitem>

          <listitem>
            <para>Maps are a special form of binary relation and satisfy the
            constraint that the first element of each tuple is unique. Maps
            model functions. To distinguish between map tuples and tuples in
            general relations, we write them as (E1a : E1b, E2a : E2b, ...),
            i.e. they are enclosed between ( and ) and the elements are pairs
            separated by :.</para>
          </listitem>
        </itemizedlist>

        <para>An index operator
        <literal><replaceable>R</replaceable>[<replaceable>N</replaceable>]</literal>
        can be applied to values of types string, list, tuple, map and
        relation and returns the <replaceable>N</replaceable>-th element. It
        throws the exception <literal>out_of_range(str msg)</literal> when the
        index value is out of range.</para>

        <para>For a map <replaceable>M</replaceable>,
        <replaceable>M</replaceable>[<replaceable>N</replaceable>], returns
        the single image value corresponding with
        <replaceable>N</replaceable>. This expression may also occur as
        left-hand side of an assignment:<programlisting><replaceable>M</replaceable>[<replaceable>N</replaceable>] = <replaceable>V</replaceable></programlisting>which
        first removes from <replaceable>M</replaceable> the tuple with domain
        value <replaceable>N</replaceable> and then adds the tuple
        <replaceable>N</replaceable> : <replaceable>V</replaceable>. The net
        effect is that a new map value is assigned to
        <replaceable>M</replaceable>. For relations, a subscript consisting of
        n- subscripts returns the range values that correspond to these index
        values.</para>

        <para>For all structured values, we provide comprehensions. For lists
        of the form:<programlisting>[ E | G1, ..., Gn ]</programlisting>for
        maps of the form<programlisting>( K : V | G1, ..., Gn )</programlisting></para>

        <para>and for sets and relations of the form:<programlisting>{ &lt;E1,...,Em&gt; | G1, ..., Gn }</programlisting></para>
      </section>

      <section>
        <title>Node values</title>

        <para>Syntax trees are expressions and generators in comprehensions
        may range over syntax trees.</para>

        <para>Generators may have a strategy option to indicate:</para>

        <itemizedlist>
          <listitem>
            <para><literal>top-down</literal></para>
          </listitem>

          <listitem>
            <para><literal>bottom-up</literal> (this is the default)</para>
          </listitem>
        </itemizedlist>

        <para>There are other strategy options that are only meaningfull in
        the context of a <literal>visit</literal> expression.</para>
      </section>

      <section>
        <title>Predicates</title>

        <para>Predicates are expressions that yield a value of type bool and
        include <literal>==</literal> (equal), <literal>!=</literal> (not
        equal), <literal>&lt;</literal> (less), <literal>&lt;=</literal> (less
        or equal), <literal>&gt;</literal> (greater), <literal>&gt;=</literal>
        (greater or equal). Predicates are used in control statements and in
        conditional expressions written as<programlisting><replaceable>Predicate</replaceable> ? <replaceable>Expression1</replaceable> : <replaceable>Expression2</replaceable></programlisting>Other
        predicates are:</para>

        <itemizedlist>
          <listitem>
            <para><literal>in</literal>, <literal>notin</literal>: membership
            test.</para>
          </listitem>

          <listitem>
            <para><literal>:=</literal> match</para>
          </listitem>

          <listitem>
            <para><literal>!:=</literal> nomatch</para>
          </listitem>

          <listitem>
            <para>? is defined, yields true is the expressions has a defined
            value and false otherwise</para>
          </listitem>
        </itemizedlist>
      </section>

      <section>
        <title>Visit expression and insert statement</title>

        <para>A <literal>visit</literal> expression corresponds to a traversal
        function in ASF+SDF and has the form:<programlisting><replaceable>Strategy</replaceable> visit ( <replaceable>Expression</replaceable> ) {
case <replaceable>Rule</replaceable>1;
case <replaceable>Rule</replaceable>2;
...
default: ...
}</programlisting>Given a subject term (the current value of
        <replaceable>Expression</replaceable>) and a list of cases (resembling
        cases in a case statement or rewrite rules) it traverses the term.
        Depending on the precise rules it may perform replacement (mimicking a
        transformer), update local variables (mimicking an accumulator) or a
        combination of these two. If <emphasis role="bold">any</emphasis> of
        the cases contains an <literal>insert</literal> statement, the value
        of the visit expression is a new value that is obtained by successive
        insertions in the subject term by executing one or more cases.
        Otherwise, the original value of the subject term is returned.</para>

        <para>The visit expression is optionally preceeded by one of the
        following strategy indications that determine the traversal order of
        the subject:</para>

        <itemizedlist>
          <listitem>
            <para><literal>top-down</literal></para>
          </listitem>

          <listitem>
            <para><literal>top-down-break</literal></para>
          </listitem>

          <listitem>
            <para><literal>bottom-up</literal> (this is the default)</para>
          </listitem>

          <listitem>
            <para><literal>bottom-up-break</literal></para>
          </listitem>

          <listitem>
            <para><literal>innermost</literal> = compute a fixed-point: repeat
            a bottom-up traversal as long as the traversal function changes
            values.</para>
          </listitem>

          <listitem>
            <para><literal>outermost</literal> = compute a fixed-point: repeat
            a traversal traversal as long as the traversal function changes
            values.</para>
          </listitem>
        </itemizedlist>

        <para>The execution of the cases is similar to the cases in a switch
        statement with the following exceptions:</para>

        <itemizedlist>
          <listitem>
            <para>Rules of the form ... =&gt; ... <emphasis
            role="bold">insert</emphasis> their result in the subject (instead
            of returning a value).</para>
          </listitem>

          <listitem>
            <para>For rules of the form
            <literal><replaceable>Pattern</replaceable> :
            <replaceable>Statement</replaceable></literal>, executing
            <replaceable>Statement</replaceable> should lead to one of the
            following:</para>

            <itemizedlist>
              <listitem>
                <para>Execution of an <literal>insert</literal> statement of
                the form <literal>insert
                <replaceable>Expression</replaceable></literal>. The value of
                <replaceable>Expression</replaceable> replaces the subtree of
                the subject that is currently being visited. Note that a copy
                of the subject is created at the start of the visit statement
                and all insertions are made in this copy. As a consequence,
                insertions cannot influence matches later on.<note>
                    <para>An <literal>insert</literal> statement may only
                    occur inside a <literal>visit</literal> expression.</para>
                  </note></para>
              </listitem>

              <listitem>
                <para>Execution of a <literal>fail</literal> statement: all
                side effects of <replaceable>Statement</replaceable> are
                undone, no insertion is made, and the next case is
                tried.</para>
              </listitem>

              <listitem>
                <para>Execution of a <literal>return</literal> statement that
                returns a value from the enclosing function.</para>
              </listitem>
            </itemizedlist>
          </listitem>
        </itemizedlist>

        <para>Each case keyword may be followed by a type constraint of the
        form <literal>[<replaceable>Type</replaceable>]</literal> that limits
        the type of the values to which the case applies.</para>

        <para>The precise behaviour of the visit statement depends on the type
        of the subject:</para>

        <itemizedlist>
          <listitem>
            <para>For type <literal>node or ADT</literal>, all nodes of the
            tree are visited (in the order determined by the strategy).
            SyntaxPatterns and AbstractPatterns directly match tree nodes.
            RexExpPatterns match only values of type string.</para>
          </listitem>

          <listitem>
            <para>For structured types (list, set, map, tuple, rel), the
            elements of the structured type are visited and matched against
            the cases. When inserts are made, a new structured value is
            created.<caution>
                <para>Have strategies any effect for non-tree subjects?</para>
              </caution></para>
          </listitem>
        </itemizedlist>
      </section>
    </section>

    <section>
      <title>Global rules</title>

      <para>The Rules that we have already encountered in switch and visit
      statement, can also be defined globally and are the closest to rewrite
      rules as we will get in Rascal. Unlike functions that are always called
      explicitly when needed, global rules are always applied implicitly,
      i.e., whenever a value of some type is created and there are rules
      defined for that type, they are immediately applied. In principle, rules
      can be used to define arbitrary computations. In practice, they are
      mostly used to guarantee that certain constraints are satisfied whenever
      a value of some type is created.<note>
          <para>Rules can only be applied to nodes and ADTs.</para>
        </note></para>

      <para>Rules have the general form:<programlisting>rule <replaceable>Name</replaceable> <replaceable>Rule</replaceable></programlisting>Here
      is an example for concrete Booleans:</para>

      <para><programlisting>rule a1 true &amp; &lt;Bool B2&gt;   =&gt; &lt;B2&gt;</programlisting>and
      here for abstract Booleans:</para>

      <para><programlisting>rule a1 band(btrue, Bool B2)  =&gt; B2 </programlisting></para>

      <para>As we have seen before, the replacement part may also have the
      form colon (<literal>:</literal>) followed by an arbitrary statement.
      During execution of rules the following applies:</para>

      <itemizedlist>
        <listitem>
          <para>Rules are applied non-deterministically, and in any order of
          matching.</para>
        </listitem>

        <listitem>
          <para>The right hand side of rules can contain fail statements,
          which cause backtracking over the alternative matches or alternative
          rules for a certain constructor.</para>
        </listitem>

        <listitem>
          <para>When the right-hand side is a statement, a return statement
          determines the value of the actual replacement.</para>
        </listitem>
      </itemizedlist>

      <para>As with cases, the rule keyword may be immediately followed by a
      type constraint to limit its applicability.<caution>
          <para>Default rules?</para>
        </caution></para>
    </section>

    <section>
      <title>Failure and side-effects</title>

      <para>There are two contexts in which side-effects, i.e., assignment to
      variables, have to be undone in case of failure. These contexts are a
      rule in a switch or visit statement. If the pattern on the left-handside
      of the rule matches there are various possibilities:</para>

      <itemizedlist>
        <listitem>
          <para>All control flow paths through the right-hand side of the rule
          end in a return statement. In this case, the rule can not fail and
          all side-effects caused by the execution of the right-hand side are
          committed.</para>
        </listitem>

        <listitem>
          <para>One or more control path can fail. This can be caused by an
          explicit fail statement or an if-then statement with missing
          else-branch (the missing else-branch acts as a fail). In the case of
          failure all side-effects (of local and global variables) are
          undone.</para>
        </listitem>

        <listitem>
          <para>If a rule fails there are two possibilities:</para>

          <itemizedlist>
            <listitem>
              <para>the left-hand side contains a list or set pattern that has
              more matching options; the next option is tried.</para>
            </listitem>

            <listitem>
              <para>the left-hand side contains a list or set pattern that has
              no more matching options or it contains no list or set pattern
              at all; the next rule is tried.</para>
            </listitem>
          </itemizedlist>
        </listitem>

        <listitem>
          <para>The possible choice points are:</para>

          <itemizedlist>
            <listitem>
              <para>case in a switch, visit statement.</para>
            </listitem>

            <listitem>
              <para>match of left-hand side of rule.</para>
            </listitem>

            <listitem>
              <para>Selection of a binding of list variables during list
              matching, except if there is one possibility left.</para>
            </listitem>

            <listitem>
              <para>Selection of an element by a generator.</para>
            </listitem>
          </itemizedlist>
        </listitem>

        <listitem>
          <para>The possible failure points are:</para>

          <itemizedlist>
            <listitem>
              <para>fail statement</para>
            </listitem>

            <listitem>
              <para>a predicate used as generator in a comprehension.</para>
            </listitem>
          </itemizedlist>
        </listitem>

        <listitem>
          <para>The possible success points are:</para>

          <itemizedlist>
            <listitem>
              <para><literal>return</literal> (jumps out of function scope and
              pops all choice points).</para>
            </listitem>

            <listitem>
              <para><literal>insert</literal> (jumps to enclosing switch or
              visit or rule choice)</para>
            </listitem>

            <listitem>
              <para>true predicate in comprehension (jumps to next assignment
              of generator).</para>
            </listitem>
          </itemizedlist>
        </listitem>

        <listitem>
          <para>On failure, the currently active choice point is used to undo
          side-effects and to continue execution.</para>
        </listitem>

        <listitem>
          <para>Side effects caused by built-in functions (like file i/o,
          socket communication, etc.) are <emphasis role="bold">not</emphasis>
          undone.</para>
        </listitem>
      </itemizedlist>
    </section>
  </section>

  <section>
    <title>Examples</title>

    <para>Here we list some experimental examples of Rascal code to try out
    features. Caveats:</para>

    <itemizedlist>
      <listitem>
        <para>The examples using concrete syntax have not been tested since
        concrete syntax is not yet implemented, but in most cases we have
        tested an abstract version instead.</para>
      </listitem>

      <listitem>
        <para>Not all examples are completely up-to-date.</para>
      </listitem>
    </itemizedlist>

    <para>Despite these caveats, the examples are representative of what we
    want to express.</para>

    <section>
      <title>Hello world</title>

      <para>The ritual first example:<programlisting>module Hello

import IO;

public void main() {
   println("Hello, this is my first Rascal program");
}</programlisting>Observe how the IO module is imported that defines the
      <literal>println</literal> function.</para>
    </section>

    <section>
      <title>Table of squares</title>

      <para>Another ritual example, printing a table of
      squares:<programlisting>module Squares

import IO;

public void squares(int N){
  println("Table of squares from 1 to &lt;N&gt;");
  for(int I : [1 .. N]){
      I2 = I * I;
      println("&lt;I&gt; squared = &lt;I2&gt;");
  } 
}</programlisting></para>
    </section>

    <section>
      <title>Table of word counts per file</title>

      <para><programlisting>module WordCount

import IO;
 
/* this is a * test * comment */

public void main(str argv ...){
  int total = 0;
  for(str fileName : argv){
    try {
       int count = wordCount(readFile(fileName));
       println("&lt;count&gt; word in file &lt;fileName&gt;");
       total = total + count;
    } catch {println("Skipping file &lt;fileName&gt;");}
  }
  
  println("&lt;total&gt; words in all files");
}

public int wordCount(list[str] input, int (str s) countLine)
{
  count = 0;
  for(line : input){
     count = count + #countLine(line);
  }
  return count;
}

public int countLine1(str S){
  int count = 0;
  for(/[a-zA-Z0-9]+/: S){
       count = count + 1;
  }
  return count;
}

// Here is an alternative (but less desirable) declaration:
public int countLine2(str S){
  int count = 0;
  
  // \w matches any word character
  // \W match3es any non-word character
  // &lt;...&gt; are groups and should appear at the top level.
  while (/^\W*&lt;word:\w+&gt;&lt;rest:.*$&gt;/ ~= S) { 
    count = count + 1; 
    S = rest; 
  }
  return count;
}

// Maintain word count per word.
// Note how the =? operator initializes each map entry
// to an appropriate value (0 in this case)

public map[str,int] countLine3(str S){
  map[str,int] allCounts = ();

 for(/&lt;word:[a-zA-Z0-9]+&gt;/: S){
       /* allCounts[word] ? 0 += 1; */
	/* This is the same as */
       allCounts[word] = (allCounts[word] =? 0) + 1;
  }
  return allCounts;
}

public list[str] Jabberwocky = [
	"Jabberwocky by Lewis Carroll",
	"",
	"'Twas brillig, and the slithy toves",
	"Did gyre and gimble in the wabe;",
	"All mimsy were the borogoves,",
	"And the mome raths outgrabe.",
	"",
	"\"Beware the Jabberwock, my son!",
	"The jaws that bite, the claws that catch!",
	"Beware the Jubjub bird, and shun",
	"The frumious Bandersnatch!\"",
	"",
	"'Twas brillig, and the slithy toves",
	"Did gyre and gimble in the wabe;",
	"All mimsy were the borogoves,",
	"And the mome raths outgrabe.",
	"",
	"\"Beware the Jabberwock, my son!",
	"The jaws that bite, the claws that catch!",
	"Beware the Jubjub bird, and shun",
	"The frumious Bandersnatch!\"",
	"",
	"He took his vorpal sword in hand:",
	"Long time the manxome foe he sought&#8212;",
	"So rested he by the Tumtum tree,",
	"And stood awhile in thought.",
	"",
	"And as in uffish thought he stood,",
	"The Jabberwock, with eyes of flame,",
	"Came whiffling through the tulgey wood",
	"And burbled as it came!",
	"",
	"One, two! One, two! and through and through",
	"The vorpal blade went snicker-snack!",
	"He left it dead, and with its head",
	"He went galumphing back.",
	"",
	"\"And hast thou slain the Jabberwock?",
	"Come to my arms, my beamish boy!",
	"O frabjous day! Callooh! Callay!",
	"He chortled in his joy.",
	"",
	"'Twas brillig, and the slithy toves",
	"Did gyre and gimble in the wabe;",
	"All mimsy were the borogoves,",
	"And the mome raths outgrabe."
];

bool test(){
  return 
  wordCount(Jabberwocky, #countLine1) == 215 &amp;&amp;
  wordCount(Jabberwocky, #countLine2) == 215 &amp;&amp;
  wordCount(Jabberwocky, #countLine3) == 215;
}</programlisting></para>
    </section>

    <section>
      <title>Word replacement</title>

      <para>Here are two versions of a word replacement function:</para>

      <para><programlisting>module WordReplacement

public str capOne(str S){
    return (/rascal/i ~= S) ? "Rascal" : S;
}

public str capAll1(str S)
{
 result = "";
 while (/^&lt;before:\W*&gt;&lt;word:\w+&gt;&lt;after:.*$&gt;/ ~= S) { 
    result = result + before + capOne(word);
    S = after;
  }
  return result;
}

public str capitalize(str word)
{
   if(/^&lt;letter:[a-z]&gt;&lt;rest:.*$/){
      return toUpperCase(letter) + rest;
   } else {
      return word;
   }
}

public str capAll2(str S)
{
   return visit(S){
     case /&lt;word:\w+&gt;/i =&gt; capitalize(word);
   };
}

bool test)
{
  return
  capAll1("turn this into a title") == "Turn This Into A Title" &amp;&amp;
  capAll2("turn this into a title") == "Turn This Into A Title";
}</programlisting></para>
    </section>

    <section>
      <title>Finding date-related variables</title>

      <para>In year 2000 conversions, the starting point for analysis could be
      variables with a date-related name. Here is how to find
      them:<programlisting>module DateVars

set[Var] getDateVars(Program P){
   return {V | Var V : P, 
               /.*(date|dt|year|yr).*$/i ~= toString(V)};
}</programlisting></para>
    </section>

    <section>
      <title>Booleans</title>

      <para>It seems that every language specification effort has to produce a
      specification of the Booleans at some moment, so let's try it now. We
      try several variations.</para>

      <para>We use the following common syntax:<programlisting>module Booleans-syntax
exports 
  sorts Bool

  context-free syntax
    "true"        -&gt; Bool
    "false"       -&gt; Bool
    Bool "&amp;" Bool -&gt; Bool {left}
    Bool "|" Bool -&gt; Bool {right}</programlisting></para>

      <section xml:id="section.booleans-with-visit">
        <title>Concrete Booleans defined with visit</title>

        <para>Using the visit construct that we have described above, we can
        write the definitions for the functions <literal>&amp;</literal> and
        <literal>|</literal> as follows:<programlisting>module Bool-examples1

import languages/Booleans/syntax;

Bool reduce(Bool B) {
    Bool B1, B2;
    return bottom-up visit(B) {
      case true &amp; &lt;B2&gt;   =&gt; &lt;B2&gt;
      case false &amp; &lt;B2&gt;  =&gt; false

      case true | true   =&gt; true
      case true | false  =&gt; true
      case false | true  =&gt; true
      case false | false =&gt; false
    };
}</programlisting></para>

        <para>Observe that there are two styles:</para>

        <itemizedlist>
          <listitem>
            <para>In the definition for <literal>&amp;</literal>, we use
            variables on the left-hand side: the visit is needed to fully
            normalize the result.</para>
          </listitem>

          <listitem>
            <para>In the definition of <literal>|</literal>, we use a truth
            table.</para>
          </listitem>
        </itemizedlist>
      </section>

      <section>
        <title>Abstract Booleans defined with visit</title>

        <para>In the above example we used concrete syntax for Booleans
        expressions. It also possible to define Booleans as abstract
        terms.<programlisting>module Bool-abstract-visit

data Bool btrue;
data Bool bfalse;
data Bool band(Bool L, Bool R);
data Bool bor(Bool L, Bool R);  

public Bool reduce(Bool B) {
    return innermost visit(B) {
      case band(btrue, Bool B1) =&gt; B1        // Use variables
      case band(bfalse, Bool B1)=&gt; bfalse   //TODO: should become B1!
      
      case bor(btrue, btrue)    =&gt; btrue    // Use a truth table
      case bor(btrue, bfalse)   =&gt; btrue
      case bor(bfalse, btrue)   =&gt; btrue
      case bor(bfalse, bfalse)  =&gt; bfalse
    };
}

bool test(){
	
   return reduce(bor(band(btrue,btrue),band(btrue, bfalse))) == btrue;
}</programlisting></para>

        <para>First, type declarations are used to define the abstract syntax
        of the type Bool. Next, a similar reduce function is defined as
        before, but now we use abstract patterns.</para>
      </section>

      <section>
        <title>Abstract Booleans defined with rules</title>

        <para>In ASF, values are always reduced to a normal form before they
        are created. For some applications this normalization or
        canonicalization feature is very handy. We introduce the following
        syntax, which can also help in the transformation of old ASF+SDF
        programs to Rascal:</para>

        <para><programlisting>module Bool-abstract-rules

data Bool btrue;
data Bool bfalse;
data Bool band(Bool L, Bool R);
data Bool bor(Bool L, Bool R);  

rule a1 band(btrue, Bool B)    =&gt; B;
rule a2 band(bfalse, Bool B)   =&gt; bfalse;

rule o1 bor(btrue, btrue)     =&gt; btrue;
rule o2 bor(btrue, bfalse)    =&gt; btrue;
rule o3 bor(bfalse, btrue)    =&gt; btrue;
rule o4 bor(bfalse, bfalse)   =&gt; bfalse;

boolean test()
{
  return bor(band(btrue,btrue),band(btrue, bfalse)) == btrue;
}</programlisting>These rules are applied on every Bool that is constructed.
        Like in ASF+SDF it is the responsibility of the programmer to make
        sure the rules are confluent and terminating. A rule definition has
        the same syntax and semantics as the switch construct, allowing
        backtracking, side-effects and checking of conditions.</para>

        <para>There are some issues here:</para>

        <itemizedlist>
          <listitem>
            <para>It should be dissallowed to have private rules on public
            constructors; normalization is a global effect on public
            data-structures. On the other hand, constructors that are local to
            a module may have some private rules applied to them; but public
            rules on private constructors are dissallowed too.</para>
          </listitem>
        </itemizedlist>
      </section>

      <section>
        <title>Concrete Booleans defined with rules</title>

        <para>In a similar fashion, the concrete syntax version of Booleans
        can be defined using rules:<programlisting>module Bool-conc-rules

import languages/Booleans/syntax;

rule a1 true &amp; &lt;Bool B2&gt;   =&gt; &lt;B2&gt;
rule a2 false &amp; &lt;Bool B2&gt;  =&gt; false

rule o1 true | true        =&gt; true
rule o2 true | false       =&gt; true
rule o3 false | true       =&gt; true
rule o4 false | false      =&gt; false</programlisting></para>
      </section>
    </section>

    <section>
      <title>Abstract Graph datatype</title>

      <para>In the Meta-Environment we use an abstract data type to exchange
      data representing graphs. It can be defined as follows.<programlisting>module GraphDataType

data Point point(int x, int y);

type list[Point]  Polygon;

type str File;

data Color rgb(int red, int green, int blue);

data Style bold | dashed | dotted | filled | invisible | solid;

data Shape box | circle | diamond | egg | elipse | hexagon | 
           house | octagon | parallelogram | plaintext | 
           trapezium | triangle;

data Direction forward | back | both | none;

data Attribute bounding-box(Point first, Point second);
data Attribute color(Color color);
data Attribute curve-points(Polygon points);
data Attribute direction(Direction direction);
data Attribute fill-color(Color color);
data Attribute info(str key, value val);
data Attribute label(str label);
data Attribute tooltip(str tooltip);
data Attribute location(int x, int y);
data Attribute shape(Shape shape);
data Attribute size(int width, int height);
data Attribute style(Style style);
data Attribute level(str level);
data Attribute \file(File \file);
data Attribute \file(value \file);

type list[Attribute] AttributeList;

data NodeId id(tree id);

data Edge edge(NodeId from, 
               NodeId to, 
               AttributeList attributes);
               
type list[Edge] EdgeList;

type list[Point] Polygon;

data Node node(NodeId id,  
               AttributeList attributes);
               
type list[Node] NodeList;

data Graph graph(NodeList nodes, 
                 EdgeList edges, 
                 AttributeList attributes);

data Node subgraph(NodeId id, 
                   NodeList nodes, 
                   EdgeList edges, 
                   AttributeList attributes);
                   on;

data Point point(int x, int y);</programlisting></para>
    </section>

    <section>
      <title>Tree traversal</title>

      <para>Here is the binary tree example that we use in explaining
      traversal functions in ASF+SDF.<programlisting>
module demo::TreeTraversals
import List;
import UnitTest;

data NODE = i(int N) | f(NODE I, NODE J) | g(NODE I, NODE J) |  
            h(NODE I, NODE J)  | h(NODE I, NODE J, NODE K);

// Example 1: Count the int nodes in a tree

// Ex1a: Collect all integers in the tree in 
// a list and return the size of the list

public int cnta(NODE T) {
    return size([N | int N &lt;- T]);
}

// Ex1b: alternative solution using a visit statement

public int cntb(NODE T) {
    int C = 0;
    visit(T) {
      case int N: C = C + 1;
    };
    return C;
}

// Ex2: Sum all leaves in a tree

// Ex2a: Collect all integers in the tree in 
// a list and use the library function sum on lists
// to add all list elements together.

public int sumtreea(NODE T) {
    return sum([N | int N &lt;- T], 0);
}

// Ex2b: using visit statement

public int sumtreeb(NODE T) {
    int C = 0;
    visit(T) {
      case int N : C = C + N;
    };
    return C;
}

// Ex3: Increment all leaves in a tree

public NODE inc(NODE T) {
    return visit(T) {
      case int N: insert N + 1;
    };
}

// Ex4: full replacement of g by h, i.e.
// replace all nodes g(_,_) by h(_,_)

// Ex4a Using insert

public NODE frepa(NODE T) {
    return visit (T) {
      case g(NODE T1, NODE T2):
           insert h(T1, T2);
    };
}

// Ex4a Using replacement rule

public NODE frepb(NODE T) {
    return visit (T) {
      case g(NODE T1, NODE T2) =&gt; h(T1, T2)
    };
}

// Ex5 Replace all nodes g(_,_) by h(_,_,_)

// Ex5a Using insert

public NODE frepG2H3a(NODE T) {
    return visit (T) {
      case g(NODE T1, NODE T2):
           insert h(T1, T2, i(0));
    };
}

// Ex5b Using replacement rule

public NODE frepG2H3b(NODE T) {
    return visit (T) {
      case g(NODE T1, NODE T2) =&gt; h(T1, T2, i(0))
    };
}

// Ex6: Deep replacement of g by h (i.e. only innermost 
// g's are replaced); 

public NODE drepl(NODE T) {
    return bottom-up-break visit (T) {
      case g(NODE T1, NODE T2) =&gt;  h(T1, T2)
    };
}

// Ex7: shallow replacement of g by h (i.e. only outermost 
// g's are replaced); 

public NODE srepl(NODE T) {
    return top-down-break visit (T) {
       case g(NODE T1, NODE T2) =&gt;  h(T1, T2)
    };
}

// Ex8: accumulating transformer that increments integer leaves with 
// amount D and counts them as well.

public tuple[int, NODE] count_and_inc(NODE T, int D) {
    int C = 0;
    
    T = visit (T) {
        case int N: { C = C + 1; 
                     insert N + D;
                    }
        };
    return &lt;C, T&gt;;
}

public bool test(){
   NODE N = f(g(i(1),g(i(2),i(3))),i(4));
   
   assertTrue(cnta(N) == 4);
   assertTrue(cntb(N) == 4);
   assertTrue(sumtreea(N) == 10);
   assertTrue(sumtreeb(N) == 10);
   
   assertTrue(inc(N) ==  f(g(i(2),g(i(3),i(4))),i(5)));
   
   assertTrue(frepa(N) ==   f(h(i(1),h(i(2),i(3))),i(4)));
   assertTrue(frepb(N) ==   f(h(i(1),h(i(2),i(3))),i(4)));
   
   assertTrue(frepG2H3a(N) ==   f(h(i(1),h(i(2),i(3),i(0)), i(0)),i(4)));
   assertTrue(frepG2H3b(N) ==   f(h(i(1),h(i(2),i(3),i(0)), i(0)),i(4)));
   
   assertTrue(drepl(N) ==  f(g(i(1),h(i(2),i(3))),i(4)));
   assertTrue(srepl(N) ==  f(h(i(1),g(i(2),i(3))),i(4)));
   
   assertTrue(count_and_inc(N,3) == &lt;4, f(g(i(4),g(i(5),i(6))),i(7))&gt;);
   
   return report();
}</programlisting></para>
    </section>

    <section>
      <title>Substitution in Lambda</title>

      <para>Below a definition of substitution in lambda expressions. It would
      be nice to get this as simple as possible since it is a model for many
      binding mechanisms. It is also a challenge to write a generic
      substitution function that only depends on the syntax of variables and
      argument binding.</para>

      <programlisting>module examples/Lambda/Lambda-syntax

exports
sorts Var %% variables
      Exp %% expressions
lexical syntax
     [a-z]+               -&gt; Var
context-free syntax
     "prime" "(" Var ")"  -&gt; Var  %% generate unique name
     Var                  -&gt; Exp  %% single variable
     "fn" Var "=&gt;" Exp    -&gt; Exp  %% function abstraction
     Exp Exp              -&gt; Exp  %% function application
</programlisting>

      <para>Examples:</para>

      <para><programlisting>module Lambda-Examples

import Lambda-syntax;

set[Var] allVars(Exp E) {
    return {V | Var V : E};
}

set[Var] boundVars(Exp E) {
    return {V | fn &lt;Var V&gt; =&gt; &lt;Exp E1&gt; : E};
} 

set[Var] freeVars(Exp E) {
    return allVars(E) - boundVars(E);
}

%% Generate a fresh variable if V does not occur in 
%% given set of variables.

Var fresh(Var V, set[Var] S) {
    if (V in S){ return prime(V); } else {return V;}
}

%% Substitution: replace all occurrences of V in E2 by E1

Exp subst(Var V1, Exp E1, Exp E2) {

    return visit (E2) { 
      case &lt;Var V2&gt;: insert (V1==V2) ? E1 : V2;

      case &lt;Exp Ea&gt; &lt;Exp Eb&gt;:
        insert [| &lt;subst(V, E, Ea)&gt; &lt;subst(V, E, Eb)&gt; |];

      case fn &lt;Var V2&gt; =&gt; &lt;Var Ea&gt;:
        if (V1 == V2) { insert [| fn &lt;V2&gt; =\&gt; &lt;Ea&gt; |]; }

      case fn &lt;Var V2&gt; =&gt; &lt;Exp Ea&gt;:
        if(V1 != V2 &amp;&amp; !(V1 in freeVars(E2) &amp;&amp; 
           V2 in freeVars(E1))){
           insert [| fn &lt;V2&gt; =\&gt; &lt;subst(V1, E1, Ea)&gt; |];
        }              
 
      case fn &lt;Var V2&gt; =&gt; &lt;Exp Ea&gt;: 
        if(V1 != V2 &amp;&amp; V1 in freeVars(Ea) &amp;&amp;
           V2 in freeVars(E1)){
           Var V3 = fresh(V2, freeVars(Ea) + freeVars(E1));
           Exp EaS = subst(V1, E1, subst(V2, V3, E2));
           insert [| fn &lt;V3&gt; =\&gt; &lt;EaS&gt; |];
        }
    };
}</programlisting></para>
    </section>

    <section>
      <title>Renaming in Let</title>

      <para><programlisting>module Let-syntax
exports
sorts Var %% variables
      Exp %% expressions
lexical syntax
     [a-z]+                           -&gt; Var
context-free syntax
     Var                              -&gt; Exp
     "let" Var "=" Exp "in" Exp "end" -&gt; Exp </programlisting>Examples:<programlisting>module Let-Example

import Let;

%% Rename all bound variables in an Exp
%% Version 1: purely functional
%% Exp: given expression to be renamed
%% rel[Var,Var]: renaming table
%% Int: counter to generate unique variables

Exp rename(Exp E, rel[Var,Var] Rn, Int Cnt) {
    switch (E) {
    case let &lt;Var V&gt; = &lt;Exp E1&gt; in &lt;Exp E2&gt; end:
         return [| let &lt;parseString("x" + toString(Cnt))&gt; = 
                       &lt;rename(E1, Rn, Cnt)&gt;
                   in 
                       &lt;rename(E2, {&lt;V, Y&gt;} + Rn, Cnt+1)&gt;
                   end
                |];
          
    case &lt;Var V&gt;: return Rn[V];

    default: return E;
    }
}</programlisting></para>
    </section>

    <section>
      <title>Renaming in Let using globals</title>

      <para>Here is the same renaming function now using two global
      variables.<programlisting>module Let-Example

import Let;

%% Rename all bound variables in an Exp
%% Version 2: using global variables
%% Cnt: global counter to generate fresh variables
%% rel[Var,Var]: global renaming table

global int Cnt = 0;
global rel[Var,Var] Rn = {};

Var newVar() {
    global int Cnt;  
    Cnt = Cnt + 1;
    return parseString("x" + toString(Cnt));
}

Exp rename(Exp E) {
    global int Cnt;
    global rel[Var,Var] Rn;
    switch (E) {
    case let &lt;Var V&gt; = &lt;Exp E1&gt; in &lt;Exp E2&gt; end: {
         Var Y = newVar();
         Rn = {&lt;V, Y&gt;} + Rn;
         return [| let &lt;Y&gt;= &lt;rename(E1)&gt;
                   in 
                      &lt;rename(E2)&gt;
                   end 
                |];
          }

    case &lt;Var V&gt;: return Rn[V];

    default: return E;
    }
}</programlisting></para>
    </section>

    <section>
      <title>Pico Typechecker</title>

      <para>The following example shows a typechecker for Pico that generates
      a list of error messages.<programlisting>module Typecheck

import Pico-syntax;
import Errors;

type map[PICO-ID,TYPE] Env;

list[Error] tcp(PROGRAM P) {
    switch (P) {
      case begin &lt;DECLS Decls&gt; &lt;{STATEMENT ";"}* Series&gt; end: {
           Env Env = {&lt;Id, Type&gt; | 
                      [| &lt;PICO-ID Id&gt; : &lt;TYPE Type&gt; |] : Decls};
           return [ tcst(S, Env) | Stat S : Series ];
      }
    }
    return [];
}

list[Error] tcst(Stat Stat, Env Env) {
    switch (Stat) {
      case [| &lt;PICO-ID Id&gt; = &lt;EXP Exp&gt;|]: {
        TYPE Type = Env[Id];
        return type_of(Exp, Type, Env);
      }

      case if &lt;EXP Exp&gt; then &lt;{STATEMENT ";"}* Stats1&gt; 
                   else &lt;{STATEMENT ";"}* Stats1&gt; fi:
        return type_of(Exp, natural, Env) + 
               tcs(Stats1, Env) + tcs(Stats2, Env);

      case while &lt;EXP Exp&gt; do &lt;{STATEMENT ";"}* Stats1&gt; od: 
        return type_of(Exp, natural, Env) + tcs(Stats, Env);
    }
    return [];
}
 
list[Error] type_of(Exp E, TYPE Type, Env Env) {
    switch (E) {
      case &lt;NatCon N&gt;: if(Type == natural){ return []; }

      case &lt;StrCon S&gt;: if(Type == string) { return []; }

      case &lt;PICO-ID Id&gt;: {
         TYPE Type2 = Env(Id);
         if(Type2 == Type) { return []; }
      }

      case &lt;EXP E1&gt; + &lt;EXP E2&gt;:
        if(Type == natural){
           return type_of(E1, natural, Env) + 
                  type_of(E1, natural, Env);
        }

      case &lt;EXP E1&gt; - &lt;EXP E2&gt;:
        if(Type == natural){
           return type_of(E1, natural, Env) + 
                  type_of(E1, natural, Env);
        }

      case &lt;EXP E1&gt; || &lt;EXP E2&gt;: 
        if(Type == string){
          return type_of(E1, string, Env) + 
                 type_of(E1, string, Env);
        }
    
      default: return [error("Incorrect type")];
    }
}</programlisting></para>
    </section>

    <section>
      <title>Pico evaluator</title>

      <para><programlisting>module Pico-eval
import pico/syntax/Pico;
 
data PICO_VALUE intval(int) | strval(str);

type map[PICO-ID, PICO_VALUE] VEnv;

VEnv evalProgram(PROGRAM P){
    switch (P) {
      case begin &lt;DECLS Decls&gt; &lt;{STATEMENT ";"}* Series&gt; end: {
          VEnv Env = evalDecls(Decls);
          return evalStatements(Series, Env);
      }
   }
}

VEnv evalDecls(DECLS Decls){
    VEnv Env = {};
    visit (Decls) {
      case &lt;PICO-ID Id&gt; : string: { 
           Env[Id] = strval(""); 
           return Env;
      }
      case &lt;PICO-ID Id&gt; : natural: { 
           Env[Id] = intval(0);  
           return Env;
      }
    };
    return Env;
}

VEnv evalStatements({STATEMENT ";"}* Series, VEnv Env){
    switch (Series) {
      case &lt;STATEMENT Stat&gt;; &lt;{STATEMENT ";"}* Series2&gt;: {
        Env Env2 = evalStatement(Stat, Env);
        return evalStatements(Series2, Env2);
      }
      default: return Env;
    }
}

VEnv evalStatement(STATEMENT Stat, VEnv Env){
    switch (Stat) {
      case [| &lt;PICO-ID Id&gt; = &lt;EXP Exp&gt; |]: {
        Env[Id] = evalExp(Exp, Env);
        return Env;
      }

      case if &lt;EXP Exp&gt; then &lt;{STATEMENT ";"}* Stats1&gt; 
                       else &lt;{STATEMENT ";"}* Stats1&gt; fi:{
        if(evalExp(Exp, Env) != intval(0)){
          return evalStatments(Stats1, Env);
        } else {
          return evalStatements(Stats2, Env);
        }
      }

      case while &lt;EXP Exp&gt; do &lt;{STATEMENT ";"}* Stats1&gt; od: {
        if(evalExp(Exp, Env) != intval(0)){
          return Env;
        } else {
          VEnv Env2 = evalStatements(Stats1, Env);
          return evalStatement(Stat, Env2);
        }
      }
      default: return Env;
    }
}

PICO_VALUE evalExp(Exp exp, VEnv Env) {
    switch (exp) {
      case NatCon[| &lt;NatCon N&gt; |]: 
           return intval(toInt(unparseToString(N)));

      case StrCon[| &lt;StrCon S&gt; |]: 
           return strval(unparseToString(S));

      case PICO-ID[| &lt;PICO-ID Id&gt; |]: 
           return Env[Id];

      case &lt;EXP exp1&gt; + &lt;EXP exp2&gt;:
           if(intval(int n1) ~~ evalExp(exp1, Env) &amp;&amp;
              intval(int n2) ~~ evalExp(exp2, Env)){
              return intval(n1 + n2);
           }
      
      case &lt;EXP exp1&gt; - &lt;EXP exp2&gt;:
            if(intval(int n1) ~~ evalExp(exp1, Env) &amp;&amp;
               intval(int n2) ~~ evalExp(exp2, Env)){
               return intval(n1 - n2);
           }
 
      case &lt;EXP exp1&gt; || &lt;EXP exp2&gt;:
           if(strval(str s1) ~~ evalExp(exp1, Env) &amp;&amp;
              strval(str s2) ~~ evalExp(exp2, Env)){
              return strval(s1 + s2);
           }
   } 
}
</programlisting></para>
    </section>

    <section>
      <title>Pico evaluator with globals</title>

      <para>Here is the same evaluator but now using a global variable to
      represent the value environment.<programlisting>module Pico-eval

import pico/syntax/Pico;

data PICO_VALUE intval(int) | strval(str);

type map[PICO-ID, PICO_VALUE] VEnv;

VEnv Env = {};

void evalProgram(PROGRAM P){
    switch(P) {
      case begin &lt;DECLS Decls&gt; &lt;{STATEMENT ";"}* Series&gt; end: {
          evalDecls(Decls);
          evalStatements(Series);
      }
   }
}

VEnv evalDecls(DECLS Decls){
    global Venv Env;
    visit (Decls) {
      case &lt;PICO-ID Id&gt; : string:  Env[Id] = strval("");
      case &lt;PICO-ID Id&gt; : natural: Env[Id] = intval(0);
    };
    return Env;
}

void evalStatements({STATEMENT ";"}* Series){
    switch (Series) {
      case &lt;STATEMENT Stat&gt;; &lt;{STATEMENT ";"}* Series2&gt;: {
        evalStatement(Stat);
        evalStatements(Series2);
        return;
      }
      default: return;
    }
}

void evalStatement(STATEMENT Stat){
    global Venv Env;
    switch (Stat) {
      case [| &lt;PICO-ID Id&gt; = &lt;EXP Exp&gt; |]: {
        Env[Id] = evalExp(Exp);
        return;
      }

      case if &lt;EXP Exp&gt; then &lt;{STATEMENT ";"}* Stats1&gt; 
                   else &lt;{STATEMENT ";"}* Stats1&gt; fi:{
        if(evalExp(Exp) != intval(0)) {
          evalStatements(Stats1);
          return;
        } else {
          evalStatements(Stats2);
          return;
        }
      }

      case while &lt;EXP Exp&gt; do &lt;{STATEMENT ";"}* Stats1&gt; od:{
        if(evalExp(Exp) != intval(0)){
          return;
        } else {
          evalStatements(Stats1);
          evalStatement(Stat);
          return;
        }
      }
    }
};

PICO_VALUE evalExp(Exp exp) {
    global Venv Env;
    switch (exp) {
      case &lt;NatCon N&gt;: intval(toInt(unparseToString(N)));

      case &lt;StrCon S&gt;: return strval(unparseToString(S));

      case &lt;PICO-ID Id&gt;: return Env[Id];

      case &lt;EXP exp1&gt; + &lt;EXP exp2&gt;:
           if(intval(int n1) ~~ evalExp(exp1) &amp;&amp;
              intval(int n2) ~~ evalExp(exp2)){
              return intval(n1 + n2);
           }

      case &lt;EXP exp1&gt; - &lt;EXP exp2&gt;:
           if(intval(int n1) ~~ evalExp(exp1) &amp;&amp;
              intval(int n2) ~~ evalExp(exp2)){
              return intval(n1 - n2);
           }
   
      case &lt;EXP exp1&gt; || &lt;EXP exp2&gt;:
           if(strval(str s1) ~~ evalExp(exp1) &amp;&amp;
              strval(str s2) ~~ evalExp(exp2)){
              return strval(s1 + s2);
           }
   } 
}
</programlisting></para>
    </section>

    <section>
      <title>Pico control flow extraction</title>

      <programlisting>module Pico-controlflow
 
import pico/syntax/Pico;

data CP exp(EXP) | stat(STATEMENT);

type tuple[set[CP] entry, 
           rel[CP,CP] graph, 
           set[CP] exit] CFSEGMENT;

CFSEGMENT cflow({STATEMENT ";"}* Stats){ 
    switch (Stats) {
      case &lt;STATEMENT Stat&gt; ; &lt;{STATEMENT ";"}* Stats2&gt;: { 
           CFSEGMENT CF1 = cflow(Stat);
           CFSEGMENT CF2 = cflow(Stats2);
           return &lt;CF1.entry, 
                   CF1.graph | CF2.graph | (CF1.exit * CF2.entry), 
                   CF2.exit&gt;;
      }

      case [| |]: return &lt;{}, {}, {}&gt;;
    }
}

CFSEGMENT cflow(STATEMENT Stat){
    switch (Stat) {
      case while &lt;EXP Exp&gt; do &lt;{STATEMENT ";"}* Stats&gt; od : {
           CFSEGMENT CF = cflow(Stats);
           set[CP] E = {exp(Exp)};
           return &lt; E, 
                    (E * CF.entry) | CF.graph | (CF.exit * E),
                    E
                  &gt;;
      }
                
      case if &lt;EXP Exp&gt; then &lt;{STATEMENT ";"}* Stats1&gt; 
                   else &lt;{STATEMENT ";"}* Stats2&gt; fi: {
           CFSEGMENT CF1 = cflow(Stats1);
           CFSEGMENT CF2 = cflow(Stats2);
           set[CP] E = {exp(Exp)};
           return &lt; E, 
                    (E * CF1.entry) | (E * CF2.entry) | 
                                      CF1.graph | CF2.graph,
                    CF1.exit | CF2.exit
                  &gt;;
      }
         
      case &lt;STATEMENT Stat&gt;: return &lt;{Stat}, {}, {Stat}&gt;;
    }
}
</programlisting>

      <para></para>
    </section>

    <section>
      <title>Pico use def extraction</title>

      <programlisting>module Pico-use-def

import pico/syntax/Pico;

rel[PICO-ID, EXP] uses(PROGRAM P) {
  return {&lt;Id, E&gt; | EXP E : P, [| &lt;PICO-ID Id&gt; |] ~~ E};
}

rel[PICO-ID, STATEMENT] defs(PROGRAM P) { 
  return {&lt;Id, S&gt; | STATEMENT S : P, 
                    [| &lt;PICO-ID Id&gt; := &lt;EXP Exp&gt; |] ~~ S};
}</programlisting>

      <para>The above uses a "matching condition" to decompose
      <literal>S</literal>. The problem solved is that we want to have a name
      for the whole assignment <emphasis>and</emphasis> for the lhs
      identifier. Also note that, compared to older definitions of these
      functions, the iudentifier is placed as first element in each
      tuple.</para>
    </section>

    <section>
      <title>Pico uninitialized variables</title>

      <para><programlisting>module Pico-uninit

import pico/syntax/Pico;

import Pico-controlflow;
import Pico-use-def;

set[PICO-ID] uninit(PROGRAM P) {
    rel[EXP,PICO-ID] Uses = uses(P);
    rel[PICO-ID, STATEMENT] Defs = defs(P);
    CFSEGMENT CFLOW = cflow(P);
    set[CP] Root = CFLOW.entry;
    rel[CP,CP] Pred = CFLOW.graph; 

    return {Id | &lt;EXP E, PICO-ID Id&gt; : Uses,
                 E in reachX(Root, Defs[Id], Pred)
    };
}
</programlisting></para>
    </section>

    <section>
      <title>Pico common subsexpression elimination</title>

      <para><programlisting>module Pico-common-subexpression

import pico/syntax/Pico;
import Pico-controlflow;
import Pico-use-def;

PROGRAM cse(PROGRAM P) {
    rel[PICO-ID, STATEMENT] Defs = defs(P);
    rel[CP,CP] Pred = cflow(P).graph;
    map[EXP, PICO-ID] replacements = 
       {&lt;E2 -&gt; Id&gt; | STATEMENT S : P,
                   [| &lt;PICO-ID Id&gt; := &lt;EXP E&gt; |] ~~ S,
                   Id notin E,
                   EXP E2 : reachX({S}, Defs[Id], Pred)
       };
  
    return visit (P) {
      case &lt;EXP E&gt;: if([| &lt;PICO-ID Id&gt; |] ~~ replacements(E)){
                       replace-by Id;
                    }
    };
}</programlisting></para>

      <para>Paraphrased: Replace in P all expressions E2 by Id, such
      that</para>

      <itemizedlist>
        <listitem>
          <para>P contains a statement S of the form Id := E,</para>
        </listitem>

        <listitem>
          <para>Id does not occur in E,</para>
        </listitem>

        <listitem>
          <para>E2 can be reached from S,</para>
        </listitem>

        <listitem>
          <para>There is no redefinition of Id between S and E2.</para>
        </listitem>
      </itemizedlist>
    </section>

    <section>
      <title>Pico constant propagation</title>

      <para><programlisting>module Pico-constant-propagation

import  pico/syntax/Pico;
import  Pico-controlflow;
import  Pico-use-def;

Boolean is_constant(EXP E) {
   switch (E) {
     case &lt;NatCon N&gt;: return true;

     case &lt;StrCon S&gt;: return true;

     case &lt;EXP E&gt;: return false;
   }
}

PROGRAM cp(PROGRAM P) {
    rel[PICO-ID, STATEMENT] Defs = defs(P);
    rel[CP,CP] Pred = cflow(P).graph;

    map[PICO-ID, EXP] replacements = 
      {&lt;Id2 -&gt; E&gt; | STATEMENT S : P,
                  [| &lt;PICO-ID Id&gt; := &lt;EXP E&gt; |] ~~ S,
                  is_constant(E),
                  PICO-ID Id2 : reachX({S},Defs[Id],Pred),
                  Id2 == Id 
      };  
 
    return visit (P) {
     case &lt;PICO-ID Id&gt;: if(&lt;EXP E&gt; ~~ replacements[Id]){
                           insert E;
                        }
    };
}</programlisting></para>

      <para>Paraphrased: Replace in P all expressions Id2 by the constant E,
      such that</para>

      <itemizedlist>
        <listitem>
          <para>P contains a statement S of the form Id ~~ E,</para>
        </listitem>

        <listitem>
          <para>E is constant,</para>
        </listitem>

        <listitem>
          <para>Id2 can be reached from S,</para>
        </listitem>

        <listitem>
          <para>Id2 is equal to Id,</para>
        </listitem>

        <listitem>
          <para>There is no redefinition of Id between S and Id2.</para>
        </listitem>
      </itemizedlist>
    </section>

    <section>
      <title>Pico Reaching definitions</title>

      <para>Recall the equations construct as used, for example, in the
      reaching definitions example in the Rscript guide. It computes the
      values of a set of variables until none of them changes any longer. The
      "solve" statement achives the same effect.<programlisting>module Pico-reaching-defs

type tuple[Stat theStat, Var theVar] Def;
type tuple[Stat theStat, Var theVar] Use;

set[Stat] predecessor(rel[Stat,Stat] P, Stat S) { 
    return invert(P)[S];
}

set[Stat] successor(rel[Stat,Stat] P, Stat S) { 
    return P(S);
}

rel[Stat, Def] reaching_definitions(rel[Stat,Var] DEFS, 
                                        rel[Stat,Stat] PRED) {

    set[Stat] STATEMENT = carrier(PRED);

    rel[Stat,Def] DEF  = {&lt;S,&lt;S,V&gt;&gt; | tuple[Stat S, Var V]: DEFS};

    rel[Stat,Def] KILL = 
        {&lt;S1, &lt;S2, V&gt;&gt; | tuple[Stat S1, Var V] : DEFS, 
                         tuple[Stat S2, V] : DEFS, 
                         S1 != S2
        };

     rel[Stat,Def] IN = {};
     rel[Stat,Def] OUT = DEF;

     solve {
           IN  =  {&lt;S, D&gt; | int S : STATEMENT, 
                            Stat P : predecessor(PRED,S), 
                            Def D : OUT[P]};
           OUT =  {&lt;S, D&gt; | int S : STATEMENT, 
                            Def D : DEF[S] + (IN[S] - KILL[S])}
    }
    return IN;
}</programlisting></para>
    </section>

    <section>
      <title>Structured lexicals: numbers</title>

      <para>Given the SDF definition:<programlisting>sorts Digit Number Real  
lexical syntax
   [0-9]             -&gt; Digit
   Digit+            -&gt; Number
   Number "." Number -&gt; Real</programlisting>we can write a normalization
      rule for <literal>Number</literal> that removes leading
      zeros:<programlisting>rule n1 number("0" &lt;Digit+ Ds&gt;) =&gt; number(&lt;Ds&gt;)</programlisting></para>

      <para>Note that a character class can be used instead of the sort
      <literal>Digit</literal>:<programlisting>rule n2 number("0" &lt;[0-9]+ Ds&gt;) =&gt; number(&lt;Ds&gt;)</programlisting></para>

      <para>A truncation function on <literal>Real</literal> can replace the
      mantissa by 0:</para>

      <para><programlisting>Real truncate(Real R){
    switch (R) {
       case real(&lt;Number Num&gt; "." &lt;Digit+ Ds&gt;) =&gt; real(&lt;Num&gt; "." "0")
    }
}</programlisting></para>
    </section>

    <section>
      <title>Structured Lexicals: strings</title>

      <para>Given the SDF definition:<programlisting>sorts String NQChar
lexical syntax
   ~[\"]             -&gt; NQChar
   [\"] NQChar* [\"] -&gt; String</programlisting>A function that removes the
      <emphasis>first</emphasis> newline from a string can be written
      as:<programlisting>String removeFirstNL(String S){
    switch (S) {
      case string("\"" &lt;NQChar* Chars1&gt; "\n" &lt;NQChar* Chars2&gt; "\"") =&gt;
           string("\"" &lt;Chars1&gt; &lt;Chars2&gt; "\"")
    }
}</programlisting></para>

      <para>A function that removes all newline from a string:<programlisting>String removeAllNL(String S){
    return innermost visit (S) {
      case string("\"" &lt;NQChar* Chars1&gt; "\n" &lt;NQChar* Chars2&gt; "\"") =&gt;
           string("\"" &lt;Chars1&gt; &lt;Chars2&gt; "\"")
    };
}</programlisting></para>
    </section>

    <section>
      <title>Innerproduct</title>

      <para>[Example inspired by TXL documentation]</para>

      <para>Define nnerproduct on lists of integers, e.g. innerProduct([1, 2,
      3] .[3, 2, 1]) =&gt; 10.</para>

      <programlisting>module Innerproduct

import List;

public int inner1(list[int] V1, list[int] V2){
    if ((size(V1) == 0) || (size(V2) == 0)){
       return 0;
    } else {
       return (V1[0] * V2[0]) + inner1(tail(V1), tail(V2));
    }
 }
 
 public int inner2(list[int] V1, list[int] V2){
    if(([N1, list[int] R1] ~= V1) &amp;&amp; ([N2, list[int] R2] ~= V2)){
    	return N1 * N2 + inner2(R1, R2);
    } else {
       return 0;
    }
 }
</programlisting>
    </section>

    <section>
      <title>Bubble sort</title>

      <para>[Example inspired by TXL documentation]</para>

      <programlisting>module Bubble

import List;

// sort1: uses list indexing and for-loop

public list[int] sort1(list[int] Numbers){
  for(int I : [0 .. size(Numbers) - 2 ]){
     if(Numbers[I] &gt; Numbers[I+1]){
       &lt;Numbers[I], Numbers[I+1]&gt; = &lt;Numbers[I+1], Numbers[I]&gt;;
       return sort1(Numbers);
     }
  }
  return Numbers;
}

// sort2: uses list matching and switch

public list[int] sort2(list[int] Numbers){
  
  switch(Numbers){
    case [list[int] Nums1, int P, int Q, list[int] Nums2]:
       if(P &gt; Q){
          return sort2(Nums1 + [Q, P] + Nums2);
       } else {
       	  fail;
       }
     default: return Numbers;
   }
  
}

// sort3: uses list matching and visit

public list[int] sort3(list[int] Numbers){

  return innermost visit(Numbers){
    case [list[int] Nums1, int P, int Q, list[int] Nums2]:
       if(P &gt; Q){
          insert Nums1 + [Q, P] + Nums2;
       } else {
          fail;
       }
    };
}
</programlisting>
    </section>
  </section>

  <section>
    <title>The Rascal standard library</title>

    <para>In this section we summarize the functions in the Rascal Standard
    Library.</para>

    <section>
      <title>Benchmark</title>

      <para>A starting point for a full suite of benchmarking
      functions:</para>

      <itemizedlist>
        <listitem>
          <para>currentTimeMillis -- current time in milliseconds since
          January 1, 1970 GMT.</para>
        </listitem>

        <listitem>
          <para>benchmark -- measure and report the execution time of
          name:void-closure pairs.</para>
        </listitem>
      </itemizedlist>
    </section>

    <section>
      <title>Boolean</title>

      <itemizedlist>
        <listitem>
          <para>arbBool -- get an arbitrary boolean value.</para>
        </listitem>

        <listitem>
          <para>fromInt -- convert an integer to a bool</para>
        </listitem>

        <listitem>
          <para>fromString -- convert the strings "true" or "false" to a
          bool</para>
        </listitem>

        <listitem>
          <para>toInt -- convert a boolean value to integer.</para>
        </listitem>

        <listitem>
          <para>toReal -- convert a boolean value to a real value.</para>
        </listitem>

        <listitem>
          <para>toString -- convert a boolean value to a string.</para>
        </listitem>
      </itemizedlist>
    </section>

    <section>
      <title>Exception</title>

      <para>The following "soft" exceptions are defined:<programlisting>data RuntimeException = 
      EmptyList
    | EmptyMap 
    | EmptySet
    | IndexOutOfBounds(int index)
    | AssertionFailed 
    | AssertionFailed(str label)
    | NoSuchElement(value v)
    | IllegalArgument(value v)
    | IllegalArgument
    | IO(str message)
    | FileNotFound(str filename)
    | LocationNotFound(loc location)
    | PermissionDenied
    | PermissionDenied(str message)
    | ModuleNotFound(str name)
    | NoSuchKey(value key)
    | NoSuchAnnotation(str label)
    | Java(str message)
    ;</programlisting></para>
    </section>

    <section>
      <title>Graph</title>

      <para><programlisting>alias graph[&amp;T] = rel[&amp;T from, &amp;T to];</programlisting></para>

      <itemizedlist>
        <listitem>
          <para>bottom -- return the bottom nodes of a graph.</para>
        </listitem>

        <listitem>
          <para>top -- return the top nodes of a graph.</para>
        </listitem>

        <listitem>
          <para>reach -- Reachability from set of start nodes.</para>
        </listitem>

        <listitem>
          <para>reachR -- Reachability from set of start nodes with
          restriction to certain nodes.</para>
        </listitem>

        <listitem>
          <para>reachX -- Reachability from set of start nodes with exclusion
          of certain nodes.</para>
        </listitem>

        <listitem>
          <para>shortestPathPair -- Shortest path between pair of
          nodes.</para>
        </listitem>
      </itemizedlist>
    </section>

    <section>
      <title>Integer</title>

      <itemizedlist>
        <listitem>
          <para>abs -- absolute value of integer.</para>
        </listitem>

        <listitem>
          <para>arbInt -- return an arbitrary integer value.</para>
        </listitem>

        <listitem>
          <para>arbInt -- return an arbitrary integer value in the interval
          [0, limit).</para>
        </listitem>

        <listitem>
          <para>max -- largest of two integers.</para>
        </listitem>

        <listitem>
          <para>min -- smallest of two integers.</para>
        </listitem>

        <listitem>
          <para>toReal -- convert an integer value to a real value.</para>
        </listitem>

        <listitem>
          <para>toString -- convert an integer value to a string.</para>
        </listitem>
      </itemizedlist>
    </section>

    <section>
      <title>IO</title>

      <itemizedlist>
        <listitem>
          <para>println -- print a list of values on the output stream.</para>
        </listitem>

        <listitem>
          <para>readFile -- read a named file as list of strings.</para>
        </listitem>
      </itemizedlist>
    </section>

    <section>
      <title>LabelledGraph</title>

      <para><programlisting>alias lgraph[&amp;T,&amp;L] = rel[&amp;T from, &amp;L label, &amp;T to];</programlisting><itemizedlist>
          <listitem>
            <para>bottom -- return the bottom nodes of a graph.</para>
          </listitem>

          <listitem>
            <para>top -- return the top nodes of a graph.</para>
          </listitem>

          <listitem>
            <para>reach -- Reachability from set of start nodes.</para>
          </listitem>

          <listitem>
            <para>reachR -- Reachability from set of start nodes with
            restriction to certain nodes.</para>
          </listitem>

          <listitem>
            <para>reachX -- Reachability from set of start nodes with
            exclusion of certain nodes.</para>
          </listitem>

          <listitem>
            <para>shortestPathPair -- Shortest path between pair of
            nodes.</para>
          </listitem>
        </itemizedlist></para>
    </section>

    <section>
      <title>List</title>

      <itemizedlist>
        <listitem>
          <para>average -- average of elements of a list</para>
        </listitem>

        <listitem>
          <para>delete -- delete nth element from list</para>
        </listitem>

        <listitem>
          <para>domain -- a list of all legal index values for a list</para>
        </listitem>

        <listitem>
          <para>head -- get the first element of a list</para>
        </listitem>

        <listitem>
          <para>head -- get the first n elements of a list</para>
        </listitem>

        <listitem>
          <para>getOneFrom -- get an arbitrary element from a list</para>
        </listitem>

        <listitem>
          <para>insertAt -- add an element at a specific position in a
          list</para>
        </listitem>

        <listitem>
          <para>isEmpty -- is list empty?</para>
        </listitem>

        <listitem>
          <para>mapper -- apply a function to each element of a list</para>
        </listitem>

        <listitem>
          <para>max -- largest element of a list</para>
        </listitem>

        <listitem>
          <para>min -- smallest element of a list</para>
        </listitem>

        <listitem>
          <para>multiply -- multiply the elements of a list</para>
        </listitem>

        <listitem>
          <para>permutations -- return all permutations of a list</para>
        </listitem>

        <listitem>
          <para>reducer -- apply function F to successive elements of a
          list</para>
        </listitem>

        <listitem>
          <para>reverse -- elements of a list in reverse order</para>
        </listitem>

        <listitem>
          <para>size -- number of elements in a list</para>
        </listitem>

        <listitem>
          <para>slice -- sublist from start of length len</para>
        </listitem>

        <listitem>
          <para>sort -- sort the elements of a list</para>
        </listitem>

        <listitem>
          <para>sum -- add elements of a List</para>
        </listitem>

        <listitem>
          <para>tail -- all but the first element of a list</para>
        </listitem>

        <listitem>
          <para>tail -- last n elements of a list</para>
        </listitem>

        <listitem>
          <para>takeOneFrom -- remove an arbitrary element from a list,
          returns the element and the modified list</para>
        </listitem>

        <listitem>
          <para>toMap -- convert a list of tuples to a map</para>
        </listitem>

        <listitem>
          <para>toSet -- convert a list to a set</para>
        </listitem>

        <listitem>
          <para>toString -- convert a list to a string</para>
        </listitem>
      </itemizedlist>
    </section>

    <section>
      <title>Map</title>

      <itemizedlist>
        <listitem>
          <para>domain -- return the domain (keys) of a map</para>
        </listitem>

        <listitem>
          <para>getOneFrom -- return arbitrary key of a map</para>
        </listitem>

        <listitem>
          <para>invert -- return map with key and value inverted</para>
        </listitem>

        <listitem>
          <para>isEmpty -- is map empty?</para>
        </listitem>

        <listitem>
          <para>mapper -- apply two functions to each key/value pair in a
          map.</para>
        </listitem>

        <listitem>
          <para>range -- return the range (values) of a map</para>
        </listitem>

        <listitem>
          <para>size -- number of elements in a map.</para>
        </listitem>

        <listitem>
          <para>toList -- convert a map to a list</para>
        </listitem>

        <listitem>
          <para>toRel -- convert a map to a relation</para>
        </listitem>

        <listitem>
          <para>toString -- convert a list to a string.</para>
        </listitem>
      </itemizedlist>
    </section>

    <section>
      <title>Node</title>

      <itemizedlist>
        <listitem>
          <para>arity -- number of children of a node</para>
        </listitem>

        <listitem>
          <para>getChildren -- get the children of a node</para>
        </listitem>

        <listitem>
          <para>getName -- get the function name of a node</para>
        </listitem>

        <listitem>
          <para>makeNode -- create a node given its function name and
          arguments</para>
        </listitem>
      </itemizedlist>
    </section>

    <section>
      <title>Real</title>

      <itemizedlist>
        <listitem>
          <para>arbReal -- returns an arbitrary real value in the interval
          [0.0,1.0).</para>
        </listitem>

        <listitem>
          <para>max -- largest of two reals</para>
        </listitem>

        <listitem>
          <para>min -- smallest of two reals</para>
        </listitem>

        <listitem>
          <para>toInteger -- convert a real to integer.</para>
        </listitem>

        <listitem>
          <para>toString -- convert a real to a string.</para>
        </listitem>
      </itemizedlist>
    </section>

    <section>
      <title>Relation</title>

      <itemizedlist>
        <listitem>
          <para>carrier -- all elements in any tuple in a relation</para>
        </listitem>

        <listitem>
          <para>carrierR -- relation restricted to tuples with elements in a
          set S</para>
        </listitem>

        <listitem>
          <para>carrierX -- relation excluded tuples with some element in
          S</para>
        </listitem>

        <listitem>
          <para>complement -- complement of relation</para>
        </listitem>

        <listitem>
          <para>domain -- first element of each tuple in binary
          relation</para>
        </listitem>

        <listitem>
          <para>domainR -- restriction of a relation to tuples with first
          element in S}</para>
        </listitem>

        <listitem>
          <para>domainX -- relation excluded tuples with first element in
          S</para>
        </listitem>

        <listitem>
          <para>invert -- inverse the tuples in a relation</para>
        </listitem>

        <listitem>
          <para>range -- all but the first element of each tuples in binary
          relation</para>
        </listitem>

        <listitem>
          <para>rangeR -- restriction of a binary relation to tuples with
          second element in set S</para>
        </listitem>
      </itemizedlist>

      <note>
        <para>We have not yet decided which of these functions we will
        generalize for the n-ary case.</para>
      </note>
    </section>

    <section>
      <title>RSF</title>

      <itemizedlist>
        <listitem>
          <para>readRSF -- read a file in Rigi Standard Format (RSF).</para>
        </listitem>
      </itemizedlist>
    </section>

    <section>
      <title>Set</title>

      <itemizedlist>
        <listitem>
          <para>average -- compute the average of the elements of a set</para>
        </listitem>

        <listitem>
          <para>getOneFrom -- pick a random element from a set</para>
        </listitem>

        <listitem>
          <para>isEmpty -- is set empty?</para>
        </listitem>

        <listitem>
          <para>mapper -- apply a function to each element of a set</para>
        </listitem>

        <listitem>
          <para>max -- largest element of a set</para>
        </listitem>

        <listitem>
          <para>min -- smallest element of a set</para>
        </listitem>

        <listitem>
          <para>multiply -- multiply the elements of a set</para>
        </listitem>

        <listitem>
          <para>power -- return all subsets of a set</para>
        </listitem>

        <listitem>
          <para>power1-- return all subsets (excluding empty set) of a
          set</para>
        </listitem>

        <listitem>
          <para>reducer -- apply function F to successive elements of a
          set</para>
        </listitem>

        <listitem>
          <para>size -- number of elements in a set</para>
        </listitem>

        <listitem>
          <para>sum -- add the elements of a set</para>
        </listitem>

        <listitem>
          <para>takeOneFrom -- remove an arbitrary element from a set, returns
          the element and the modified set</para>
        </listitem>

        <listitem>
          <para>toList -- convert a set to a list</para>
        </listitem>

        <listitem>
          <para>toMap -- convert a set of tuples to a map</para>
        </listitem>

        <listitem>
          <para>toString -- convert a set to a string</para>
        </listitem>
      </itemizedlist>
    </section>

    <section>
      <title>String</title>

      <itemizedlist>
        <listitem>
          <para>charAt -- return the character at position i in string
          s.</para>
        </listitem>

        <listitem>
          <para>endsWith -- returns true if string s ends with given string
          suffix.</para>
        </listitem>

        <listitem>
          <para>center -- center s in string of length n using spaces</para>
        </listitem>

        <listitem>
          <para>center -- center s in string of length n using a pad
          character</para>
        </listitem>

        <listitem>
          <para>isEmpty -- is string empty</para>
        </listitem>

        <listitem>
          <para>left -- left align s in string of length n using spaces</para>
        </listitem>

        <listitem>
          <para>left -- left align s in string of length n using pad
          character</para>
        </listitem>

        <listitem>
          <para>right -- right align s in string of length n using
          spaces</para>
        </listitem>

        <listitem>
          <para>right -- right align s in string of length n using pad
          character</para>
        </listitem>

        <listitem>
          <para>reverse -- return string with all characters in reverse
          order.</para>
        </listitem>

        <listitem>
          <para>size -- return the length of string s.</para>
        </listitem>

        <listitem>
          <para>startsWith -- return true if string s starts with the string
          prefix.</para>
        </listitem>

        <listitem>
          <para>toLowerCase -- convert all characters in string s to
          lowercase.</para>
        </listitem>

        <listitem>
          <para>toUpperCase -- convert all characters in string s to
          uppercase.</para>
        </listitem>
      </itemizedlist>
    </section>

    <section>
      <title>UnitTest</title>

      <para>We provided a very rudimentary library for unit testing that will
      certainly evolve over time:</para>

      <itemizedlist>
        <listitem>
          <para>assertEqual -- succeeds is arguments are equal</para>
        </listitem>

        <listitem>
          <para>assertTrue -- succeeds if argument is true</para>
        </listitem>

        <listitem>
          <para>report -- report the results of unit testing</para>
        </listitem>
      </itemizedlist>
    </section>
  </section>

  <section>
    <title>Syntax Definition</title>

    <para>See separate SDF definition.</para>
  </section>

  <section>
    <title>DO NOT READ BEYOND THIS POINT</title>

    <para>The following contains incoherent snippets that may be inserted
    somewhere later on. Some texts are outdated.</para>
  </section>

  <section xml:id="section.issues">
    <title xml:id="Issues">Misc</title>

    <itemizedlist>
      <listitem>
        <para>Unexplored idea: add (possibly lazy) generators for all types;
        this allows to generate, for instance, all statements in a
        program.</para>
      </listitem>

      <listitem>
        <para>Shopping list of ideas in Tom:</para>

        <itemizedlist>
          <listitem>
            <para>Named patterns to avoid building a term, i.e. w@[| while
            $Exp do $stat od |].</para>
          </listitem>

          <listitem>
            <para>Anonymous variables a la Prolog: [| while $_ do $stat od
            |].</para>
          </listitem>

          <listitem>
            <para>String matching in patterns.</para>
          </listitem>

          <listitem>
            <para>Tom uses the notation %[ ... ]% for quoted strings with
            embedded @...@ constructs that are evaluated. It also has a
            backquote construct.</para>
          </listitem>
        </itemizedlist>
      </listitem>

      <listitem>
        <para>Shopping list of ideas from TXL:</para>

        <itemizedlist>
          <listitem>
            <para>"redefine" allows modification of an imported
            grammar.</para>
          </listitem>
        </itemizedlist>
      </listitem>
    </itemizedlist>
  </section>

  <section>
    <title>Read-Eval-Print Loop (REPL) [Needs further discussion]</title>

    <para>For the scripting of applications it is important to have a command
    language and read-eval-print loop. Here is an attempt.</para>

    <para>We copy the Python REPL style:</para>

    <itemizedlist>
      <listitem>
        <para>The command promt prompt is "&gt;&gt;&gt;".</para>
      </listitem>

      <listitem>
        <para>Continuation lines are prefixed with "...".</para>
      </listitem>

      <listitem>
        <para>Answers start at the beginning of the line.</para>

        <caution>
          <para>This is not compatible with the current implementation.</para>
        </caution>
      </listitem>
    </itemizedlist>

    <para><programlisting>&gt;&gt;&gt; {1, 2, 3} + {2, 3, 4}
{1, 2, 3, 4}
&gt;&gt;&gt; first([1, 2, 3])
1
&gt;&gt;&gt; rest([ 1,
...           2, 3])
[2, 3]</programlisting>One advantage of this style is that such a dialog can
    be run and checked automatically. This has two effects:</para>

    <itemizedlist>
      <listitem>
        <para>Examples in manuals become test cases.</para>
      </listitem>

      <listitem>
        <para>We can introduce a "tests" attribute for functions that conatisn
        a REPL script. This can also be tested. Example:<programlisting>public &amp;T max(set[&amp;T] R)
  @doc{Maximum of a set}
  @tests{
  &gt;&gt;&gt; max({1, 2, 3})
  3
  &gt;&gt;&gt; max({3, 2, 1})
  3
  }
{
  &amp;T result = arb(R);
  for(&amp;T E : R){
    result = max(result, E);
  }
  return result;
}</programlisting></para>
      </listitem>
    </itemizedlist>

    <para><caution>
        <para>The remainder of this section is a mess!</para>
      </caution><programlisting>&gt;&gt;&gt; import lang.java.syntax.Main as Java;
&gt;&gt;&gt; str source = read("program.java");
&gt;&gt;&gt; CU program = parseString(source);

data B and(B b1, B b2)

B.and &lt;= B &lt;= value

lexical syntax
  [\n\ \t\n] -&gt; LAYOUT


view Boolean &lt;= tree and(B b1, LAYOUT? l, 'a' a?, LAYOUT? l2, B b2) appl(prod([ B &amp; B -&gt; B], [ B b1 , LAYOUT? _, lit('a'), LAYOUT? _ = appl(),B b2 ])
view Boolean &lt;= tree or()            appl()

Boolean . and &lt;= Boolean &lt;= tree &lt;= value

&gt; int count(CU P) {
&gt;   int cnt = 0;
    Boolean B1 = true, B2, B3;

&gt;   visit(P) {
      acase and(B1,l1=&lt;LAYOUT? L&gt;,&lt;Boolean B2&gt;) =&gt; and(B1, l1=parseString(" "), a=A, l2=" ", B2) 
      case &lt;Boolean B1&gt; &amp; &lt;B2&gt; : 
      case B &amp; B : 
      case [| &lt;Identifier&gt; |] : natural =&gt;
&gt;     acase if(&lt;E&gt;,&lt;S&gt;) : cnt++;
      acase &lt;Bool.and is&gt; 
&gt;   }
&gt;   return cnt
&gt; }

&gt; count(program)
17</programlisting>There are several innovations here:</para>

    <itemizedlist>
      <listitem>
        <para>The import associates a name with the imported module.<caution>
            <para>Work out the details.</para>
          </caution><note>
            <para>This means that "grammar" and "rule" become notions that can
            be manipulated.</para>
          </note></para>
      </listitem>

      <listitem>
        <para>There is a read functions that reads a text file into a
        string.</para>
      </listitem>

      <listitem>
        <para>We associate a parse function with every non-terminal in a
        grammar.</para>
      </listitem>

      <listitem>
        <para>The notation <literal>Java::Statements.IF</literal> consists of
        three parts:</para>

        <itemizedlist>
          <listitem>
            <para>Language name</para>
          </listitem>

          <listitem>
            <para>Sort name</para>
          </listitem>

          <listitem>
            <para>Rule name (currently implemented with the "cons"
            attribute).</para>
          </listitem>
        </itemizedlist>

        <para>It can be used as pattern. Other potential uses are as
        generator:<programlisting>{S | Java::Statements.IF S : P}</programlisting>It
        generates all if statements in P.</para>
      </listitem>
    </itemizedlist>
  </section>

  <section>
    <title>Expression operators</title>

    <para><table>
        <title>Usage of selected characters in Rascal Syntax</title>

        <tgroup cols="2">
          <colspec align="center" />

          <thead>
            <row>
              <entry align="center">&#160;Characters</entry>

              <entry align="center">Used in</entry>
            </row>
          </thead>

          <tbody>
            <row>
              <entry>+</entry>

              <entry>+ (add/conc), +=, + (closure)</entry>
            </row>

            <row>
              <entry>-</entry>

              <entry>- (sub/diff), -=, in names</entry>
            </row>

            <row>
              <entry>*</entry>

              <entry>* (prod), *=, * (closure)</entry>
            </row>

            <row>
              <entry>/</entry>

              <entry>/ (div)</entry>
            </row>

            <row>
              <entry>=</entry>

              <entry>== (equal), != (nequal), =&gt; (case), +=, -=, *=, /=,
              &amp;=, |=, &lt;= (leq), &gt;= (geq), ~= (match)</entry>
            </row>

            <row>
              <entry>&amp;</entry>

              <entry>&amp; (intersection), &amp;&amp; (and), &amp;=, &amp;
              (type var)</entry>
            </row>

            <row>
              <entry>@</entry>

              <entry>@ (get annotation), _ @ _ = _ (modify annotation), @{...}
              (declaration annotation)</entry>
            </row>

            <row>
              <entry>|</entry>

              <entry>| (union), || (or), [| _ |] (quotes), { _ | _ }
              (comprehension), |=</entry>
            </row>

            <row>
              <entry>!</entry>

              <entry>! (not), != (neq), ~! (nomatch)</entry>
            </row>

            <row>
              <entry>&gt;</entry>

              <entry>&gt; (gt), &gt;= (geq), =&gt; (case), &lt; _ &gt;
              (PatternVariable), &lt; _ &gt; (tuple)</entry>
            </row>

            <row>
              <entry>&lt;</entry>

              <entry>&lt; (lt), &lt;= (leq), &lt; _ &gt; (PatternVariable),
              &lt; _ &gt; (tuple), &lt;: (subtype)</entry>
            </row>

            <row>
              <entry>?</entry>

              <entry>? (anno operator), _ ? _ : _ (cond expr)</entry>
            </row>

            <row>
              <entry>:</entry>

              <entry>~~ (match), !~~ (nomatch), case _ : (case), in generator,
              &lt;: (subtype)</entry>
            </row>

            <row>
              <entry>[ and ]</entry>

              <entry>[| _ |] (quote), [ _ ] (projection), [ _ | _ ] (list
              comprehension), [ _ ] (list), type decls</entry>
            </row>

            <row>
              <entry>{ and }</entry>

              <entry>{ _ } (statements), { _ } (set/rel), { _ | _ } (set/rel
              comprehension)</entry>
            </row>
          </tbody>
        </tgroup>
      </table></para>
  </section>

  <section>
    <title>Visitor definitions (UNDECIDED and INCOMPLETE)</title>

    <para>Visitor definitions are a new idea that borrow the programmability
    of Systems S's single level traversals and add them to Rascal. The idea is
    to be able to define the strategy annotations of visit statements and
    generators using a simple expression language. A definition takes as
    formal argument the code block of the visit statement (s), which is what
    needs to be done at every node (the visitor).</para>

    <para><programlisting>%% first recurse to the arguments, then try v, 
%% which if it fails returns the original structure.
<emphasis role="bold">visitor</emphasis> bottom-up(v) = <emphasis role="bold">all</emphasis>(bottom-up(v)) ; (v <emphasis
          role="bold">&lt;+</emphasis> <emphasis role="bold">id</emphasis>)

<emphasis role="bold">visitor</emphasis> innermost(t,v) = <emphasis
          role="bold">all</emphasis>(innermost(t,v)) ; <emphasis role="bold">repeat</emphasis>(v &lt;+ id) 
    </programlisting>We demand that all visitors are infallible, which means
    that when the v block fails, they must return a default result of the
    correct type. In most cases, this would be the identity (id).</para>

    <para>We can also try to give these definitions a more imperative look, as
    if they are patterns for generating code for the visitors, as in:</para>

    <para><programlisting><emphasis role="bold">visitor</emphasis> bottom-up(v) {
  <emphasis role="bold">all</emphasis> {
     bottom-up(v);
  }

  <emphasis role="bold">try</emphasis> {             %% try is the '&lt;+' of System S, 
                    %% only if v fails the catch block is executed.
    v;
  } <emphasis role="bold">catch</emphasis> <emphasis role="bold">fail</emphasis>(t) {
    <emphasis role="bold">yield</emphasis> t;
  } 
}

%% innermost goes down and only returns after 
%% nothing changes anymore

<emphasis role="bold">visitor</emphasis> innermost(v) {
  <emphasis role="bold">all</emphasis> {
    innermost(v);     %% apply this to all children first.
  }
  <emphasis role="bold">while (true) {</emphasis> {    %% then until kingdom come, apply this block:
    <emphasis role="bold">try</emphasis> {
      v;              %% if v succeeds, it has a yield or a return
                      %% statement that updates the current node. 
    } <emphasis role="bold">catch fail</emphasis>(t) { %% if v fails after all, we obtain a reference
                      %% to the current node visited which we can 
                      %% return;
      <emphasis role="bold">yield</emphasis> t;
    } 
  }
}   

visitor bottom-up-dbg(v) {  <emphasis role="bold">
  all</emphasis> {
     bottom-up(v);
  }

  <emphasis role="bold">try</emphasis> {              %% try is the '&lt;+' of System S,
                     %% only if v fails the catch block is executed.
    v;
  } <emphasis role="bold">catch</emphasis> <emphasis role="bold">fail</emphasis>(t) {
    printf("DBG: bottom-up visitor failed on: " + t);
    <emphasis role="bold">yield</emphasis> t;
  } 
}</programlisting>After such definitions, most of which would be in the
    standard library of Rascal, we can use them to program actual
    visits:</para>

    <para><programlisting>visit bottom-up (t) {
  pattern =&gt; pattern
  pattern2 : { effect; }
}</programlisting></para>
  </section>
</article>