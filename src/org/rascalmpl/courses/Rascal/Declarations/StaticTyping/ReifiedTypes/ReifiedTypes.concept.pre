concept("ReifiedTypes",|tutor:///Rascal/Declarations/StaticTyping/ReifiedTypes/ReifiedTypes.concept|,[],[],{},""," \<code\># $Name\</code\>\n"," \<code\>type\</code\>\n","",{"Name","type","#"}," Usually one declares functions that have arguments that have a type that corresponds to one of the many forms of values in Rascal.\n In exceptional circumstances it is desirable to define functions that have a type itself as argument. \n \<br/\>\n\<br/\>\n\n To solve this problem in a more general manner something special has to be done. \n Types are not values and without an additional mechanism they cannot be passed as arguments to functions. \n To achieve this effect we introduce reified types that are denoted by the type \<code\>type\</code\>. \n In other words, reified types make it possible to use types as values.\n"," The prototypical example is a parse function: how to write a type safe parse function that expresses the type of the result we expect?\n Suppose we want to parse a language that has the non-terminals \<code\>EXP\</code\>, \<code\>STAT\</code\> and \<code\>PROGRAM\</code\>.\n A first, naive, solution introduces a parse function for each non-terminal:\n  \<pre class=\"listing\"\>EXP parseEXP(str s){ ... }\nSTAT parsePROGRAM(str s) { ... }\nPROGRAM parsePROGRAM(str s) { ... }\n\</pre\> Unfortunately this solution does not scale well to large languages with many non-terminals and it breaks down completely \n when we do not know the non-terminals before hand.\n \<br/\>\n\<br/\>\n\n Now we can write:\n  \<pre class=\"listing\"\>&amp;T parse(type[&amp;T] start, str s) { ... }\n\</pre\> and use the parse by giving it a type as argument:\n  \<pre class=\"listing\"\>parse(#EXP, \"1+3\");\n\</pre\>","","",[])