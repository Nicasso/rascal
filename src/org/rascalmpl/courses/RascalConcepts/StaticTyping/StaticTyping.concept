# Static Typing

.Synopsis
Static type checking.

.Syntax

.Types

.Function

.Details


image::type-lattice.png[width=400,title="Type Lattice"]

.Description
Rascal is based on static typing, this means that as many errors and inconsistencies as possible are spotted before the program is executed. 
The types are ordered in a so-called _type lattice_ shown in the figure above.

The arrows describe a _subtype-of_ relation between types. The type `void` is the _smallest_ type and 
is included in all other types and the type `value` is the _largest_ type that includes all other types. 
We also see that `rel` is a subtype of `set` and that each ADT is a subtype of `node`. 
A special role is played by the datatype `Tree` that is the generic type of syntax trees. 
Syntax trees for specific languages are all subtypes of `Tree`. As a result, syntax trees can be addressed at two levels: 

*  in a generic fashion as `Tree` and,
*  in a specific fashion as a more precisely typed syntax tree. 
Finally, each `alias` is structurally equivalent to one or more specific other types.

Rascal does not provide an explicit casting mechanism (as in Java), but pattern matching can play that role.
 
The language provides higher-order, parametric polymorphism. 
A type aliasing mechanism allows documenting specific uses of a type. 
Built-in operators are heavily overloaded. 
For instance, the operator `+` is used for addition on integers and reals but also for list concatenation, 
set union and the like.

.Examples

Some example can illustrate the above.
[source,rascal-shell,error]
----
int I = 3;
----
Since I is declared as type `int`, we cannot assign a `real` value to it:
[source,rascal-shell,continue,error]
----
I = 3.5;
----

[source,rascal-shell]
----
num N = 3;
----
Since N is declared as type `num`, we can assign both `int` and `real` values to it:
[source,rascal-shell,continue]
----
N = 3.5;
----

Since all types are a subtype of type `value`, one can assign values of any type to a variable declared as `value`:
[source,rascal-shell]
----
value V = 3;
V = "abc";
V = false;
----
We can use pattern matching to classify the actual type of a value:
[source,rascal-shell,continue]
----
str classify(value V){
  switch(V){
    case str S: return "A string";
    case bool B: return "A Boolean";
    default: return "Another type"; 
  }
}
classify(V);
V = 3.5;
classify(V);
----

In addition to these standard examples, it is interesting that all link:/Rascal#Declarations-AlgebraicDataType[Algebraic Data Types] are subtypes of type `node`.
Let's introduce a simple `Color` data type:
[source,rascal-shell]
----
data Color = red(int level) | blue(int level);
----
Unsurprisingly, we have:
[source,rascal-shell,continue]
----
Color C = red(3);
----
Due to subtyping, we can also have:
[source,rascal-shell,continue]
----
node ND = red(3);
----

One example of the actual application of subtypes can be found in 
link:/Recipes#Common-CountConstructors[Count Constructors].

.Benefits

.Pitfalls

