<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<!--[if IE]><meta http-equiv="X-UA-Compatible" content="IE=edge"><![endif]-->
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="generator" content="Asciidoctor 1.5.4">
<title>Recipes</title>
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:300,300italic,400,400italic,600,600italic%7CNoto+Serif:400,400italic,700,700italic%7CDroid+Sans+Mono:400,700">
<style>
/* Asciidoctor default stylesheet | MIT License | http://asciidoctor.org */
/* Remove comment around @import statement below when using as a custom stylesheet */
/*@import "https://fonts.googleapis.com/css?family=Open+Sans:300,300italic,400,400italic,600,600italic%7CNoto+Serif:400,400italic,700,700italic%7CDroid+Sans+Mono:400,700";*/
article,aside,details,figcaption,figure,footer,header,hgroup,main,nav,section,summary{display:block}
audio,canvas,video{display:inline-block}
audio:not([controls]){display:none;height:0}
[hidden],template{display:none}
script{display:none!important}
html{font-family:sans-serif;-ms-text-size-adjust:100%;-webkit-text-size-adjust:100%}
body{margin:0}
a{background:transparent}
a:focus{outline:thin dotted}
a:active,a:hover{outline:0}
h1{font-size:2em;margin:.67em 0}
abbr[title]{border-bottom:1px dotted}
b,strong{font-weight:bold}
dfn{font-style:italic}
hr{-moz-box-sizing:content-box;box-sizing:content-box;height:0}
mark{background:#ff0;color:#000}
code,kbd,pre,samp{font-family:monospace;font-size:1em}
pre{white-space:pre-wrap}
q{quotes:"\201C" "\201D" "\2018" "\2019"}
small{font-size:80%}
sub,sup{font-size:75%;line-height:0;position:relative;vertical-align:baseline}
sup{top:-.5em}
sub{bottom:-.25em}
img{border:0}
svg:not(:root){overflow:hidden}
figure{margin:0}
fieldset{border:1px solid silver;margin:0 2px;padding:.35em .625em .75em}
legend{border:0;padding:0}
button,input,select,textarea{font-family:inherit;font-size:100%;margin:0}
button,input{line-height:normal}
button,select{text-transform:none}
button,html input[type="button"],input[type="reset"],input[type="submit"]{-webkit-appearance:button;cursor:pointer}
button[disabled],html input[disabled]{cursor:default}
input[type="checkbox"],input[type="radio"]{box-sizing:border-box;padding:0}
input[type="search"]{-webkit-appearance:textfield;-moz-box-sizing:content-box;-webkit-box-sizing:content-box;box-sizing:content-box}
input[type="search"]::-webkit-search-cancel-button,input[type="search"]::-webkit-search-decoration{-webkit-appearance:none}
button::-moz-focus-inner,input::-moz-focus-inner{border:0;padding:0}
textarea{overflow:auto;vertical-align:top}
table{border-collapse:collapse;border-spacing:0}
*,*:before,*:after{-moz-box-sizing:border-box;-webkit-box-sizing:border-box;box-sizing:border-box}
html,body{font-size:100%}
body{background:#fff;color:rgba(0,0,0,.8);padding:0;margin:0;font-family:"Noto Serif","DejaVu Serif",serif;font-weight:400;font-style:normal;line-height:1;position:relative;cursor:auto}
a:hover{cursor:pointer}
img,object,embed{max-width:100%;height:auto}
object,embed{height:100%}
img{-ms-interpolation-mode:bicubic}
.left{float:left!important}
.right{float:right!important}
.text-left{text-align:left!important}
.text-right{text-align:right!important}
.text-center{text-align:center!important}
.text-justify{text-align:justify!important}
.hide{display:none}
body{-webkit-font-smoothing:antialiased}
img,object,svg{display:inline-block;vertical-align:middle}
textarea{height:auto;min-height:50px}
select{width:100%}
.center{margin-left:auto;margin-right:auto}
.spread{width:100%}
p.lead,.paragraph.lead>p,#preamble>.sectionbody>.paragraph:first-of-type p{font-size:1.21875em;line-height:1.6}
.subheader,.admonitionblock td.content>.title,.audioblock>.title,.exampleblock>.title,.imageblock>.title,.listingblock>.title,.literalblock>.title,.stemblock>.title,.openblock>.title,.paragraph>.title,.quoteblock>.title,table.tableblock>.title,.verseblock>.title,.videoblock>.title,.dlist>.title,.olist>.title,.ulist>.title,.qlist>.title,.hdlist>.title{line-height:1.45;color:#7a2518;font-weight:400;margin-top:0;margin-bottom:.25em}
div,dl,dt,dd,ul,ol,li,h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6,pre,form,p,blockquote,th,td{margin:0;padding:0;direction:ltr}
a{color:#2156a5;text-decoration:underline;line-height:inherit}
a:hover,a:focus{color:#1d4b8f}
a img{border:none}
p{font-family:inherit;font-weight:400;font-size:1em;line-height:1.6;margin-bottom:1.25em;text-rendering:optimizeLegibility}
p aside{font-size:.875em;line-height:1.35;font-style:italic}
h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6{font-family:"Open Sans","DejaVu Sans",sans-serif;font-weight:300;font-style:normal;color:#ba3925;text-rendering:optimizeLegibility;margin-top:1em;margin-bottom:.5em;line-height:1.0125em}
h1 small,h2 small,h3 small,#toctitle small,.sidebarblock>.content>.title small,h4 small,h5 small,h6 small{font-size:60%;color:#e99b8f;line-height:0}
h1{font-size:2.125em}
h2{font-size:1.6875em}
h3,#toctitle,.sidebarblock>.content>.title{font-size:1.375em}
h4,h5{font-size:1.125em}
h6{font-size:1em}
hr{border:solid #ddddd8;border-width:1px 0 0;clear:both;margin:1.25em 0 1.1875em;height:0}
em,i{font-style:italic;line-height:inherit}
strong,b{font-weight:bold;line-height:inherit}
small{font-size:60%;line-height:inherit}
code{font-family:"Droid Sans Mono","DejaVu Sans Mono",monospace;font-weight:400;color:rgba(0,0,0,.9)}
ul,ol,dl{font-size:1em;line-height:1.6;margin-bottom:1.25em;list-style-position:outside;font-family:inherit}
ul,ol,ul.no-bullet,ol.no-bullet{margin-left:1.5em}
ul li ul,ul li ol{margin-left:1.25em;margin-bottom:0;font-size:1em}
ul.square li ul,ul.circle li ul,ul.disc li ul{list-style:inherit}
ul.square{list-style-type:square}
ul.circle{list-style-type:circle}
ul.disc{list-style-type:disc}
ul.no-bullet{list-style:none}
ol li ul,ol li ol{margin-left:1.25em;margin-bottom:0}
dl dt{margin-bottom:.3125em;font-weight:bold}
dl dd{margin-bottom:1.25em}
abbr,acronym{text-transform:uppercase;font-size:90%;color:rgba(0,0,0,.8);border-bottom:1px dotted #ddd;cursor:help}
abbr{text-transform:none}
blockquote{margin:0 0 1.25em;padding:.5625em 1.25em 0 1.1875em;border-left:1px solid #ddd}
blockquote cite{display:block;font-size:.9375em;color:rgba(0,0,0,.6)}
blockquote cite:before{content:"\2014 \0020"}
blockquote cite a,blockquote cite a:visited{color:rgba(0,0,0,.6)}
blockquote,blockquote p{line-height:1.6;color:rgba(0,0,0,.85)}
@media only screen and (min-width:768px){h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6{line-height:1.2}
h1{font-size:2.75em}
h2{font-size:2.3125em}
h3,#toctitle,.sidebarblock>.content>.title{font-size:1.6875em}
h4{font-size:1.4375em}}
table{background:#fff;margin-bottom:1.25em;border:solid 1px #dedede}
table thead,table tfoot{background:#f7f8f7;font-weight:bold}
table thead tr th,table thead tr td,table tfoot tr th,table tfoot tr td{padding:.5em .625em .625em;font-size:inherit;color:rgba(0,0,0,.8);text-align:left}
table tr th,table tr td{padding:.5625em .625em;font-size:inherit;color:rgba(0,0,0,.8)}
table tr.even,table tr.alt,table tr:nth-of-type(even){background:#f8f8f7}
table thead tr th,table tfoot tr th,table tbody tr td,table tr td,table tfoot tr td{display:table-cell;line-height:1.6}
body{tab-size:4}
h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6{line-height:1.2;word-spacing:-.05em}
h1 strong,h2 strong,h3 strong,#toctitle strong,.sidebarblock>.content>.title strong,h4 strong,h5 strong,h6 strong{font-weight:400}
.clearfix:before,.clearfix:after,.float-group:before,.float-group:after{content:" ";display:table}
.clearfix:after,.float-group:after{clear:both}
*:not(pre)>code{font-size:.9375em;font-style:normal!important;letter-spacing:0;padding:.1em .5ex;word-spacing:-.15em;background-color:#f7f7f8;-webkit-border-radius:4px;border-radius:4px;line-height:1.45;text-rendering:optimizeSpeed}
pre,pre>code{line-height:1.45;color:rgba(0,0,0,.9);font-family:"Droid Sans Mono","DejaVu Sans Mono",monospace;font-weight:400;text-rendering:optimizeSpeed}
.keyseq{color:rgba(51,51,51,.8)}
kbd{font-family:"Droid Sans Mono","DejaVu Sans Mono",monospace;display:inline-block;color:rgba(0,0,0,.8);font-size:.65em;line-height:1.45;background-color:#f7f7f7;border:1px solid #ccc;-webkit-border-radius:3px;border-radius:3px;-webkit-box-shadow:0 1px 0 rgba(0,0,0,.2),0 0 0 .1em white inset;box-shadow:0 1px 0 rgba(0,0,0,.2),0 0 0 .1em #fff inset;margin:0 .15em;padding:.2em .5em;vertical-align:middle;position:relative;top:-.1em;white-space:nowrap}
.keyseq kbd:first-child{margin-left:0}
.keyseq kbd:last-child{margin-right:0}
.menuseq,.menu{color:rgba(0,0,0,.8)}
b.button:before,b.button:after{position:relative;top:-1px;font-weight:400}
b.button:before{content:"[";padding:0 3px 0 2px}
b.button:after{content:"]";padding:0 2px 0 3px}
p a>code:hover{color:rgba(0,0,0,.9)}
#header,#content,#footnotes,#footer{width:100%;margin-left:auto;margin-right:auto;margin-top:0;margin-bottom:0;max-width:62.5em;*zoom:1;position:relative;padding-left:.9375em;padding-right:.9375em}
#header:before,#header:after,#content:before,#content:after,#footnotes:before,#footnotes:after,#footer:before,#footer:after{content:" ";display:table}
#header:after,#content:after,#footnotes:after,#footer:after{clear:both}
#content{margin-top:1.25em}
#content:before{content:none}
#header>h1:first-child{color:rgba(0,0,0,.85);margin-top:2.25rem;margin-bottom:0}
#header>h1:first-child+#toc{margin-top:8px;border-top:1px solid #ddddd8}
#header>h1:only-child,body.toc2 #header>h1:nth-last-child(2){border-bottom:1px solid #ddddd8;padding-bottom:8px}
#header .details{border-bottom:1px solid #ddddd8;line-height:1.45;padding-top:.25em;padding-bottom:.25em;padding-left:.25em;color:rgba(0,0,0,.6);display:-ms-flexbox;display:-webkit-flex;display:flex;-ms-flex-flow:row wrap;-webkit-flex-flow:row wrap;flex-flow:row wrap}
#header .details span:first-child{margin-left:-.125em}
#header .details span.email a{color:rgba(0,0,0,.85)}
#header .details br{display:none}
#header .details br+span:before{content:"\00a0\2013\00a0"}
#header .details br+span.author:before{content:"\00a0\22c5\00a0";color:rgba(0,0,0,.85)}
#header .details br+span#revremark:before{content:"\00a0|\00a0"}
#header #revnumber{text-transform:capitalize}
#header #revnumber:after{content:"\00a0"}
#content>h1:first-child:not([class]){color:rgba(0,0,0,.85);border-bottom:1px solid #ddddd8;padding-bottom:8px;margin-top:0;padding-top:1rem;margin-bottom:1.25rem}
#toc{border-bottom:1px solid #efefed;padding-bottom:.5em}
#toc>ul{margin-left:.125em}
#toc ul.sectlevel0>li>a{font-style:italic}
#toc ul.sectlevel0 ul.sectlevel1{margin:.5em 0}
#toc ul{font-family:"Open Sans","DejaVu Sans",sans-serif;list-style-type:none}
#toc li{line-height:1.3334;margin-top:.3334em}
#toc a{text-decoration:none}
#toc a:active{text-decoration:underline}
#toctitle{color:#7a2518;font-size:1.2em}
@media only screen and (min-width:768px){#toctitle{font-size:1.375em}
body.toc2{padding-left:15em;padding-right:0}
#toc.toc2{margin-top:0!important;background-color:#f8f8f7;position:fixed;width:15em;left:0;top:0;border-right:1px solid #efefed;border-top-width:0!important;border-bottom-width:0!important;z-index:1000;padding:1.25em 1em;height:100%;overflow:auto}
#toc.toc2 #toctitle{margin-top:0;margin-bottom:.8rem;font-size:1.2em}
#toc.toc2>ul{font-size:.9em;margin-bottom:0}
#toc.toc2 ul ul{margin-left:0;padding-left:1em}
#toc.toc2 ul.sectlevel0 ul.sectlevel1{padding-left:0;margin-top:.5em;margin-bottom:.5em}
body.toc2.toc-right{padding-left:0;padding-right:15em}
body.toc2.toc-right #toc.toc2{border-right-width:0;border-left:1px solid #efefed;left:auto;right:0}}
@media only screen and (min-width:1280px){body.toc2{padding-left:20em;padding-right:0}
#toc.toc2{width:20em}
#toc.toc2 #toctitle{font-size:1.375em}
#toc.toc2>ul{font-size:.95em}
#toc.toc2 ul ul{padding-left:1.25em}
body.toc2.toc-right{padding-left:0;padding-right:20em}}
#content #toc{border-style:solid;border-width:1px;border-color:#e0e0dc;margin-bottom:1.25em;padding:1.25em;background:#f8f8f7;-webkit-border-radius:4px;border-radius:4px}
#content #toc>:first-child{margin-top:0}
#content #toc>:last-child{margin-bottom:0}
#footer{max-width:100%;background-color:rgba(0,0,0,.8);padding:1.25em}
#footer-text{color:rgba(255,255,255,.8);line-height:1.44}
.sect1{padding-bottom:.625em}
@media only screen and (min-width:768px){.sect1{padding-bottom:1.25em}}
.sect1+.sect1{border-top:1px solid #efefed}
#content h1>a.anchor,h2>a.anchor,h3>a.anchor,#toctitle>a.anchor,.sidebarblock>.content>.title>a.anchor,h4>a.anchor,h5>a.anchor,h6>a.anchor{position:absolute;z-index:1001;width:1.5ex;margin-left:-1.5ex;display:block;text-decoration:none!important;visibility:hidden;text-align:center;font-weight:400}
#content h1>a.anchor:before,h2>a.anchor:before,h3>a.anchor:before,#toctitle>a.anchor:before,.sidebarblock>.content>.title>a.anchor:before,h4>a.anchor:before,h5>a.anchor:before,h6>a.anchor:before{content:"\00A7";font-size:.85em;display:block;padding-top:.1em}
#content h1:hover>a.anchor,#content h1>a.anchor:hover,h2:hover>a.anchor,h2>a.anchor:hover,h3:hover>a.anchor,#toctitle:hover>a.anchor,.sidebarblock>.content>.title:hover>a.anchor,h3>a.anchor:hover,#toctitle>a.anchor:hover,.sidebarblock>.content>.title>a.anchor:hover,h4:hover>a.anchor,h4>a.anchor:hover,h5:hover>a.anchor,h5>a.anchor:hover,h6:hover>a.anchor,h6>a.anchor:hover{visibility:visible}
#content h1>a.link,h2>a.link,h3>a.link,#toctitle>a.link,.sidebarblock>.content>.title>a.link,h4>a.link,h5>a.link,h6>a.link{color:#ba3925;text-decoration:none}
#content h1>a.link:hover,h2>a.link:hover,h3>a.link:hover,#toctitle>a.link:hover,.sidebarblock>.content>.title>a.link:hover,h4>a.link:hover,h5>a.link:hover,h6>a.link:hover{color:#a53221}
.audioblock,.imageblock,.literalblock,.listingblock,.stemblock,.videoblock{margin-bottom:1.25em}
.admonitionblock td.content>.title,.audioblock>.title,.exampleblock>.title,.imageblock>.title,.listingblock>.title,.literalblock>.title,.stemblock>.title,.openblock>.title,.paragraph>.title,.quoteblock>.title,table.tableblock>.title,.verseblock>.title,.videoblock>.title,.dlist>.title,.olist>.title,.ulist>.title,.qlist>.title,.hdlist>.title{text-rendering:optimizeLegibility;text-align:left;font-family:"Noto Serif","DejaVu Serif",serif;font-size:1rem;font-style:italic}
table.tableblock>caption.title{white-space:nowrap;overflow:visible;max-width:0}
.paragraph.lead>p,#preamble>.sectionbody>.paragraph:first-of-type p{color:rgba(0,0,0,.85)}
table.tableblock #preamble>.sectionbody>.paragraph:first-of-type p{font-size:inherit}
.admonitionblock>table{border-collapse:separate;border:0;background:none;width:100%}
.admonitionblock>table td.icon{text-align:center;width:80px}
.admonitionblock>table td.icon img{max-width:none}
.admonitionblock>table td.icon .title{font-weight:bold;font-family:"Open Sans","DejaVu Sans",sans-serif;text-transform:uppercase}
.admonitionblock>table td.content{padding-left:1.125em;padding-right:1.25em;border-left:1px solid #ddddd8;color:rgba(0,0,0,.6)}
.admonitionblock>table td.content>:last-child>:last-child{margin-bottom:0}
.exampleblock>.content{border-style:solid;border-width:1px;border-color:#e6e6e6;margin-bottom:1.25em;padding:1.25em;background:#fff;-webkit-border-radius:4px;border-radius:4px}
.exampleblock>.content>:first-child{margin-top:0}
.exampleblock>.content>:last-child{margin-bottom:0}
.sidebarblock{border-style:solid;border-width:1px;border-color:#e0e0dc;margin-bottom:1.25em;padding:1.25em;background:#f8f8f7;-webkit-border-radius:4px;border-radius:4px}
.sidebarblock>:first-child{margin-top:0}
.sidebarblock>:last-child{margin-bottom:0}
.sidebarblock>.content>.title{color:#7a2518;margin-top:0;text-align:center}
.exampleblock>.content>:last-child>:last-child,.exampleblock>.content .olist>ol>li:last-child>:last-child,.exampleblock>.content .ulist>ul>li:last-child>:last-child,.exampleblock>.content .qlist>ol>li:last-child>:last-child,.sidebarblock>.content>:last-child>:last-child,.sidebarblock>.content .olist>ol>li:last-child>:last-child,.sidebarblock>.content .ulist>ul>li:last-child>:last-child,.sidebarblock>.content .qlist>ol>li:last-child>:last-child{margin-bottom:0}
.literalblock pre,.listingblock pre:not(.highlight),.listingblock pre[class="highlight"],.listingblock pre[class^="highlight "],.listingblock pre.CodeRay,.listingblock pre.prettyprint{background:#f7f7f8}
.sidebarblock .literalblock pre,.sidebarblock .listingblock pre:not(.highlight),.sidebarblock .listingblock pre[class="highlight"],.sidebarblock .listingblock pre[class^="highlight "],.sidebarblock .listingblock pre.CodeRay,.sidebarblock .listingblock pre.prettyprint{background:#f2f1f1}
.literalblock pre,.literalblock pre[class],.listingblock pre,.listingblock pre[class]{-webkit-border-radius:4px;border-radius:4px;word-wrap:break-word;padding:1em;font-size:.8125em}
.literalblock pre.nowrap,.literalblock pre[class].nowrap,.listingblock pre.nowrap,.listingblock pre[class].nowrap{overflow-x:auto;white-space:pre;word-wrap:normal}
@media only screen and (min-width:768px){.literalblock pre,.literalblock pre[class],.listingblock pre,.listingblock pre[class]{font-size:.90625em}}
@media only screen and (min-width:1280px){.literalblock pre,.literalblock pre[class],.listingblock pre,.listingblock pre[class]{font-size:1em}}
.literalblock.output pre{color:#f7f7f8;background-color:rgba(0,0,0,.9)}
.listingblock pre.highlightjs{padding:0}
.listingblock pre.highlightjs>code{padding:1em;-webkit-border-radius:4px;border-radius:4px}
.listingblock pre.prettyprint{border-width:0}
.listingblock>.content{position:relative}
.listingblock code[data-lang]:before{display:none;content:attr(data-lang);position:absolute;font-size:.75em;top:.425rem;right:.5rem;line-height:1;text-transform:uppercase;color:#999}
.listingblock:hover code[data-lang]:before{display:block}
.listingblock.terminal pre .command:before{content:attr(data-prompt);padding-right:.5em;color:#999}
.listingblock.terminal pre .command:not([data-prompt]):before{content:"$"}
table.pyhltable{border-collapse:separate;border:0;margin-bottom:0;background:none}
table.pyhltable td{vertical-align:top;padding-top:0;padding-bottom:0;line-height:1.45}
table.pyhltable td.code{padding-left:.75em;padding-right:0}
pre.pygments .lineno,table.pyhltable td:not(.code){color:#999;padding-left:0;padding-right:.5em;border-right:1px solid #ddddd8}
pre.pygments .lineno{display:inline-block;margin-right:.25em}
table.pyhltable .linenodiv{background:none!important;padding-right:0!important}
.quoteblock{margin:0 1em 1.25em 1.5em;display:table}
.quoteblock>.title{margin-left:-1.5em;margin-bottom:.75em}
.quoteblock blockquote,.quoteblock blockquote p{color:rgba(0,0,0,.85);font-size:1.15rem;line-height:1.75;word-spacing:.1em;letter-spacing:0;font-style:italic;text-align:justify}
.quoteblock blockquote{margin:0;padding:0;border:0}
.quoteblock blockquote:before{content:"\201c";float:left;font-size:2.75em;font-weight:bold;line-height:.6em;margin-left:-.6em;color:#7a2518;text-shadow:0 1px 2px rgba(0,0,0,.1)}
.quoteblock blockquote>.paragraph:last-child p{margin-bottom:0}
.quoteblock .attribution{margin-top:.5em;margin-right:.5ex;text-align:right}
.quoteblock .quoteblock{margin-left:0;margin-right:0;padding:.5em 0;border-left:3px solid rgba(0,0,0,.6)}
.quoteblock .quoteblock blockquote{padding:0 0 0 .75em}
.quoteblock .quoteblock blockquote:before{display:none}
.verseblock{margin:0 1em 1.25em 1em}
.verseblock pre{font-family:"Open Sans","DejaVu Sans",sans;font-size:1.15rem;color:rgba(0,0,0,.85);font-weight:300;text-rendering:optimizeLegibility}
.verseblock pre strong{font-weight:400}
.verseblock .attribution{margin-top:1.25rem;margin-left:.5ex}
.quoteblock .attribution,.verseblock .attribution{font-size:.9375em;line-height:1.45;font-style:italic}
.quoteblock .attribution br,.verseblock .attribution br{display:none}
.quoteblock .attribution cite,.verseblock .attribution cite{display:block;letter-spacing:-.025em;color:rgba(0,0,0,.6)}
.quoteblock.abstract{margin:0 0 1.25em 0;display:block}
.quoteblock.abstract blockquote,.quoteblock.abstract blockquote p{text-align:left;word-spacing:0}
.quoteblock.abstract blockquote:before,.quoteblock.abstract blockquote p:first-of-type:before{display:none}
table.tableblock{max-width:100%;border-collapse:separate}
table.tableblock td>.paragraph:last-child p>p:last-child,table.tableblock th>p:last-child,table.tableblock td>p:last-child{margin-bottom:0}
table.tableblock,th.tableblock,td.tableblock{border:0 solid #dedede}
table.grid-all th.tableblock,table.grid-all td.tableblock{border-width:0 1px 1px 0}
table.grid-all tfoot>tr>th.tableblock,table.grid-all tfoot>tr>td.tableblock{border-width:1px 1px 0 0}
table.grid-cols th.tableblock,table.grid-cols td.tableblock{border-width:0 1px 0 0}
table.grid-all *>tr>.tableblock:last-child,table.grid-cols *>tr>.tableblock:last-child{border-right-width:0}
table.grid-rows th.tableblock,table.grid-rows td.tableblock{border-width:0 0 1px 0}
table.grid-all tbody>tr:last-child>th.tableblock,table.grid-all tbody>tr:last-child>td.tableblock,table.grid-all thead:last-child>tr>th.tableblock,table.grid-rows tbody>tr:last-child>th.tableblock,table.grid-rows tbody>tr:last-child>td.tableblock,table.grid-rows thead:last-child>tr>th.tableblock{border-bottom-width:0}
table.grid-rows tfoot>tr>th.tableblock,table.grid-rows tfoot>tr>td.tableblock{border-width:1px 0 0 0}
table.frame-all{border-width:1px}
table.frame-sides{border-width:0 1px}
table.frame-topbot{border-width:1px 0}
th.halign-left,td.halign-left{text-align:left}
th.halign-right,td.halign-right{text-align:right}
th.halign-center,td.halign-center{text-align:center}
th.valign-top,td.valign-top{vertical-align:top}
th.valign-bottom,td.valign-bottom{vertical-align:bottom}
th.valign-middle,td.valign-middle{vertical-align:middle}
table thead th,table tfoot th{font-weight:bold}
tbody tr th{display:table-cell;line-height:1.6;background:#f7f8f7}
tbody tr th,tbody tr th p,tfoot tr th,tfoot tr th p{color:rgba(0,0,0,.8);font-weight:bold}
p.tableblock>code:only-child{background:none;padding:0}
p.tableblock{font-size:1em}
td>div.verse{white-space:pre}
ol{margin-left:1.75em}
ul li ol{margin-left:1.5em}
dl dd{margin-left:1.125em}
dl dd:last-child,dl dd:last-child>:last-child{margin-bottom:0}
ol>li p,ul>li p,ul dd,ol dd,.olist .olist,.ulist .ulist,.ulist .olist,.olist .ulist{margin-bottom:.625em}
ul.unstyled,ol.unnumbered,ul.checklist,ul.none{list-style-type:none}
ul.unstyled,ol.unnumbered,ul.checklist{margin-left:.625em}
ul.checklist li>p:first-child>.fa-square-o:first-child,ul.checklist li>p:first-child>.fa-check-square-o:first-child{width:1em;font-size:.85em}
ul.checklist li>p:first-child>input[type="checkbox"]:first-child{width:1em;position:relative;top:1px}
ul.inline{margin:0 auto .625em auto;margin-left:-1.375em;margin-right:0;padding:0;list-style:none;overflow:hidden}
ul.inline>li{list-style:none;float:left;margin-left:1.375em;display:block}
ul.inline>li>*{display:block}
.unstyled dl dt{font-weight:400;font-style:normal}
ol.arabic{list-style-type:decimal}
ol.decimal{list-style-type:decimal-leading-zero}
ol.loweralpha{list-style-type:lower-alpha}
ol.upperalpha{list-style-type:upper-alpha}
ol.lowerroman{list-style-type:lower-roman}
ol.upperroman{list-style-type:upper-roman}
ol.lowergreek{list-style-type:lower-greek}
.hdlist>table,.colist>table{border:0;background:none}
.hdlist>table>tbody>tr,.colist>table>tbody>tr{background:none}
td.hdlist1,td.hdlist2{vertical-align:top;padding:0 .625em}
td.hdlist1{font-weight:bold;padding-bottom:1.25em}
.literalblock+.colist,.listingblock+.colist{margin-top:-.5em}
.colist>table tr>td:first-of-type{padding:0 .75em;line-height:1}
.colist>table tr>td:last-of-type{padding:.25em 0}
.thumb,.th{line-height:0;display:inline-block;border:solid 4px #fff;-webkit-box-shadow:0 0 0 1px #ddd;box-shadow:0 0 0 1px #ddd}
.imageblock.left,.imageblock[style*="float: left"]{margin:.25em .625em 1.25em 0}
.imageblock.right,.imageblock[style*="float: right"]{margin:.25em 0 1.25em .625em}
.imageblock>.title{margin-bottom:0}
.imageblock.thumb,.imageblock.th{border-width:6px}
.imageblock.thumb>.title,.imageblock.th>.title{padding:0 .125em}
.image.left,.image.right{margin-top:.25em;margin-bottom:.25em;display:inline-block;line-height:0}
.image.left{margin-right:.625em}
.image.right{margin-left:.625em}
a.image{text-decoration:none;display:inline-block}
a.image object{pointer-events:none}
sup.footnote,sup.footnoteref{font-size:.875em;position:static;vertical-align:super}
sup.footnote a,sup.footnoteref a{text-decoration:none}
sup.footnote a:active,sup.footnoteref a:active{text-decoration:underline}
#footnotes{padding-top:.75em;padding-bottom:.75em;margin-bottom:.625em}
#footnotes hr{width:20%;min-width:6.25em;margin:-.25em 0 .75em 0;border-width:1px 0 0 0}
#footnotes .footnote{padding:0 .375em 0 .225em;line-height:1.3334;font-size:.875em;margin-left:1.2em;text-indent:-1.05em;margin-bottom:.2em}
#footnotes .footnote a:first-of-type{font-weight:bold;text-decoration:none}
#footnotes .footnote:last-of-type{margin-bottom:0}
#content #footnotes{margin-top:-.625em;margin-bottom:0;padding:.75em 0}
.gist .file-data>table{border:0;background:#fff;width:100%;margin-bottom:0}
.gist .file-data>table td.line-data{width:99%}
div.unbreakable{page-break-inside:avoid}
.big{font-size:larger}
.small{font-size:smaller}
.underline{text-decoration:underline}
.overline{text-decoration:overline}
.line-through{text-decoration:line-through}
.aqua{color:#00bfbf}
.aqua-background{background-color:#00fafa}
.black{color:#000}
.black-background{background-color:#000}
.blue{color:#0000bf}
.blue-background{background-color:#0000fa}
.fuchsia{color:#bf00bf}
.fuchsia-background{background-color:#fa00fa}
.gray{color:#606060}
.gray-background{background-color:#7d7d7d}
.green{color:#006000}
.green-background{background-color:#007d00}
.lime{color:#00bf00}
.lime-background{background-color:#00fa00}
.maroon{color:#600000}
.maroon-background{background-color:#7d0000}
.navy{color:#000060}
.navy-background{background-color:#00007d}
.olive{color:#606000}
.olive-background{background-color:#7d7d00}
.purple{color:#600060}
.purple-background{background-color:#7d007d}
.red{color:#bf0000}
.red-background{background-color:#fa0000}
.silver{color:#909090}
.silver-background{background-color:#bcbcbc}
.teal{color:#006060}
.teal-background{background-color:#007d7d}
.white{color:#bfbfbf}
.white-background{background-color:#fafafa}
.yellow{color:#bfbf00}
.yellow-background{background-color:#fafa00}
span.icon>.fa{cursor:default}
.admonitionblock td.icon [class^="fa icon-"]{font-size:2.5em;text-shadow:1px 1px 2px rgba(0,0,0,.5);cursor:default}
.admonitionblock td.icon .icon-note:before{content:"\f05a";color:#19407c}
.admonitionblock td.icon .icon-tip:before{content:"\f0eb";text-shadow:1px 1px 2px rgba(155,155,0,.8);color:#111}
.admonitionblock td.icon .icon-warning:before{content:"\f071";color:#bf6900}
.admonitionblock td.icon .icon-caution:before{content:"\f06d";color:#bf3400}
.admonitionblock td.icon .icon-important:before{content:"\f06a";color:#bf0000}
.conum[data-value]{display:inline-block;color:#fff!important;background-color:rgba(0,0,0,.8);-webkit-border-radius:100px;border-radius:100px;text-align:center;font-size:.75em;width:1.67em;height:1.67em;line-height:1.67em;font-family:"Open Sans","DejaVu Sans",sans-serif;font-style:normal;font-weight:bold}
.conum[data-value] *{color:#fff!important}
.conum[data-value]+b{display:none}
.conum[data-value]:after{content:attr(data-value)}
pre .conum[data-value]{position:relative;top:-.125em}
b.conum *{color:inherit!important}
.conum:not([data-value]):empty{display:none}
dt,th.tableblock,td.content,div.footnote{text-rendering:optimizeLegibility}
h1,h2,p,td.content,span.alt{letter-spacing:-.01em}
p strong,td.content strong,div.footnote strong{letter-spacing:-.005em}
p,blockquote,dt,td.content,span.alt{font-size:1.0625rem}
p{margin-bottom:1.25rem}
.sidebarblock p,.sidebarblock dt,.sidebarblock td.content,p.tableblock{font-size:1em}
.exampleblock>.content{background-color:#fffef7;border-color:#e0e0dc;-webkit-box-shadow:0 1px 4px #e0e0dc;box-shadow:0 1px 4px #e0e0dc}
.print-only{display:none!important}
@media print{@page{margin:1.25cm .75cm}
*{-webkit-box-shadow:none!important;box-shadow:none!important;text-shadow:none!important}
a{color:inherit!important;text-decoration:underline!important}
a.bare,a[href^="#"],a[href^="mailto:"]{text-decoration:none!important}
a[href^="http:"]:not(.bare):after,a[href^="https:"]:not(.bare):after{content:"(" attr(href) ")";display:inline-block;font-size:.875em;padding-left:.25em}
abbr[title]:after{content:" (" attr(title) ")"}
pre,blockquote,tr,img,object,svg{page-break-inside:avoid}
thead{display:table-header-group}
svg{max-width:100%}
p,blockquote,dt,td.content{font-size:1em;orphans:3;widows:3}
h2,h3,#toctitle,.sidebarblock>.content>.title{page-break-after:avoid}
#toc,.sidebarblock,.exampleblock>.content{background:none!important}
#toc{border-bottom:1px solid #ddddd8!important;padding-bottom:0!important}
.sect1{padding-bottom:0!important}
.sect1+.sect1{border:0!important}
#header>h1:first-child{margin-top:1.25rem}
body.book #header{text-align:center}
body.book #header>h1:first-child{border:0!important;margin:2.5em 0 1em 0}
body.book #header .details{border:0!important;display:block;padding:0!important}
body.book #header .details span:first-child{margin-left:0!important}
body.book #header .details br{display:block}
body.book #header .details br+span:before{content:none!important}
body.book #toc{border:0!important;text-align:left!important;padding:0!important;margin:0!important}
body.book #toc,body.book #preamble,body.book h1.sect0,body.book .sect1>h2{page-break-before:always}
.listingblock code[data-lang]:before{display:block}
#footer{background:none!important;padding:0 .9375em}
#footer-text{color:rgba(0,0,0,.6)!important;font-size:.9em}
.hide-on-print{display:none!important}
.print-only{display:block!important}
.hide-for-print{display:none!important}
.show-for-print{display:inherit!important}}
</style>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.5.0/css/font-awesome.min.css">
</head>
<body id="Recipes" class="article toc2 toc-left">
<div id="header">
<h1>Recipes</h1>
<div id="toc" class="toc2">
<div id="toctitle">Recipes</div>
<ul class="sectlevel1">
<li><a href="#Recipes-Basic">1. Basic</a>
<ul class="sectlevel2">
<li><a href="#Basic-Hello">1.1. Hello</a></li>
<li><a href="#Basic-Factorial">1.2. Factorial</a></li>
<li><a href="#Basic-Squares">1.3. Squares</a></li>
<li><a href="#Basic-BottlesOfBeer">1.4. Bottles Of Beer</a></li>
<li><a href="#Basic-Bubble">1.5. Bubble</a></li>
<li><a href="#Basic-Even">1.6. Even</a></li>
<li><a href="#Basic-FizzBuzz">1.7. FizzBuzz</a></li>
<li><a href="#Basic-Quine">1.8. Quine</a></li>
</ul>
</li>
<li><a href="#Recipes-Common">2. Common</a>
<ul class="sectlevel2">
<li><a href="#Common-AdHocDataExploration">2.1. Ad Hoc Data Exploration</a></li>
<li><a href="#Common-CallAnalysis">2.2. Call Analysis</a></li>
<li><a href="#Common-CallLifting">2.3. Call Lifting</a></li>
<li><a href="#Common-ColoredTrees">2.4. Colored Trees</a></li>
<li><a href="#Common-CountConstructors">2.5. Count Constructors</a></li>
<li><a href="#Common-Derivative">2.6. Derivative</a></li>
<li><a href="#Common-StringTemplate">2.7. String Template</a></li>
<li><a href="#Common-WordCount">2.8. Word Count</a></li>
<li><a href="#Common-WordReplacement">2.9. Word Replacement</a></li>
</ul>
</li>
<li><a href="#Recipes-Languages">3. Languages</a>
<ul class="sectlevel2">
<li><a href="#Languages-Exp">3.1. Exp</a></li>
<li><a href="#Languages-Func">3.2. Func</a></li>
<li><a href="#Languages-Lisra">3.3. Lisra</a></li>
<li><a href="#Languages-Pico">3.4. Pico</a></li>
</ul>
</li>
<li><a href="#Recipes-Metrics">4. Metrics</a>
<ul class="sectlevel2">
<li><a href="#Metrics-MeasuringJava">4.1. Measuring Java</a></li>
</ul>
</li>
<li><a href="#Recipes-Visualization">5. Visualization</a>
<ul class="sectlevel2">
<li><a href="#Visualization-ADT">5.1. ADT</a></li>
<li><a href="#Visualization-DrawLogo">5.2. Draw a Logo</a></li>
<li><a href="#Visualization-InteractiveBoxHeight">5.3. Interactive Box Height</a></li>
<li><a href="#Visualization-MyFirstBox">5.4. My First Box</a></li>
<li><a href="#Visualization-ParseTree">5.5. ParseTree</a></li>
<li><a href="#Visualization-PlayingWithProperties">5.6. Playing With Properties</a></li>
</ul>
</li>
</ul>
</div>
</div>
<div id="content">
<div id="preamble">
<div class="sectionbody">
<div class="paragraph">
<div class="title">Synopsis</div>
<p>Recipes for writing Rascal programs.</p>
</div>
<div class="paragraph">
<div class="title">Description</div>
<p>These <em>Rascal Recipes</em> are a work-in-progress but will gradually evolve into a collection of basic Rascal language examples and use cases.
It consists of the following parts:</p>
</div>
<div class="paragraph">
<p>The following features are covered:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Basic language features.</p>
</li>
<li>
<p>Common tasks.</p>
</li>
<li>
<p>Fact extraction.</p>
</li>
<li>
<p>Language definition.</p>
</li>
<li>
<p>Syntax definition.</p>
</li>
<li>
<p>Parsing.</p>
</li>
<li>
<p>Transformation.</p>
</li>
<li>
<p>Code generation.</p>
</li>
<li>
<p>IDE extensions.</p>
</li>
<li>
<p>Visualization.</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect1">
<h2 id="Recipes-Basic">1. Basic</h2>
<div class="sectionbody">
<div class="paragraph">
<div class="title">Synopsis</div>
<p>Some basic, <em>hello world</em>-like, examples of Rascal programs.</p>
</div>
<div class="paragraph">
<div class="title">Description</div>
<p>We discuss the following examples:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="#Basic-Hello">Hello</a>: Variations on the ubiquitous <em>Hello World</em> example.</p>
</li>
<li>
<p><a href="#Basic-Factorial">Factorial</a>: Compute the factorial function.</p>
</li>
<li>
<p><a href="#Basic-Squares">Squares</a>: Print a list of squares.</p>
</li>
<li>
<p><a href="#Basic-BottlesOfBeer">Bottles Of Beer</a>: A Rascal version of a generator for the <em>99 Bottles of Beer</em> song.</p>
</li>
<li>
<p><a href="#Basic-Bubble">Bubble</a>: Variout styles to write bubble sort.</p>
</li>
<li>
<p><a href="#Basic-Even">Even</a>: Produce a list of even numbers.</p>
</li>
<li>
<p><a href="#Basic-FizzBuzz">FizzBuzz</a>: We solve a well-known job interview puzzle.</p>
</li>
<li>
<p><a href="#Basic-Quine">Quine</a>: A self-reproducing program.</p>
</li>
</ul>
</div>
<div class="paragraph">
<div class="title">Pitfalls</div>
<p>These programs illustrate various features of Rascal; they are <strong>not representative</strong> as use cases of the language.</p>
</div>
<div class="sect2">
<h3 id="Basic-Hello">1.1. Hello</h3>
<div class="paragraph">
<div class="title">Synopsis</div>
<p>Variations on the ubiquitous <em>Hello World</em> example.</p>
</div>
<div class="sect3">
<h4 id="__code_hello_code_on_command_line">1.1.1. <code>hello</code> on command line</h4>
<div class="paragraph">
<div class="title">Examples</div>
<p>We demonstrate hello via an interactive session with the Rascal system. First we get the prompt <code>rascal&gt;</code> that shows that Rascal is ready for our input.
Next, we import the library module <a href="../Libraries/Libraries.html#Prelude-IO">IO</a> since hello world requires printing. Rascal responds with the feedback <code>ok</code> so we know that all went well. Finally, we call <code>println</code> and proudly observe our first Rascal output!</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-rascal-shell" data-lang="rascal-shell">rascal&gt;import IO;
ok
rascal&gt;println("Hello world, this is my first Rascal program");
Hello world, this is my first Rascal program
ok</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="__code_hello_code_as_function">1.1.2. <code>hello</code> as function</h4>
<div class="paragraph">
<p>A slightly more audacious approach is to wrap the print statement in a function and call it:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-rascal-shell" data-lang="rascal-shell">rascal&gt;import IO;
ok
rascal&gt;void hello() {
&gt;&gt;&gt;&gt;&gt;&gt;&gt;   println("Hello world, this is my first Rascal program");
&gt;&gt;&gt;&gt;&gt;&gt;&gt;}
ok</code></pre>
</div>
</div>
<div class="paragraph">
<p>When you type in a command and continue it on a new line
the Rascal systems prompts you with <code>&gt;&gt;&gt;&gt;&gt;&gt;&gt;</code> to
indicate that more input is needed. Don&#8217;t get scared by
the <code>void (): void hello();</code> that you get back
when typing in the hello function. The first
<code>void ()</code> part says the result is a function that
returns nothing, and the second part
<code>void hello()</code> summarizes its value
(or would you prefer a hex dump?).
Finally, we call the <code>hello</code> function and enjoy its output.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-rascal-shell" data-lang="rascal-shell">rascal&gt;hello();
Hello world, this is my first Rascal program
ok</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="__code_hello_code_as_module">1.1.3. <code>hello</code> as module</h4>
<div class="paragraph">
<p>The summit of hello-engineering can be reached by placing all the above in a separate module:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-rascal" data-lang="rascal">module demo::basic::Hello

import IO;

void hello() {
   println("Hello world, this is my first Rascal program");
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Using this Hello module is now simple:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-rascal-shell" data-lang="rascal-shell">rascal&gt;import demo::basic::Hello;
rascal2rvm: Parsing and checking |std:///demo/basic/Hello.rsc|
rascal2rvm: Compiling |std:///demo/basic/Hello.rsc|
r2mu: entering ... demo::basic::Hello
mu2rvm: Compiling module demo::basic::Hello
Compiling |std:///demo/basic/Hello.rsc|: check: 6, compile: 19, total: 25 ms
compile: Writing RVMModule |compressed+home:///bin-console/demo/basic/Hello.rvm.gz|
Removing |compressed+home:///bin-console/ConsoleInput_imports.rvm.gz|
ok
rascal&gt;hello();
Hello world, this is my first Rascal program
ok</code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>hello</code> function is by default visible outside the <code>Hello</code> module.
We could stress this by adding writing <code>public void hello() { &#8230;&#8203; }</code>.
Restricting visibility to the module itself can be achieved by adding the keyword <code>private</code>
to the definition of <code>hello</code>.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="Basic-Factorial">1.2. Factorial</h3>
<div class="paragraph">
<div class="title">Synopsis</div>
<p>Compute the factorial function.</p>
</div>
<div class="paragraph">
<div class="title">Examples</div>
<p>The <a href="http://en.wikipedia.org/wiki/Factorial">factorial</a>
of a number N is defined as <code>N * (N-1) * (N-2) * &#8230;&#8203; * 1</code>.
Here is the Rascal version:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-rascal" data-lang="rascal">module demo::basic::Factorial

int fac(int N) = N &lt;= 0 ? 1 : N * fac(N - 1); <i class="conum" data-value="1"></i><b>(1)</b>

int fac2(0) = 1;  <i class="conum" data-value="2"></i><b>(2)</b>
default int fac2(int N) = N * fac2(N - 1); <i class="conum" data-value="3"></i><b>(3)</b>

int fac3(int N)  { <i class="conum" data-value="4"></i><b>(4)</b>
  if (N == 0)
     return 1;
  return N * fac3(N - 1);
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td><code>fac</code> is defined using a conditional expression to distinguish cases.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td><code>fac2</code> distinguishes cases using pattern-based dispatch (<a href="../Rascal/Rascal.html#Concepts-Function">Rascal Functions</a>).
Here the case for <code>0</code> is defined.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>Here all other cases for <code>fac2</code> are defined (as indicated by the <code>default</code> keyword).</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td><code>fac3</code> shows a more imperative implementation of factorial.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Here is how to use <code>fac</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-rascal-shell" data-lang="rascal-shell">rascal&gt;import demo::basic::Factorial;
ok
rascal&gt;fac(47);
int: 258623241511168180642964355153611979969197632389120000000000</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Indeed, Rascal supports arbitrary length numbers.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Here is an example of <code>fac2</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-rascal-shell" data-lang="rascal-shell">rascal&gt;fac2(47);
int: 258623241511168180642964355153611979969197632389120000000000</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="Basic-Squares">1.3. Squares</h3>
<div class="paragraph">
<div class="title">Synopsis</div>
<p>Print a list of squares</p>
</div>
<div class="paragraph">
<div class="title">Examples</div>
<p>How can we print a list of squares? Here is a solution:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-rascal" data-lang="rascal">module demo::basic::Squares

import IO; <i class="conum" data-value="1"></i><b>(1)</b>

// Print a table of squares

void squares(int N){
  println("Table of squares from 1 to &lt;N&gt;\n"); <i class="conum" data-value="2"></i><b>(2)</b>
  for(int I &lt;- [1 .. N + 1])
      println("&lt;I&gt; squared = &lt;I * I&gt;");        <i class="conum" data-value="3"></i><b>(3)</b>
}

// a solution with a multi line string template:

str squaresTemplate(int N) <i class="conum" data-value="4"></i><b>(4)</b>
  = "Table of squares from 1 to &lt;N&gt;
    '&lt;for (int I &lt;- [1 .. N + 1]) {&gt;
    '  &lt;I&gt; squared = &lt;I * I&gt;&lt;}&gt;";</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>The <a href="../Libraries/Libraries.html#Prelude-IO">IO</a> module is imported since we want to print things using <code>println</code>.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td><a href="../Rascal/Rascal.html#Values-String">String</a> interpolation is used several times.
Here the value of <code>N</code> is inserted in the header message.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>The values of <code>I</code> and <code>I * I</code> are inserted in each line that is printed.</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>Define an alternative implementation <code>squareTemplate</code> that is based on string templates
and returns a string value instead of printing the results itself.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Here is how <code>square</code> can be used:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-rascal-shell" data-lang="rascal-shell">rascal&gt;import demo::basic::Squares;
rascal2rvm: Parsing and checking |std:///demo/basic/Squares.rsc|
rascal2rvm: Compiling |std:///demo/basic/Squares.rsc|
r2mu: entering ... demo::basic::Squares
mu2rvm: Compiling module demo::basic::Squares
Compiling |std:///demo/basic/Squares.rsc|: check: 7, compile: 169, total: 176 ms
compile: Writing RVMModule |compressed+home:///bin-console/demo/basic/Squares.rvm.gz|
Removing |compressed+home:///bin-console/ConsoleInput_imports.rvm.gz|
ok
rascal&gt;squares(9);
Table of squares from 1 to 9

1 squared = 1
2 squared = 4
3 squared = 9
4 squared = 16
5 squared = 25
6 squared = 36
7 squared = 49
8 squared = 64
9 squared = 81
list[void]: []</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>squaresTemplate</code> gives a similar result but now as a string:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-rascal-shell" data-lang="rascal-shell">rascal&gt;squaresTemplate(9);
str: "Table of squares from 1 to 9\n\n  1 squared = 1\n  2 squared = 4\n  3 squared = 9\n  4 squared = 16\n  5 squared = 25\n  6 squared = 36\n  7 squared = 49\n  8 squared = 64\n  9 squared = 81"</code></pre>
</div>
</div>
<div class="paragraph">
<p>To get a truly identical result we have to import the <a href="../Libraries/Libraries.html#Prelude-IO">IO</a> module
and print the value of <code>squaresTemplate</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-rascal-shell" data-lang="rascal-shell">rascal&gt;import IO;
ok
rascal&gt;println(squaresTemplate(9));
Table of squares from 1 to 9

  1 squared = 1
  2 squared = 4
  3 squared = 9
  4 squared = 16
  5 squared = 25
  6 squared = 36
  7 squared = 49
  8 squared = 64
  9 squared = 81
ok</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="Basic-BottlesOfBeer">1.4. Bottles Of Beer</h3>
<div class="paragraph">
<div class="title">Synopsis</div>
<p>A Rascal version of a generator for the <em>99 Bottles of Beer</em> song.</p>
</div>
<div class="paragraph">
<div class="title">Description</div>
<p>Programs that generate the lyrics for the song <em>99 Bottles of Beer</em> are a popular way to compare programming languages.
At <a href="http://99-bottles-of-beer.net/">99-bottles-of-beer.net</a> you can find versions in nearly 1500 different languages
and the lyrics can be found <a href="http://99-bottles-of-beer.net/lyrics.html">here</a>.</p>
</div>
<div class="paragraph">
<div class="title">Examples</div>
<p>Here is our version:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-rascal" data-lang="rascal">module demo::basic::Bottles

import IO;

str bottles(0)     = "no more bottles"; <i class="conum" data-value="1"></i><b>(1)</b>
str bottles(1)     = "1 bottle";
default str bottles(int n) = "&lt;n&gt; bottles"; <i class="conum" data-value="2"></i><b>(2)</b>

void sing(){ <i class="conum" data-value="3"></i><b>(3)</b>
  for(n &lt;- [99 .. 0]){
       println("&lt;bottles(n)&gt; of beer on the wall, &lt;bottles(n)&gt; of beer.");
       println("Take one down, pass it around, &lt;bottles(n-1)&gt; of beer on the wall.\n");
  }
  println("No more bottles of beer on the wall, no more bottles of beer.");
  println("Go to the store and buy some more, 99 bottles of beer on the wall.");
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>We use an auxiliary function <code>bottles</code> that returns the word "bottle" adjusted for the actual number of bottles that is available.
Observe how we use the patterns <code>0</code>, <code>1</code> and <code>int n</code> in the definition of three variants of this function.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td><em>Pattern-directed invocation</em> (see <a href="../Rascal/Rascal.html#Declarations-Function">function declaration</a>) will determine at the call site which function will be called. The
general case is labeled with <code>default</code> to indicate that if the case for 0 and 1 do not match, this alternative should handle the other cases.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>The main function is <code>sing</code> that iterates over the numbers 99 downto 1 (as described by the range <code>[99 .. 1]</code>)
and prints appriopriate lyrics. Observe how the value  of the <code>bottles</code> function is interpolated several times in the string.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Here is the result:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-rascal-shell" data-lang="rascal-shell">rascal&gt;import demo::basic::Bottles;
rascal2rvm: Parsing and checking |std:///demo/basic/Bottles.rsc|
rascal2rvm: Compiling |std:///demo/basic/Bottles.rsc|
r2mu: entering ... demo::basic::Bottles
mu2rvm: Compiling module demo::basic::Bottles
Compiling |std:///demo/basic/Bottles.rsc|: check: 7, compile: 51, total: 58 ms
compile: Writing RVMModule |compressed+home:///bin-console/demo/basic/Bottles.rvm.gz|
Removing |compressed+home:///bin-console/ConsoleInput_imports.rvm.gz|
ok
rascal&gt;sing();
99 bottles of beer on the wall, 99 bottles of beer.
Take one down, pass it around, 98 bottles of beer on the wall.

98 bottles of beer on the wall, 98 bottles of beer.
Take one down, pass it around, 97 bottles of beer on the wall.

97 bottles of beer on the wall, 97 bottles of beer.
Take one down, pass it around, 96 bottles of beer on the wall.

96 bottles of beer on the wall, 96 bottles of beer.
Take one down, pass it around, 95 bottles of beer on the wall.

95 bottles of beer on the wall, 95 bottles of beer.
Take one down, pass it around, 94 bottles of beer on the wall.

94 bottles of beer on the wall, 94 bottles of beer.
Take one down, pass it around, 93 bottles of beer on the wall.

93 bottles of beer on the wall, 93 bottles of beer.
Take one down, pass it around, 92 bottles of beer on the wall.

92 bottles of beer on the wall, 92 bottles of beer.
Take one down, pass it around, 91 bottles of beer on the wall.

91 bottles of beer on the wall, 91 bottles of beer.
Take one down, pass it around, 90 bottles of beer on the wall.

90 bottles of beer on the wall, 90 bottles of beer.
Take one down, pass it around, 89 bottles of beer on the wall.

89 bottles of beer on the wall, 89 bottles of beer.
Take one down, pass it around, 88 bottles of beer on the wall.

88 bottles of beer on the wall, 88 bottles of beer.
Take one down, pass it around, 87 bottles of beer on the wall.

87 bottles of beer on the wall, 87 bottles of beer.
Take one down, pass it around, 86 bottles of beer on the wall.

86 bottles of beer on the wall, 86 bottles of beer.
Take one down, pass it around, 85 bottles of beer on the wall.

85 bottles of beer on the wall, 85 bottles of beer.
Take one down, pass it around, 84 bottles of beer on the wall.

84 bottles of beer on the wall, 84 bottles of beer.
Take one down, pass it around, 83 bottles of beer on the wall.

83 bottles of beer on the wall, 83 bottles of beer.
Take one down, pass it around, 82 bottles of beer on the wall.

82 bottles of beer on the wall, 82 bottles of beer.
Take one down, pass it around, 81 bottles of beer on the wall.

81 bottles of beer on the wall, 81 bottles of beer.
Take one down, pass it around, 80 bottles of beer on the wall.

80 bottles of beer on the wall, 80 bottles of beer.
Take one down, pass it around, 79 bottles of beer on the wall.

79 bottles of beer on the wall, 79 bottles of beer.
Take one down, pass it around, 78 bottles of beer on the wall.

78 bottles of beer on the wall, 78 bottles of beer.
Take one down, pass it around, 77 bottles of beer on the wall.

77 bottles of beer on the wall, 77 bottles of beer.
Take one down, pass it around, 76 bottles of beer on the wall.

76 bottles of beer on the wall, 76 bottles of beer.
Take one down, pass it around, 75 bottles of beer on the wall.

75 bottles of beer on the wall, 75 bottles of beer.
Take one down, pass it around, 74 bottles of beer on the wall.

74 bottles of beer on the wall, 74 bottles of beer.
Take one down, pass it around, 73 bottles of beer on the wall.

73 bottles of beer on the wall, 73 bottles of beer.
Take one down, pass it around, 72 bottles of beer on the wall.

72 bottles of beer on the wall, 72 bottles of beer.
Take one down, pass it around, 71 bottles of beer on the wall.

71 bottles of beer on the wall, 71 bottles of beer.
Take one down, pass it around, 70 bottles of beer on the wall.

70 bottles of beer on the wall, 70 bottles of beer.
Take one down, pass it around, 69 bottles of beer on the wall.

69 bottles of beer on the wall, 69 bottles of beer.
Take one down, pass it around, 68 bottles of beer on the wall.

68 bottles of beer on the wall, 68 bottles of beer.
Take one down, pass it around, 67 bottles of beer on the wall.

67 bottles of beer on the wall, 67 bottles of beer.
Take one down, pass it around, 66 bottles of beer on the wall.

66 bottles of beer on the wall, 66 bottles of beer.
Take one down, pass it around, 65 bottles of beer on the wall.

65 bottles of beer on the wall, 65 bottles of beer.
Take one down, pass it around, 64 bottles of beer on the wall.

64 bottles of beer on the wall, 64 bottles of beer.
Take one down, pass it around, 63 bottles of beer on the wall.

63 bottles of beer on the wall, 63 bottles of beer.
Take one down, pass it around, 62 bottles of beer on the wall.

62 bottles of beer on the wall, 62 bottles of beer.
Take one down, pass it around, 61 bottles of beer on the wall.

61 bottles of beer on the wall, 61 bottles of beer.
Take one down, pass it around, 60 bottles of beer on the wall.

60 bottles of beer on the wall, 60 bottles of beer.
Take one down, pass it around, 59 bottles of beer on the wall.

59 bottles of beer on the wall, 59 bottles of beer.
Take one down, pass it around, 58 bottles of beer on the wall.

58 bottles of beer on the wall, 58 bottles of beer.
Take one down, pass it around, 57 bottles of beer on the wall.

57 bottles of beer on the wall, 57 bottles of beer.
Take one down, pass it around, 56 bottles of beer on the wall.

56 bottles of beer on the wall, 56 bottles of beer.
Take one down, pass it around, 55 bottles of beer on the wall.

55 bottles of beer on the wall, 55 bottles of beer.
Take one down, pass it around, 54 bottles of beer on the wall.

54 bottles of beer on the wall, 54 bottles of beer.
Take one down, pass it around, 53 bottles of beer on the wall.

53 bottles of beer on the wall, 53 bottles of beer.
Take one down, pass it around, 52 bottles of beer on the wall.

52 bottles of beer on the wall, 52 bottles of beer.
Take one down, pass it around, 51 bottles of beer on the wall.

51 bottles of beer on the wall, 51 bottles of beer.
Take one down, pass it around, 50 bottles of beer on the wall.

50 bottles of beer on the wall, 50 bottles of beer.
Take one down, pass it around, 49 bottles of beer on the wall.

49 bottles of beer on the wall, 49 bottles of beer.
Take one down, pass it around, 48 bottles of beer on the wall.

48 bottles of beer on the wall, 48 bottles of beer.
Take one down, pass it around, 47 bottles of beer on the wall.

47 bottles of beer on the wall, 47 bottles of beer.
Take one down, pass it around, 46 bottles of beer on the wall.

46 bottles of beer on the wall, 46 bottles of beer.
Take one down, pass it around, 45 bottles of beer on the wall.

45 bottles of beer on the wall, 45 bottles of beer.
Take one down, pass it around, 44 bottles of beer on the wall.

44 bottles of beer on the wall, 44 bottles of beer.
Take one down, pass it around, 43 bottles of beer on the wall.

43 bottles of beer on the wall, 43 bottles of beer.
Take one down, pass it around, 42 bottles of beer on the wall.

42 bottles of beer on the wall, 42 bottles of beer.
Take one down, pass it around, 41 bottles of beer on the wall.

41 bottles of beer on the wall, 41 bottles of beer.
Take one down, pass it around, 40 bottles of beer on the wall.

40 bottles of beer on the wall, 40 bottles of beer.
Take one down, pass it around, 39 bottles of beer on the wall.

39 bottles of beer on the wall, 39 bottles of beer.
Take one down, pass it around, 38 bottles of beer on the wall.

38 bottles of beer on the wall, 38 bottles of beer.
Take one down, pass it around, 37 bottles of beer on the wall.

37 bottles of beer on the wall, 37 bottles of beer.
Take one down, pass it around, 36 bottles of beer on the wall.

36 bottles of beer on the wall, 36 bottles of beer.
Take one down, pass it around, 35 bottles of beer on the wall.

35 bottles of beer on the wall, 35 bottles of beer.
Take one down, pass it around, 34 bottles of beer on the wall.

34 bottles of beer on the wall, 34 bottles of beer.
Take one down, pass it around, 33 bottles of beer on the wall.

33 bottles of beer on the wall, 33 bottles of beer.
Take one down, pass it around, 32 bottles of beer on the wall.

32 bottles of beer on the wall, 32 bottles of beer.
Take one down, pass it around, 31 bottles of beer on the wall.

31 bottles of beer on the wall, 31 bottles of beer.
Take one down, pass it around, 30 bottles of beer on the wall.

30 bottles of beer on the wall, 30 bottles of beer.
Take one down, pass it around, 29 bottles of beer on the wall.

29 bottles of beer on the wall, 29 bottles of beer.
Take one down, pass it around, 28 bottles of beer on the wall.

28 bottles of beer on the wall, 28 bottles of beer.
Take one down, pass it around, 27 bottles of beer on the wall.

27 bottles of beer on the wall, 27 bottles of beer.
Take one down, pass it around, 26 bottles of beer on the wall.

26 bottles of beer on the wall, 26 bottles of beer.
Take one down, pass it around, 25 bottles of beer on the wall.

25 bottles of beer on the wall, 25 bottles of beer.
Take one down, pass it around, 24 bottles of beer on the wall.

24 bottles of beer on the wall, 24 bottles of beer.
Take one down, pass it around, 23 bottles of beer on the wall.

23 bottles of beer on the wall, 23 bottles of beer.
Take one down, pass it around, 22 bottles of beer on the wall.

22 bottles of beer on the wall, 22 bottles of beer.
Take one down, pass it around, 21 bottles of beer on the wall.

21 bottles of beer on the wall, 21 bottles of beer.
Take one down, pass it around, 20 bottles of beer on the wall.

20 bottles of beer on the wall, 20 bottles of beer.
Take one down, pass it around, 19 bottles of beer on the wall.

19 bottles of beer on the wall, 19 bottles of beer.
Take one down, pass it around, 18 bottles of beer on the wall.

18 bottles of beer on the wall, 18 bottles of beer.
Take one down, pass it around, 17 bottles of beer on the wall.

17 bottles of beer on the wall, 17 bottles of beer.
Take one down, pass it around, 16 bottles of beer on the wall.

16 bottles of beer on the wall, 16 bottles of beer.
Take one down, pass it around, 15 bottles of beer on the wall.

15 bottles of beer on the wall, 15 bottles of beer.
Take one down, pass it around, 14 bottles of beer on the wall.

14 bottles of beer on the wall, 14 bottles of beer.
Take one down, pass it around, 13 bottles of beer on the wall.

13 bottles of beer on the wall, 13 bottles of beer.
Take one down, pass it around, 12 bottles of beer on the wall.

12 bottles of beer on the wall, 12 bottles of beer.
Take one down, pass it around, 11 bottles of beer on the wall.

11 bottles of beer on the wall, 11 bottles of beer.
Take one down, pass it around, 10 bottles of beer on the wall.

10 bottles of beer on the wall, 10 bottles of beer.
Take one down, pass it around, 9 bottles of beer on the wall.

9 bottles of beer on the wall, 9 bottles of beer.
Take one down, pass it around, 8 bottles of beer on the wall.

8 bottles of beer on the wall, 8 bottles of beer.
Take one down, pass it around, 7 bottles of beer on the wall.

7 bottles of beer on the wall, 7 bottles of beer.
Take one down, pass it around, 6 bottles of beer on the wall.

6 bottles of beer on the wall, 6 bottles of beer.
Take one down, pass it around, 5 bottles of beer on the wall.

5 bottles of beer on the wall, 5 bottles of beer.
Take one down, pass it around, 4 bottles of beer on the wall.

4 bottles of beer on the wall, 4 bottles of beer.
Take one down, pass it around, 3 bottles of beer on the wall.

3 bottles of beer on the wall, 3 bottles of beer.
Take one down, pass it around, 2 bottles of beer on the wall.

2 bottles of beer on the wall, 2 bottles of beer.
Take one down, pass it around, 1 bottle of beer on the wall.

1 bottle of beer on the wall, 1 bottle of beer.
Take one down, pass it around, no more bottles of beer on the wall.

No more bottles of beer on the wall, no more bottles of beer.
Go to the store and buy some more, 99 bottles of beer on the wall.
ok</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="Basic-Bubble">1.5. Bubble</h3>
<div class="paragraph">
<div class="title">Synopsis</div>
<p>Variout styles to write bubble sort.</p>
</div>
<div class="paragraph">
<div class="title">Description</div>
<p><a href="http://en.wikipedia.org/wiki/Bubble_sort">Bubble sort</a> is a classical (albeit not the most efficient) technique to sort lists of values.
We present here several styles to implement bubble sort.
Also see <a href="../Libraries/Libraries.html#List-sort">sort</a> for a more efficient library function for sorting.</p>
</div>
<div class="listingblock">
<div class="title">Examples</div>
<div class="content">
<pre class="highlight"><code class="language-rascal" data-lang="rascal">module demo::basic::Bubble

import List;
import IO;

// Variations on Bubble sort

// sort1: uses list indexing and a for-loop

list[int] sort1(list[int] numbers){
  if(size(numbers) &gt; 0){
     for(int i &lt;- [0 .. size(numbers)-1]){
       if(numbers[i] &gt; numbers[i+1]){
         &lt;numbers[i], numbers[i+1]&gt; = &lt;numbers[i+1], numbers[i]&gt;;
         return sort1(numbers);
       }
    }
  }
  return numbers;
}

// sort2: uses list matching and switch

list[int] sort2(list[int] numbers){
  switch(numbers){
    case [*int nums1, int p, int q, *int nums2]:
       if(p &gt; q){
          return sort2(nums1 + [q, p] + nums2);
       } else {
       	  fail;
       }
     default: return numbers;
   }
}

// sort3: uses list matching and while

list[int] sort3(list[int] numbers){
  while([*int nums1, int p, *int nums2, int q, *int nums3] := numbers &amp;&amp; p &gt; q)
        numbers = nums1 + [q] + nums2 + [p] + nums3;
  return numbers;
}

// sort4: using recursion instead of iteration, and splicing instead of concat
list[int] sort4([*int nums1, int p, *int nums2, int q, *int nums3]) {
  if (p &gt; q)
    return sort4([*nums1, q, *nums2, p, *nums3]);
  else
    fail sort4;
}

default list[int] sort4(list[int] x) = x;

// sort5: inlines the condition into a when:
list[int] sort5([*int nums1, int p, *int nums2, int q, *int nums3])
  = sort5([*nums1, q, *nums2, p, *nums3])
  when p &gt; q;

default list[int] sort5(list[int] x) = x;</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>sort1</code> is a classic, imperative style, implementation of bubble sort: it iterates over consecutive pairs of elements and
when a not-yet-sorted pair is encountered, the elements are exchanged, and <code>sort1</code> is applied recursively to the whole list.</p>
</div>
<div class="paragraph">
<p><code>sort2</code> uses list matching and consists of a switch with two cases:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>a case matching a list with two consecutive elements that are unsorted. Observe that when the pattern of a case matches,
the case as a whole can still fail.</p>
</li>
<li>
<p>a default case.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><code>sort3</code> also uses list matching but in a more declarative style: as long as there are unsorted elements in the list (possibly with intervening elements), exchange them.</p>
</div>
<div class="paragraph">
<p><code>sort4</code> is identical to <code>sort3</code>, except that the shorter <code>*</code>-notation for list variables is used and that the type declaration for the
the non-list variables has been omitted.</p>
</div>
<div class="paragraph">
<p><code>sort5</code> uses tail recursion to reach a fixed point instead of a while loop. One alternative matches lists with out-of-order elements, while the default alternative returns the list if no out-of-order elements are found.</p>
</div>
<div class="paragraph">
<p>Let&#8217;s put them to the test:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-rascal-shell" data-lang="rascal-shell">rascal&gt;import demo::basic::Bubble;
rascal2rvm: Parsing and checking |std:///demo/basic/Bubble.rsc|
rascal2rvm: Compiling |std:///demo/basic/Bubble.rsc|
r2mu: entering ... demo::basic::Bubble
mu2rvm: Compiling module demo::basic::Bubble
Compiling |std:///demo/basic/Bubble.rsc|: check: 20, compile: 825, total: 845 ms
compile: Writing RVMModule |compressed+home:///bin-console/demo/basic/Bubble.rvm.gz|
Removing |compressed+home:///bin-console/ConsoleInput_imports.rvm.gz|
ok
rascal&gt;L = [9,8,7,6,5,4,3,2,1];
list[int]: [9,8,7,6,5,4,3,2,1]
rascal&gt;sort1(L);
list[int]: [1,2,3,4,5,6,7,8,9]
rascal&gt;sort2(L);
list[int]: [1,2,3,4,5,6,7,8,9]
rascal&gt;sort3(L);
list[int]: [1,2,3,4,5,6,7,8,9]
rascal&gt;sort4(L);
list[int]: [1,2,3,4,5,6,7,8,9]
rascal&gt;sort5(L);
list[int]: [1,2,3,4,5,6,7,8,9]</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="Basic-Even">1.6. Even</h3>
<div class="paragraph">
<div class="title">Synopsis</div>
<p>Produce a list of even numbers.</p>
</div>
<div class="paragraph">
<div class="title">Description</div>
<p>Let&#8217;s write a function that generates all the even numbers in a list up to a certain maximum. We will do it in a few alternative
ways: from very imperative to very declarative and some steps in between.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-rascal-shell" data-lang="rascal-shell">rascal&gt;list[int] even0(int max) {
&gt;&gt;&gt;&gt;&gt;&gt;&gt;  list[int] result = [];
&gt;&gt;&gt;&gt;&gt;&gt;&gt;  for (int i &lt;- [0..max])
&gt;&gt;&gt;&gt;&gt;&gt;&gt;    if (i % 2 == 0)
&gt;&gt;&gt;&gt;&gt;&gt;&gt;      result += i;
&gt;&gt;&gt;&gt;&gt;&gt;&gt;  return result;
&gt;&gt;&gt;&gt;&gt;&gt;&gt;}
ok
rascal&gt;even0(25);
list[int]: [0,2,4,6,8,10,12,14,16,18,20,22,24]</code></pre>
</div>
</div>
<div class="paragraph">
<p>Now lets remove the temporary type declarations:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-rascal-shell" data-lang="rascal-shell">rascal&gt;list[int] even1(int max) {
&gt;&gt;&gt;&gt;&gt;&gt;&gt;  result = [];
&gt;&gt;&gt;&gt;&gt;&gt;&gt;  for (i &lt;- [0..max])
&gt;&gt;&gt;&gt;&gt;&gt;&gt;    if (i % 2 == 0)
&gt;&gt;&gt;&gt;&gt;&gt;&gt;      result += i;
&gt;&gt;&gt;&gt;&gt;&gt;&gt;  return result;
&gt;&gt;&gt;&gt;&gt;&gt;&gt;}
ok
rascal&gt;even1(25);
list[int]: [0,2,4,6,8,10,12,14,16,18,20,22,24]</code></pre>
</div>
</div>
<div class="paragraph">
<p>To make the code shorter, we can inline the condition in the for loop:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-rascal-shell" data-lang="rascal-shell">rascal&gt;list[int] even2(int max) {
&gt;&gt;&gt;&gt;&gt;&gt;&gt;  result = [];
&gt;&gt;&gt;&gt;&gt;&gt;&gt;  for (i &lt;- [0..max], i % 2 == 0)
&gt;&gt;&gt;&gt;&gt;&gt;&gt;    result += i;
&gt;&gt;&gt;&gt;&gt;&gt;&gt;  return result;
&gt;&gt;&gt;&gt;&gt;&gt;&gt;}
ok
rascal&gt;even2(25);
list[int]: [0,2,4,6,8,10,12,14,16,18,20,22,24]</code></pre>
</div>
</div>
<div class="paragraph">
<p>In fact, for loops may produce lists as values, using the append statement:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-rascal-shell" data-lang="rascal-shell">rascal&gt;list[int] even3(int max) {
&gt;&gt;&gt;&gt;&gt;&gt;&gt;  result = for (i &lt;- [0..max], i % 2 == 0)
&gt;&gt;&gt;&gt;&gt;&gt;&gt;    append i;
&gt;&gt;&gt;&gt;&gt;&gt;&gt;  return result;
&gt;&gt;&gt;&gt;&gt;&gt;&gt;}
ok
rascal&gt;even3(25);
list[int]: [0,2,4,6,8,10,12,14,16,18,20,22,24]</code></pre>
</div>
</div>
<div class="paragraph">
<p>So now, the result temporary is not necessary anymore:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-rascal-shell" data-lang="rascal-shell">rascal&gt;list[int] even4(int max) {
&gt;&gt;&gt;&gt;&gt;&gt;&gt;  return for (i &lt;- [0..max], i % 2 == 0)
&gt;&gt;&gt;&gt;&gt;&gt;&gt;           append i;
&gt;&gt;&gt;&gt;&gt;&gt;&gt;}
ok
rascal&gt;even4(25);
list[int]: [0,2,4,6,8,10,12,14,16,18,20,22,24]</code></pre>
</div>
</div>
<div class="paragraph">
<p>This code is actually very close to a list comprehension already:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-rascal-shell" data-lang="rascal-shell">rascal&gt;list[int] even5(int max) {
&gt;&gt;&gt;&gt;&gt;&gt;&gt;  return [ i | i &lt;- [0..max], i % 2 == 0];
&gt;&gt;&gt;&gt;&gt;&gt;&gt;}
ok
rascal&gt;even5(25);
list[int]: [0,2,4,6,8,10,12,14,16,18,20,22,24]</code></pre>
</div>
</div>
<div class="paragraph">
<p>And now we can just define <code>even</code> using an expression only:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-rascal-shell" data-lang="rascal-shell">rascal&gt;list[int] even6(int max) = [i | i &lt;- [0..max], i % 2 == 0];
ok
rascal&gt;even6(25);
list[int]: [0,2,4,6,8,10,12,14,16,18,20,22,24]</code></pre>
</div>
</div>
<div class="paragraph">
<p>Or, perhaps we prefer creating a set instead of a list:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-rascal-shell" data-lang="rascal-shell">rascal&gt;set[int] even7(int max) = {i | i &lt;- [0..max], i % 2 == 0};
ok
rascal&gt;even7(25);
set[int]: {10,16,8,14,20,2,4,6,24,12,22,18,0}</code></pre>
</div>
</div>
<div class="ulist">
<div class="title">Benefits</div>
<ul>
<li>
<p>You can program in for loops and use temporary variables if you like.</p>
</li>
<li>
<p>Comprehensions are shorter and more powerful.</p>
</li>
<li>
<p>There are comprehensions for lists, sets, and maps</p>
</li>
</ul>
</div>
<div class="ulist">
<div class="title">Pitfalls</div>
<ul>
<li>
<p>Trainwreck alert: if you start putting too many conditions in a single for loop or comprehension the code may become unreadable.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="Basic-FizzBuzz">1.7. FizzBuzz</h3>
<div class="paragraph">
<div class="title">Synopsis</div>
<p>We solve a well-known job interview puzzle.</p>
</div>
<div class="paragraph">
<div class="title">Description</div>
<p><a href="http://www.codinghorror.com/blog/2007/02/why-cant-programmers-program.html">FizzBuzz</a> is a well-known puzzle that is used at job interviews.
It is defined as follows:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>Write a program that prints the numbers from 1 to 100.
But for multiples of three print "Fizz" instead of the number and for the multiples of five print "Buzz".
For numbers which are multiples of both three and five print "FizzBuzz".</pre>
</div>
</div>
<div class="paragraph">
<p>Surprisingly, many candidates fail to pass this test.
Solutions to FizzBuzz in various languages are available <a href="http://www.geekschool.org/programming/fizzbuzz/">here</a>.</p>
</div>
<div class="paragraph">
<div class="title">Examples</div>
<p>Here are a few possible Rascal solutions:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-rascal" data-lang="rascal">module demo::basic::FizzBuzz

import IO;

void fizzbuzz() {
   for(int n &lt;- [1 .. 101]){
      fb = ((n % 3 == 0) ? "Fizz" : "") + ((n % 5 == 0) ? "Buzz" : "");
      println((fb == "") ?"&lt;n&gt;" : fb);
   }
}

void fizzbuzz2() {
  for (n &lt;- [1..101])
    switch(&lt;n % 3 == 0, n % 5 == 0&gt;) {
      case &lt;true,true&gt;  : println("FizzBuzz");
      case &lt;true,false&gt; : println("Fizz");
      case &lt;false,true&gt; : println("Buzz");
      default: println(n);
    }
}

void fizzbuzz3() {
  for (n &lt;- [1..101]) {
    if (n % 3 == 0) print("Fizz");
    if (n % 5 == 0) print("Buzz");
    else if (n % 3 != 0) print(n);
    println("");
  }
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-rascal-shell" data-lang="rascal-shell">rascal&gt;import demo::basic::FizzBuzz;
rascal2rvm: Parsing and checking |std:///demo/basic/FizzBuzz.rsc|
rascal2rvm: Compiling |std:///demo/basic/FizzBuzz.rsc|
r2mu: entering ... demo::basic::FizzBuzz
mu2rvm: Compiling module demo::basic::FizzBuzz
Compiling |std:///demo/basic/FizzBuzz.rsc|: check: 12, compile: 553, total: 565 ms
compile: Writing RVMModule |compressed+home:///bin-console/demo/basic/FizzBuzz.rvm.gz|
Removing |compressed+home:///bin-console/ConsoleInput_imports.rvm.gz|
ok
rascal&gt;fizzbuzz();
1
2
Fizz
4
Buzz
Fizz
7
8
Fizz
Buzz
11
Fizz
13
14
FizzBuzz
16
17
Fizz
19
Buzz
Fizz
22
23
Fizz
Buzz
26
Fizz
28
29
FizzBuzz
31
32
Fizz
34
Buzz
Fizz
37
38
Fizz
Buzz
41
Fizz
43
44
FizzBuzz
46
47
Fizz
49
Buzz
Fizz
52
53
Fizz
Buzz
56
Fizz
58
59
FizzBuzz
61
62
Fizz
64
Buzz
Fizz
67
68
Fizz
Buzz
71
Fizz
73
74
FizzBuzz
76
77
Fizz
79
Buzz
Fizz
82
83
Fizz
Buzz
86
Fizz
88
89
FizzBuzz
91
92
Fizz
94
Buzz
Fizz
97
98
Fizz
Buzz
list[void]: []</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="Basic-Quine">1.8. Quine</h3>
<div class="paragraph">
<div class="title">Synopsis</div>
<p>A self-reproducing program.</p>
</div>
<div class="paragraph">
<div class="title">Description</div>
<p>A <a href="http://en.wikipedia.org/wiki/Quine_(computing)">quine</a>
is a computer program that takes no input and produces a copy of its own source code.
A quine is also called a <em>self-replicating</em> or <em>self-reproducing</em> program.</p>
</div>
<div class="paragraph">
<p>At the <a href="http://www.nyx.net/~gthompso/quine.htm">Quine Page</a> you can find hundreds of
quines in many different programming languages.</p>
</div>
<div class="paragraph">
<p>Learning about quines, is about learning how to quote and escape symbols in strings.</p>
</div>
<div class="listingblock">
<div class="title">Examples</div>
<div class="content">
<pre class="highlight"><code class="language-rascal" data-lang="rascal">module demo::basic::Quine

import IO;
import String;

void quine(){
  println(program); <i class="conum" data-value="3"></i><b>(3)</b>
  println("\"" + escape(program, ("\"" : "\\\"", "\\" : "\\\\")) + "\";"); <i class="conum" data-value="4"></i><b>(4)</b>
}

str program = <i class="conum" data-value="1"></i><b>(1)</b>
"module demo::basic::Quine

import IO;
import String;

void quine(){
  println(program);
  println(\"\\\"\" + escape(program, (\"\\\"\" : \"\\\\\\\"\", \"\\\\\" : \"\\\\\\\\\")) + \"\\\";\");
}

str program ="; <i class="conum" data-value="2"></i><b>(2)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>A remarkable point in the code: the string variable <code>program</code> has as value
the text of the module <code>Quine</code> upto here.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>The definition of <code>program</code> ends here.
This string has a mesmerizing amount of escapes to which we will come back in a moment.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>The function <code>quine</code> prints the string <code>program</code> twice, here as is and this produces the program upto <span class="icon"><i class="fa fa-callout fa-1"></i></span> above.</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>Here the value of <code>program</code> is printed as a string (surrounded with string quotes) in order to reproduce the string value
of <code>program</code> followed by a semi-colon (<code>;</code>).</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Now here is the catch: we have to be very carefull in handling special characters like quote (<code>"</code>) and backslash (<code>\</code>) in strings.</p>
</div>
<div class="paragraph">
<p>Let&#8217;s do a simple experiment:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-rascal-shell" data-lang="rascal-shell">rascal&gt;import IO;
ok
rascal&gt;str greeting = "\"Good Morning, Dr. Watson\", said Holmes";
str: "\"Good Morning, Dr. Watson\", said Holmes"
rascal&gt;println("\"" + greeting + "\"");
""Good Morning, Dr. Watson", said Holmes"
ok</code></pre>
</div>
</div>
<div class="paragraph">
<p>As you see the quotes inside the string are not escaped and the result is not a legal string.
So what can we do? We escape all dangerous characters in the string before printing it using the [Rascal:escape] function.
It takes a string and a map of characters to be escaped and returns a result in which all escaping has been carried out.
Be aware that in the map, also escaping is needed!
We want to say: escape <code>"</code> and replace it by <code>\"</code>, but since both <code>"</code> and <code>\</code> have to be escaped themselves
we have to say: escape <code>"\""</code> and replace it by <code>"\\\""</code>. The effect is as follows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-rascal-shell" data-lang="rascal-shell">rascal&gt;import String;
ok
rascal&gt;println("\"" + escape(greeting, ("\"": "\\\"")) + "\"");
"\"Good Morning, Dr. Watson\", said Holmes"
ok</code></pre>
</div>
</div>
<div class="paragraph">
<p>And indeed, the two quotes are now properly escaped.</p>
</div>
<div class="paragraph">
<p>This is exactly what happens at <span class="image"><img src="../images//4.png" alt="4"></span> in the definition of <code>quine</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-rascal" data-lang="rascal">println("\"" + escape(program, ("\"" : "\\\"", "\\" : "\\\\")) + "\";");</code></pre>
</div>
</div>
<div class="paragraph">
<p>We escape <code>program</code> and replace <code>"</code> by <code>\"</code>, and <code>\</code> by <code>\\</code>.
The mesmerizing amount of <code>\</code> characters can be explained due to escaping <code>"</code> and <code>\</code>.</p>
</div>
<div class="paragraph">
<p>Now let&#8217;s put <code>quine</code> to the test.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-rascal-shell" data-lang="rascal-shell">rascal&gt;import demo::basic::Quine;
rascal2rvm: Parsing and checking |std:///demo/basic/Quine.rsc|
rascal2rvm: Compiling |std:///demo/basic/Quine.rsc|
r2mu: entering ... demo::basic::Quine
mu2rvm: Compiling module demo::basic::Quine
Compiling |std:///demo/basic/Quine.rsc|: check: 10, compile: 28, total: 38 ms
compile: Writing RVMModule |compressed+home:///bin-console/demo/basic/Quine.rvm.gz|
Removing |compressed+home:///bin-console/ConsoleInput_imports.rvm.gz|
ok
rascal&gt;quine();
module demo::basic::Quine

import IO;
import String;

void quine(){
  println(program);
  println("\"" + escape(program, ("\"" : "\\\"", "\\" : "\\\\")) + "\";");
}

str program =
"module demo::basic::Quine

import IO;
import String;

void quine(){
  println(program);
  println(\"\\\"\" + escape(program, (\"\\\"\" : \"\\\\\\\"\", \"\\\\\" : \"\\\\\\\\\")) + \"\\\";\");
}

str program =";
ok</code></pre>
</div>
</div>
<div class="paragraph">
<p>If you follow this output line-by-line you will see that it
is identical to the original source code of module <code>Quine</code>.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="Recipes-Common">2. Common</h2>
<div class="sectionbody">
<div class="paragraph">
<div class="title">Synopsis</div>
<p>Solutions for some common tasks.</p>
</div>
<div class="paragraph">
<div class="title">Description</div>
<p>We discuss the following tasks:</p>
</div>
<div class="sect2">
<h3 id="Common-AdHocDataExploration">2.1. Ad Hoc Data Exploration</h3>
<div class="paragraph">
<div class="title">Synopsis</div>
<p>Using Rascal to explore an interesting data space.</p>
</div>
<div class="paragraph">
<div class="title">Description</div>
<p>The problem we will look at comes from mathematics, and has a precise analytical solution, but
let&#8217;s use Rascal to explore the state space, and see how it can help us to build intuition.</p>
</div>
<div class="paragraph">
<p>As you know, Rascal supports arbitrarily large numbers cleanly and simply, unlike more traditional
languages like C or Java.  For example, if you want to compute 1000!, then it&#8217;s a simple matter of
calling <code>fact(1000)</code> at the command line.  Let&#8217;s use this definition of factorial:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-rascal" data-lang="rascal">public int fact (int n) {
    if (n &lt;= 1) {
	return 1;
    } else {
	return n * fact (n-1);
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>If you compute <code>fact(1000)</code> at the Rascal command line, you get a large number, on the order of 4.02 x 10<sup>2567</sup>. This is much, much bigger than, say a google, which is a mere 10&lt;<sup>&gt;100</sup>.  (If Rascal runs out stack space, try computing 100!, then 200!, then &#8230;&#8203; then 1000!; the run-time will allocate more stack space incrementally and automatically if you sneak up to where you want to go).</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-rascal" data-lang="rascal">rascal&gt; fact(1000);
int: 402387260077093773543702433923003985719374864210714632543799910429938512398629020592044208486969404800479988610197196058631666872994808558901323829669944590997424504087073759918823627727188732519779505950995276120874975462497043601418278094646496291056393887437886487337119181045825783647849977012476632889835955735432513185323958463075557409114262417474349347553428646576611667797396668820291207379143853719588249808126867838374559731746136085379534524221586593201928090878297308431392844403281231558611036976801357304216168747609675871348312025478589320767169132448426236131412508780208000261683151027341827977704784635868170164365024153691398281264810213092761244896359928705114964975419909342221566832572080821333186116811553615836546984046708975602900950537616475847728421889679646244945160765353408198901385442487984959953319101723355556602139450399736280750137837615307127761926849034352625200015888535147331611702103968175921510907788019393178114194545257223865541461062892187960223838971476088506276862967146674697562911234082439208160153780889893964518263243671616762179168909779911903754031274622289988005195444414282012187361745992642956581746628302955570299024324153181617210465832036786906117260158783520751516284225540265170483304226143974286933061690897968482590125458327168226458066526769958652682272807075781391858178889652208164348344825993266043367660176999612831860788386150279465955131156552036093988180612138558600301435694527224206344631797460594682573103790084024432438465657245014402821885252470935190620929023136493273497565513958720559654228749774011413346962715422845862377387538230483865688976461927383814900140767310446640259899490222221765904339901886018566526485061799702356193897017860040811889729918311021171229845901641921068884387121855646124960798722908519296819372388642614839657382291123125024186649353143970137428531926649875337218940694281434118520158014123344828015051399694290153483077644569099073152433278288269864602789864321139083506217095002597389863554277196742822248757586765752344220207573630569498825087968928162753848863396909959826280956121450994871701244516461260379029309120889086942028510640182154399457156805941872748998094254742173582401063677404595741785160829230135358081840096996372524230560855903700624271243416909004153690105933983835777939410970027753472000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000</code></pre>
</div>
</div>
<div class="paragraph">
<p>Now copy the numerical result above and paste it into an edit window to have a good look at it.  Notice anything interesting?  The last 249 digits are all zeros.  How did this happen and what does it mean?</p>
</div>
<div class="paragraph">
<p>To be honest, when I did this calculation for the first time, I thought I&#8217;d found a bug.  So I looked at the values of N! for N in the range 900 to 1000 and discovered that the zeros accumulate on the end of N! as N gets bigger.  Let&#8217;s think about it for a bit:  N! is a cumulative product, so once a zero has appeared on the end there is no way to get rid of it by multiplying by a positive integer.</p>
</div>
<div class="paragraph">
<p>How do the zeros appear?  Well, this isn&#8217;t to hard to figure out.  Obviously, each time you reach a multiple of 10, you will add (at least) one more zero to the cumulative product.  But what about multiples of 5?  Well, you would add one more zero if you can match the 5 to a 2 within the factors, and there are lots of lonely 2s in that list.  So, to summarize, each time N is a multiple of 5, you add at least one zero onto the cumulative product N!.</p>
</div>
<div class="paragraph">
<p>So here&#8217;s the question we&#8217;re going to solve:  For an arbitrary N, can you predict exactly how many trailing zeros there will be in N!?</p>
</div>
<div class="paragraph">
<p>Again, this can be solved analytically (and if you go looking on the web, you will discover that this is an old chestnut of a math problem that&#8217;s sometimes used in job interviews to test analytical ability), but what I want to do here is to show how we can use Rascal to play around with the problem space a bit to help us build up our intuition.  This is very much like what we do in empirical software engineering, when we have lots of data to analyze, and we&#8217;re trying to look for patterns that might explain behaviours, such as why some functions are more likely to be associated with bugs than others.  In that kind of situation, we typically go through two stages:  first, we wade through the data, exploring relationships, looking for unusual lumps or recognizable patters; second, we build theories of how the world works, and test them out using the data.  In both stages, we not only look at the data, we play with it.  We build little tools to help answer our questions, see where our hunches lead us.  We use this "play" to improve our understanding of the problem space, and build intuition about how it works as testable theories.  In empirical software engineering, as in most other sciences, we usually don&#8217;t get concrete proof of a theory; rather, we gather evidence towards ultimately accepting or rejecting the theories (tho often, we may choose to use this evidence to refine the theories and try again).</p>
</div>
<div class="paragraph">
<p>In this case, however, there is a precise analytical solution, a proof, a "ground truth".  But that doesn&#8217;t mean that we can&#8217;t use the empirical approach to help build our intuition about the problem space, and ultimately devise a theory about how to calculate the number of trailing zeros in N!.  Solving analytical problems is about having enough intuition to see possible solutions.  And using this empirical approach is one way to build intuition.</p>
</div>
<div class="paragraph">
<p>So let&#8217;s define a few helper functions and see where that leads us:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-rascal" data-lang="rascal">public int countZeros (int n) {
    if (n &lt; 10) {
	return 0;
    } else if (n % 10 == 0) {
        return 1 + countZeros (n / 10);
    } else {
	return countZeros (n / 10);
    }
}
rascal&gt; int i = fact(1000);
int: 402387260077093773543702433923003985719374864210714632543799910429938512398629020592044208486969404800479988610197196058631666872994808558901323829669944590997424504087073759918823627727188732519779505950995276120874975462497043601418278094646496291056393887437886487337119181045825783647849977012476632889835955735432513185323958463075557409114262417474349347553428646576611667797396668820291207379143853719588249808126867838374559731746136085379534524221586593201928090878297308431392844403281231558611036976801357304216168747609675871348312025478589320767169132448426236131412508780208000261683151027341827977704784635868170164365024153691398281264810213092761244896359928705114964975419909342221566832572080821333186116811553615836546984046708975602900950537616475847728421889679646244945160765353408198901385442487984959953319101723355556602139450399736280750137837615307127761926849034352625200015888535147331611702103968175921510907788019393178114194545257223865541461062892187960223838971476088506276862967146674697562911234082439208160153780889893964518263243671616762179168909779911903754031274622289988005195444414282012187361745992642956581746628302955570299024324153181617210465832036786906117260158783520751516284225540265170483304226143974286933061690897968482590125458327168226458066526769958652682272807075781391858178889652208164348344825993266043367660176999612831860788386150279465955131156552036093988180612138558600301435694527224206344631797460594682573103790084024432438465657245014402821885252470935190620929023136493273497565513958720559654228749774011413346962715422845862377387538230483865688976461927383814900140767310446640259899490222221765904339901886018566526485061799702356193897017860040811889729918311021171229845901641921068884387121855646124960798722908519296819372388642614839657382291123125024186649353143970137428531926649875337218940694281434118520158014123344828015051399694290153483077644569099073152433278288269864602789864321139083506217095002597389863554277196742822248757586765752344220207573630569498825087968928162753848863396909959826280956121450994871701244516461260379029309120889086942028510640182154399457156805941872748998094254742173582401063677404595741785160829230135358081840096996372524230560855903700624271243416909004153690105933983835777939410970027753472000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
rascal&gt; countZeros(i);
int: 472</code></pre>
</div>
</div>
<div class="paragraph">
<p>This was my first try at the solution (really!), and there&#8217;s a problem: 1000! has exactly 249 trailing zeros, not 472.</p>
</div>
<div class="paragraph">
<p>What did I do wrong?  Oh, right, <em>trailing</em> zeros, and the above function counts <em>all</em> of the zeros.  Let&#8217;s try again:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-rascal" data-lang="rascal">public int countTrailingZeros (int n) {
    if (n &lt; 10) {
	return 0;
    } else if (n % 10 == 0) {
        return 1 + countTrailingZeros (n / 10);
    } else {
	return 0 ;
    }
}

rascal&gt; countTrailingZeros(i);
int: 249</code></pre>
</div>
</div>
<div class="paragraph">
<p>OK, so we&#8217;re making progress.  Let&#8217;s define another function to help us explore the data space:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-rascal" data-lang="rascal">public void printLastTwenty (int n){
    for(int i &lt;- [n-19..n+1]) {
        println ("&lt;i&gt;! has &lt;countTrailingZeros(fact(i))&gt; trailing zeros.");
    }
}

rascal&gt;printLastTwenty(1000);
981! has 243 trailing zeros.
982! has 243 trailing zeros.
983! has 243 trailing zeros.
984! has 243 trailing zeros.
985! has 244 trailing zeros.
986! has 244 trailing zeros.
987! has 244 trailing zeros.
988! has 244 trailing zeros.
989! has 244 trailing zeros.
990! has 245 trailing zeros.
991! has 245 trailing zeros.
992! has 245 trailing zeros.
993! has 245 trailing zeros.
994! has 245 trailing zeros.
995! has 246 trailing zeros.
996! has 246 trailing zeros.
997! has 246 trailing zeros.
998! has 246 trailing zeros.
999! has 246 trailing zeros.
1000! has 249 trailing zeros.
ok</code></pre>
</div>
</div>
<div class="paragraph">
<p>So the pattern I see arising (confirmed by more playing that I won&#8217;t show you) is that you add a zero every time N is divisible by 5.  But sometimes you add more than one zero: 1000! adds three zeros.</p>
</div>
<div class="paragraph">
<p>We defined one function above to help us look at the data more compactly; now let&#8217;s create another function to look for lumps in the data:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-rascal" data-lang="rascal">// Printout all i in [0..n] where i! has more trailing zeros than (i-1)!
public void findLumps (int n) {
    int iMinusOneFactZeros = 0;
    for (int i &lt;- [1..n+1]) {
        int iFactZeros = countTrailingZeros(fact(i));
        int diff = iFactZeros - iMinusOneFactZeros ;
        if (diff &gt;= 1) {
            println ("&lt;diff&gt; more zeros at &lt;i&gt;!");
        }
        iMinusOneFactZeros = iFactZeros;
    }
}

rascal&gt;findLumps(1000);
1 more zeros at 5!
1 more zeros at 10!
1 more zeros at 15!
1 more zeros at 20!
2 more zeros at 25!
1 more zeros at 30!
1 more zeros at 35!
1 more zeros at 40!
1 more zeros at 45!
2 more zeros at 50!
1 more zeros at 55!
1 more zeros at 60!
1 more zeros at 65!
1 more zeros at 70!
2 more zeros at 75!
1 more zeros at 80!
1 more zeros at 85!
1 more zeros at 90!
1 more zeros at 95!
2 more zeros at 100!
1 more zeros at 105!
1 more zeros at 110!
1 more zeros at 115!
1 more zeros at 120!
3 more zeros at 125!
1 more zeros at 130!
...
1 more zeros at 245!
3 more zeros at 250!
1 more zeros at 255!
1 more zeros at 495!
3 more zeros at 500!
1 more zeros at 505!
...
1 more zeros at 620!
4 more zeros at 625!
1 more zeros at 630!
...
1 more zeros at 985!
1 more zeros at 990!
1 more zeros at 995!
3 more zeros at 1000!
ok</code></pre>
</div>
</div>
<div class="paragraph">
<p>So probably we&#8217;re noticing some patterns here already, and maybe forming some intuition.  But let&#8217;s first revise our lump-finding function to produce even more concise output:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-rascal" data-lang="rascal">// We can parameterize the threshold to look for jumps of 2, 3, or 4 zeros
public void findLumps2 (int n, int tao) {
    int iMinusOneFactZeros = 0;
    for (int i &lt;- [1..n+1]) {
        int iFactZeros = countTrailingZeros(fact(i));
        int diff = iFactZeros - iMinusOneFactZeros ;
        if (diff &gt;= tao) {
            println ("&lt;diff&gt; more zeros at &lt;i&gt;!");
        }
        iMinusOneFactZeros = iFactZeros;
    }
}

rascal&gt;findLumps2(1000,2);
2 more zeros at 25!
2 more zeros at 50!
2 more zeros at 75!
2 more zeros at 100!
3 more zeros at 125!
2 more zeros at 150!
2 more zeros at 175!
2 more zeros at 200!
2 more zeros at 225!
3 more zeros at 250!
2 more zeros at 275!
...
2 more zeros at 950!
2 more zeros at 975!
3 more zeros at 1000!
ok

rascal&gt;findLumps2(1000,3);
3 more zeros at 125!
3 more zeros at 250!
3 more zeros at 375!
3 more zeros at 500!
4 more zeros at 625!
3 more zeros at 750!
3 more zeros at 875!
3 more zeros at 1000!
ok

rascal&gt;findLumps2(1000,4);
4 more zeros at 625!
ok</code></pre>
</div>
</div>
<div class="paragraph">
<p>Notice anything yet?  Here are some fun math facts to consider:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>5<sup>0</sup> = 1</p>
</li>
<li>
<p>5<sup>1</sup> = 5</p>
</li>
<li>
<p>5 <sup>2</sup> = 25</p>
</li>
<li>
<p>5<sup>3</sup> = 125</p>
</li>
<li>
<p>5<sup>4</sup> = 625</p>
</li>
<li>
<p>5<sup>5</sup> = 3125</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>So here&#8217;s the solution:</p>
</div>
<div class="paragraph">
<p>Let N be a positive integer.</p>
</div>
<div class="paragraph">
<p>Let k = floor (log<sub>5</sub> N)</p>
</div>
<div class="paragraph">
<p>Start a counter at zero, call it nz</p>
</div>
<div class="paragraph">
<p>We want to examine i &#8592; [1..N+1]</p>
</div>
<div class="ulist">
<ul>
<li>
<p>If i  is not divisible by 5, ignore it</p>
</li>
<li>
<p>If  i  is divisible by 5, add 1 to nz</p>
</li>
<li>
<p>If  i  is also divisible by 25, add 1 more</p>
</li>
<li>
<p>&#8230;&#8203;</p>
</li>
<li>
<p>If  i is also divisible by 2k, add 1 more</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>We can write this in Rascal as:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-rascal" data-lang="rascal">public int predictZeros (int N) {
    int k = floorLogBase(N, 5);  // I wrote this
    int nz = 0;
    for (int i &lt;- [1..N+1] ){
	int p5 = 1;
        for (int j &lt;- [1..k+1]) {
    	    p5 *= 5;
    	    if (i % p5 == 0) {
		nz += 1;
	    } else {
    	    	break;
	    }
	}
    }
    return nz;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Now a little hand validation might convince you that this should work, but let&#8217;s write a little verifier function to be sure:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-rascal" data-lang="rascal">public void verifyTheory (int N) {
    int checkInterval = 100; // for printing
    bool failed = false;
    for (int i &lt;- [1..N+1]) {
        ifact=fact(i);
    	int p = predictZeros(i);
    	int c = countTrailingZeros(ifact);
    	if (p != c) {
	    failed = true;
	    println ("Found a counter example at i=&lt;i&gt;");
	    break;
    	} else {
	    if (i % checkInterval == 0) {
		println ("&lt;i&gt;! has &lt;p&gt; trailing zeros");
	    }
	}
    }
    if (!failed) {
	println ("The theory works for i: 1..&lt;N&gt;");
    }
}

rascal&gt;verifyTheory(10);
The theory works for i: 1..10
ok

rascal&gt;verifyTheory(100);
100! has 24 trailing zeros
The theory works for i: 1..100
ok

rascal&gt;verifyTheory(1000);
100! has 24 trailing zeros
200! has 49 trailing zeros
300! has 74 trailing zeros
400! has 99 trailing zeros
500! has 124 trailing zeros
600! has 148 trailing zeros
Found a counter example at i=625
    predicted zeros = 155
    observed zeros  = 156
ok</code></pre>
</div>
</div>
<div class="paragraph">
<p>Yikes, what do we do?  Well, first let&#8217;s look under the hood at the engine.  The function <code>predictZeros</code> <em>is</em> actually correct, assuming that the functions is calls are correct.  So let&#8217;s look at the auxiliary functions I wrote (but haven&#8217;t shown you yet):</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-rascal" data-lang="rascal">// Log for an arbitrary base
public real logB(real a, real base) {
    return log(a) / log(base);
}

public real floor (real a) {
    return toReal(round (a - 0.5));
}

public int floorLogBase (int a, int b) {
    return toInt(floor(logB(toReal(a), toReal(b))));
}

rascal&gt;floorLogBase(625,5);
int: 3
rascal&gt;logB(625.0,5.0);
real: 3.9999999999999998757330130880776320985295476764801684...</code></pre>
</div>
</div>
<div class="paragraph">
<p>Oh right, real numbers are prone to round off error.  What should we do?</p>
</div>
<div class="paragraph">
<p>Well, here&#8217;s a bad solution (that "works"):</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-rascal" data-lang="rascal">public real floor (real a) {
    return toReal(round (a - 0.5 + 0.00001));
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>But how can I be sure that that&#8217;s enought decimal places?  What if someone likes my <code>floor</code> function and sticks it into the Rascal library, where it is subsequently used by the Eurpoean Space Agency for its next generation of flight control software?</p>
</div>
<div class="paragraph">
<p>Sometimes, the answer is to do a lot of homework.  Lucky for us, here there is a fairly efficient exact solution using repeated integer division:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-rascal" data-lang="rascal">// Also change predictZeros to call this version
public int floorLogBase2 (int a, int b) {
    int remaining = a;
    int ans = 0;
    while (remaining &gt;= b) {
	ans += 1;
	remaining /= b;
    }
    return ans;
}

rascal&gt;verifyTheory(1000);
100! has 24 trailing zeros
200! has 49 trailing zeros
300! has 74 trailing zeros
400! has 99 trailing zeros
500! has 124 trailing zeros
600! has 148 trailing zeros
700! has 174 trailing zeros
800! has 199 trailing zeros
900! has 224 trailing zeros
1000! has 249 trailing zeros
The theory works for i: 1..1000
ok</code></pre>
</div>
</div>
<div class="paragraph">
<p>And we&#8217;re done.  But what did we learn here?  Here&#8217;s what I think:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Explore the terrain, take notes, build intuition, develop theories, test them.</p>
<div class="ulist">
<ul>
<li>
<p>Refine and repeat</p>
</li>
<li>
<p>Double check!</p>
</li>
</ul>
</div>
</li>
<li>
<p>Build infrastructure with natural "break points"</p>
<div class="ulist">
<ul>
<li>
<p>Understandable is better than fast, esp. in the beginning</p>
</li>
<li>
<p>The correct way is better than the easy way</p>
<div class="ulist">
<ul>
<li>
<p>The correct way may be pretty easy too</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
</li>
<li>
<p>Document and later challenge your assumptions</p>
<div class="ulist">
<ul>
<li>
<p>Are you measuring what you think you are measuring?  How do you know?</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="Common-CallAnalysis">2.2. Call Analysis</h3>
<div class="paragraph">
<div class="title">Synopsis</div>
<p>Analyzing the call structure of an application.</p>
</div>
<div class="paragraph">
<div class="title">Description</div>
<p>Suppose a mystery box ends up on your desk. When you open it, it contains a huge software system with several questions attached to it:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>How many procedure calls occur in this system?</p>
</li>
<li>
<p>How many procedures does it contains?</p>
</li>
<li>
<p>What are the entry points for this system, i.e., procedures that call others but are not called themselves?</p>
</li>
<li>
<p>What are the leaves of this application, i.e., procedures that are called but do not make any calls themselves?</p>
</li>
<li>
<p>Which procedures call each other indirectly?</p>
</li>
<li>
<p>Which procedures are called directly or indirectly from each entry point?</p>
</li>
<li>
<p>Which procedures are called from all entry points?</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Let&#8217;s see how these questions can be answered using Rascal.</p>
</div>
<div class="paragraph">
<div class="title">Examples</div>
<p>Consider the following call graph (a box represents a procedure and an arrow represents a call from one procedure to another procedure):</p>
</div>
<div class="imageblock">
<div class="content">
<img src="Common/CallAnalysis/calls.png" alt="calls" width="300px">
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-rascal-shell" data-lang="rascal-shell">rascal&gt;import Set;
ok
rascal&gt;import Relation;
ok
rascal&gt;import analysis::graphs::Graph;
ok</code></pre>
</div>
</div>
<div class="paragraph">
<p>Rascal supports basic data types like integers and strings which are sufficient to formulate and answer the questions at hand. However, we
can gain readability by introducing separately named types for the items we are describing.
First, we introduce therefore a new type <code>Proc</code> (an alias for strings) to denote procedures:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-rascal-shell" data-lang="rascal-shell">rascal&gt;alias Proc = str;
ok</code></pre>
</div>
</div>
<div class="paragraph">
<p>Next, we have to represent the call relation as a Rascal datatype, and the relation is the most appropriate for it.
As preparation, we also import the libraries [$Rascal:Prelude/Set], [$Rascal:Prelude/Relation] and [$Rascal:Libraries/analysis/graphs/Graph] that will come in handy.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-rascal-shell" data-lang="rascal-shell">rascal&gt;rel[Proc, Proc] Calls = {&lt;"a", "b"&gt;, &lt;"b", "c"&gt;, &lt;"b", "d"&gt;, &lt;"d", "c"&gt;,
&gt;&gt;&gt;&gt;&gt;&gt;&gt;                         &lt;"d", "e"&gt;, &lt;"f", "e"&gt;, &lt;"f", "g"&gt;, &lt;"g", "e"&gt;};
rel[str,str]: {
  &lt;"f","e"&gt;,
  &lt;"g","e"&gt;,
  &lt;"a","b"&gt;,
  &lt;"b","d"&gt;,
  &lt;"b","c"&gt;,
  &lt;"d","c"&gt;,
  &lt;"d","e"&gt;,
  &lt;"f","g"&gt;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Now we are in a good position to start asking some questions.</p>
</div>
<div class="paragraph">
<p><em>How many calls occur in this system?</em>
We use the function [Rascal:Set/size] to determine the number of elements in a set or relation.
Since each tuple in the <code>Calls</code> relation represents a call between procedures, the number of tuples is equal
to the number of calls.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-rascal-shell" data-lang="rascal-shell">rascal&gt;size(Calls);
int: 8</code></pre>
</div>
</div>
<div class="paragraph">
<p><em>How many procedures occur in this system?</em> This question is more subtle, since a procedure may call (or be called) by
several others and the number of tuples is therefore not indicative. What we need are the set of procedures that
occur (as first or second element) in <em>any</em> tuple. This is precisely what the function [$Rascal:Libraries/Prelude/Relation/carrier] gives us:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-rascal-shell" data-lang="rascal-shell">rascal&gt;carrier(Calls);
set[str]: {"a","b","c","d","e","f","g"}</code></pre>
</div>
</div>
<div class="paragraph">
<p>and computing the number of procedures is now easy:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-rascal-shell" data-lang="rascal-shell">rascal&gt;size(carrier(Calls));
int: 7</code></pre>
</div>
</div>
<div class="paragraph">
<p>As an aside, functions [$Rascal:Prelude/Relation/domain] and [$Rascal:Prelude/Relation/range] do the same for the first, respectively, second element of the pairs in a relation:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-rascal-shell" data-lang="rascal-shell">rascal&gt;domain(Calls);
set[str]: {"a","b","d","f","g"}
rascal&gt;range(Calls);
set[str]: {"b","c","d","e","g"}</code></pre>
</div>
</div>
<div class="paragraph">
<p><em>What are the entry points for this system?</em></p>
</div>
<div class="paragraph">
<p>The next step in the analysis is to determine which entry points this application has, i.e., procedures which call others but are
not called themselves. Entry points are useful since they define the external interface of a system and may also be used as guidance to
split a system in parts. The top of a relation contains those left-hand sides of tuples in a relation that do not occur in any
right-hand side. When a relation is viewed as a graph, its top corresponds to the root nodes of that graph. Similarly, the bottom of a
relation corresponds to the leaf nodes of the graph. See the section called  [$Rascal:Libraries/analysis/graphs/Graph] for more details. Using this knowledge, the entry
points can be computed by determining the top of the Calls relation:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-rascal-shell" data-lang="rascal-shell">rascal&gt;top(Calls);
set[str]: {"a","f"}</code></pre>
</div>
</div>
<div class="paragraph">
<p><em>What are the leaves of this application?</em></p>
</div>
<div class="paragraph">
<p>In a similar spirit, we can determine the leaves of this application, i.e., procedures that are being called but do not make any calls
themselves:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-rascal-shell" data-lang="rascal-shell">rascal&gt;bottom(Calls);
set[str]: {"c","e"}</code></pre>
</div>
</div>
<div class="paragraph">
<p><em>Which procedures call each other indirectly?</em></p>
</div>
<div class="paragraph">
<p>We can also determine the indirect calls between procedures, by taking the transitive closure of the Calls relation, written as <code>Calls+</code>.
Observe that the transitive closure will contain both the direct and the indirect calls.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-rascal-shell" data-lang="rascal-shell">rascal&gt;closureCalls = Calls+;
rel[str,str]: {
  &lt;"f","e"&gt;,
  &lt;"g","e"&gt;,
  &lt;"a","b"&gt;,
  &lt;"a","c"&gt;,
  &lt;"b","c"&gt;,
  &lt;"d","c"&gt;,
  &lt;"d","e"&gt;,
  &lt;"f","g"&gt;,
  &lt;"a","d"&gt;,
  &lt;"b","e"&gt;,
  &lt;"b","d"&gt;,
  &lt;"a","e"&gt;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><em>Which procedures are called directly or indirectly from each entry point?</em></p>
</div>
<div class="paragraph">
<p>We now know the entry points for this application ("a" and "f") and the indirect call relations. Combining this information,
we can determine which procedures are called from each entry point. This is done by indexing closureCalls with appropriate procedure name.
The index operator yields all right-hand sides of tuples that have a given value as left-hand side. This gives the following:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-rascal-shell" data-lang="rascal-shell">rascal&gt;calledFromA = closureCalls["a"];
set[str]: {"b","c","d","e"}
rascal&gt;calledFromF = closureCalls["f"];
set[str]: {"e","g"}</code></pre>
</div>
</div>
<div class="paragraph">
<p><em>Which procedures are called from all entry points?</em></p>
</div>
<div class="paragraph">
<p>Finally, we can determine which procedures are called from both entry points by taking the intersection of the two sets
<code>calledFromA</code> and <code>calledFromF</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-rascal-shell" data-lang="rascal-shell">rascal&gt;calledFromA &amp; calledFromF;
set[str]: {"e"}</code></pre>
</div>
</div>
<div class="paragraph">
<p>or if your prefer to write all of the above as a one-liner using a [$Rascal:Expressions/Reducer] expression:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-rascal-shell" data-lang="rascal-shell">rascal&gt;(carrier(Calls) | it &amp; (Calls+)[p] | p &lt;- top(Calls));
set[str]: {"e"}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The reducer is initialized with  all procedures (<code>carrier(Calls)</code>) and iterates over all entry points (<code>p &#8592; top(Calls)</code>).
At each iteration the current value of the reducer (<code>it</code>) is intersected (<code>&amp;</code>) with the procedures called directly or indirectly
from that entry point (<code>(Calls+)[p]</code>).</p>
</div>
<div class="ulist">
<div class="title">Benefits</div>
<ul>
<li>
<p>In small examples, the above results can be easily obtained by a visual inspection of the call graph.
Such a visual inspection does <em>not</em> scale very well to large graphs and this makes the above form of analysis particularly suited for studying large systems.</p>
</li>
</ul>
</div>
<div class="ulist">
<div class="title">Pitfalls</div>
<ul>
<li>
<p>We discuss call analysis in a, intentionally, simplistic fashion that does not take into account how the call relation
is extracted from actual source code.
The above principles are, however, applicable to real cases as well.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="Common-CallLifting">2.3. Call Lifting</h3>
<div class="paragraph">
<div class="title">Synopsis</div>
<p>Lift procedure calls to component calls.</p>
</div>
<div class="paragraph">
<div class="title">Description</div>
<p>A frequently occurring problem is that we know the call relation of a system but that we want to understand it at the component level rather than at the procedure level. If it is known to which component each procedure belongs, it is possible to lift the call relation to the component level. Actual lifting amounts to translating each call between procedures by a call between components.</p>
</div>
<div class="paragraph">
<div class="title">Examples</div>
<p>Consider the following figure:</p>
</div>
<div class="imageblock">
<div class="content">
<img src="Common/CallLifting/parts.png" alt="Module Parts" width="500px">
</div>
</div>
<div class="paragraph">
<p>(a) Shows the calls between procedures;
(b) shows how procedures are part of a system component.
(c) shows how the call relation given in (a) can be lifted to the component level.</p>
</div>
<div class="paragraph">
<p>The situation can be characterized by:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>A call relation between procedures</p>
</li>
<li>
<p>A partOf relation between procedures and components</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The problem is now to lift the call relation using the information in the partOf relation.
In other words: a call between two procedures will be lifted to
a call between the components to which each procedure belongs.</p>
</div>
<div class="paragraph">
<p>Here is a solution:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-rascal" data-lang="rascal">module demo::common::Lift

alias proc = str;
alias comp = str;

rel[comp,comp] lift(rel[proc,proc] aCalls, rel[proc,comp] aPartOf){
	return { &lt;C1, C2&gt; | &lt;proc P1, proc P2&gt; &lt;- aCalls,
	                    &lt;comp C1, comp C2&gt; &lt;- aPartOf[P1] * aPartOf[P2] };
}

// Test set-up

rel[proc,proc] Calls = {&lt;"main", "a"&gt;, &lt;"main", "b"&gt;, &lt;"a", "b"&gt;, &lt;"a", "c"&gt;, &lt;"a", "d"&gt;,
                        &lt;"b", "d"&gt;};

set[comp] Components = {"Appl", "DB", "Lib"};

rel[proc, comp] PartOf = {&lt;"main", "Appl"&gt;, &lt;"a", "Appl"&gt;, &lt;"b", "DB"&gt;,
                          &lt;"c", "Lib"&gt;, &lt;"d", "Lib"&gt;};

rel[comp,comp] ComponentCalls = lift(Calls, PartOf);</code></pre>
</div>
</div>
<div class="paragraph">
<p>And we can use it as follows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-rascal-shell" data-lang="rascal-shell">rascal&gt;import demo::common::Lift;
rascal2rvm: Parsing and checking |std:///demo/common/Lift.rsc|
rascal2rvm: Compiling |std:///demo/common/Lift.rsc|
r2mu: entering ... demo::common::Lift
mu2rvm: Compiling module demo::common::Lift
Compiling |std:///demo/common/Lift.rsc|: check: 8, compile: 150, total: 158 ms
compile: Writing RVMModule |compressed+home:///bin-console/demo/common/Lift.rvm.gz|
Removing |compressed+home:///bin-console/ConsoleInput_imports.rvm.gz|
ok</code></pre>
</div>
</div>
<div class="paragraph">
<p>Encode the call relation and partOf relation:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-rascal-shell" data-lang="rascal-shell">rascal&gt;calls = {&lt;"main", "a"&gt;, &lt;"main", "b"&gt;, &lt;"a", "b"&gt;, &lt;"a", "c"&gt;, &lt;"a", "d"&gt;, &lt;"b", "d"&gt;};
rel[str,str]: {
  &lt;"a","d"&gt;,
  &lt;"a","b"&gt;,
  &lt;"b","d"&gt;,
  &lt;"a","c"&gt;,
  &lt;"main","a"&gt;,
  &lt;"main","b"&gt;
}
rascal&gt;partOf = {&lt;"main", "Appl"&gt;, &lt;"a", "Appl"&gt;, &lt;"b", "DB"&gt;, &lt;"c", "Lib"&gt;, &lt;"d", "Lib"&gt;};
rel[str,str]: {
  &lt;"b","DB"&gt;,
  &lt;"a","Appl"&gt;,
  &lt;"main","Appl"&gt;,
  &lt;"d","Lib"&gt;,
  &lt;"c","Lib"&gt;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>and do the lifting:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-rascal-shell" data-lang="rascal-shell">rascal&gt;lift(calls, partOf);
rel[str,str]: {
  &lt;"Appl","Appl"&gt;,
  &lt;"DB","Lib"&gt;,
  &lt;"Appl","DB"&gt;,
  &lt;"Appl","Lib"&gt;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Please verify that this corresponds exactly to (c) in the figure above.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-rascal-shell" data-lang="rascal-shell"></code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="Common-ColoredTrees">2.4. Colored Trees</h3>
<div class="paragraph">
<div class="title">Synopsis</div>
<p>Computations on binary trees.</p>
</div>
<div class="paragraph">
<div class="title">Description</div>
<p>We consider binary trees---trees with exactly two children---that have integers as their leaves.
Our trees can have red and black nodes and we want to perform the following operations on them:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Count the number of red nodes.</p>
</li>
<li>
<p>Compute the sum of all the integers that occur in the leaves.</p>
</li>
<li>
<p>Extend the tree data type with green nodes.</p>
</li>
<li>
<p>Replace all red nodes by green ones.</p>
</li>
</ul>
</div>
<div class="paragraph">
<div class="title">Examples</div>
<p>The definition of ColoredTrees is as follows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-rascal" data-lang="rascal">module demo::common::ColoredTrees

// Define ColoredTrees with red and black nodes and integer leaves

data ColoredTree = leaf(int N) <i class="conum" data-value="1"></i><b>(1)</b>
                 | red(ColoredTree left, ColoredTree right)
                 | black(ColoredTree left, ColoredTree right);

public ColoredTree  rb = red(black(leaf(1), red(leaf(2),leaf(3))), black(leaf(3), leaf(4)));

// Count the number of red nodes

int cntRed(ColoredTree t){
   int c = 0;
   visit(t) {
     case red(_,_): c = c + 1; <i class="conum" data-value="2"></i><b>(2)</b>
   };
   return c;
}

test bool tstCntRed() = cntRed(rb) == 2;

// Compute the sum of all integer leaves

int addLeaves(ColoredTree t){
   int c = 0;
   visit(t) {
     case leaf(int N): c = c + N; <i class="conum" data-value="3"></i><b>(3)</b>
   };
   return c;
}

test bool tstAddLeaves() = addLeaves(rb) == 13;

// Add green nodes to ColoredTree

data ColoredTree = green(ColoredTree left, ColoredTree right); <i class="conum" data-value="4"></i><b>(4)</b>

// Transform red nodes into green nodes

ColoredTree makeGreen(ColoredTree t){
   return visit(t) {
     case red(l, r) =&gt; green(l, r) <i class="conum" data-value="5"></i><b>(5)</b>
   };
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>We define the data type of <code>ColoredTrees</code> with constructors <code>leaf</code>, <code>red</code> and <code>black</code>.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td><code>cntRed</code> counts all red nodes by visiting all nodes and incrementing
the counter <code>c</code> for each red one.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td><code>addLeaves</code> visits all nodes and adds the integers in each leaf node.</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td><code>coloredTrees</code> are extended with a new constructor <code>green</code>.</td>
</tr>
<tr>
<td><i class="conum" data-value="5"></i><b>5</b></td>
<td><code>makeGreen</code> visits all nodes and turns red nodes in green ones.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>We can now explore ColoredTrees:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-rascal-shell" data-lang="rascal-shell">rascal&gt;import demo::common::ColoredTrees;
rascal2rvm: Parsing and checking |std:///demo/common/ColoredTrees.rsc|
rascal2rvm: Compiling |std:///demo/common/ColoredTrees.rsc|
r2mu: entering ... demo::common::ColoredTrees
mu2rvm: Compiling module demo::common::ColoredTrees
Compiling |std:///demo/common/ColoredTrees.rsc|: check: 9, compile: 1284, total: 1293 ms
compile: Writing RVMModule |compressed+home:///bin-console/demo/common/ColoredTrees.rvm.gz|
Removing |compressed+home:///bin-console/ConsoleInput_imports.rvm.gz|
ok
rascal&gt;rb = red(black(leaf(1), red(leaf(2),leaf(3))), black(leaf(3), leaf(4)));
ColoredTree: red(
  black(
    leaf(1),
    red(
      leaf(2),
      leaf(3))),
  black(
    leaf(3),
    leaf(4)))</code></pre>
</div>
</div>
<div class="paragraph">
<p>Count the red nodes in <code>rb</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-rascal-shell" data-lang="rascal-shell">rascal&gt;cntRed(rb);
int: 2</code></pre>
</div>
</div>
<div class="paragraph">
<p>and compute the sum of all leaves:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-rascal-shell" data-lang="rascal-shell">rascal&gt;addLeaves(rb);
int: 13</code></pre>
</div>
</div>
<div class="paragraph">
<p>Finally, we convert all red nodes:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-rascal-shell" data-lang="rascal-shell">rascal&gt;makeGreen(rb);
ColoredTree: green(
  black(
    leaf(1),
    green(
      leaf(2),
      leaf(3))),
  black(
    leaf(3),
    leaf(4)))</code></pre>
</div>
</div>
<div class="paragraph">
<div class="title">Benefits</div>
<p>This example illustrates the fully automatic visiting of the elements of a structured data type.
Compare this with the traditional programming style in which a switch statement is used to determine
the constructor and recursion is used to visit substructures. This style becomes particularly cumbersome
for data types with large numbers of constructors such as, for instance, abstract syntax trees for real
programming languages.</p>
</div>
<div class="paragraph">
<div class="title">Pitfalls</div>
<p>The visit statement is based on a new paradigm one has to learn.</p>
</div>
</div>
<div class="sect2">
<h3 id="Common-CountConstructors">2.5. Count Constructors</h3>
<div class="paragraph">
<div class="title">Synopsis</div>
<p>Generic function that can count constructors in a value of any algebraic data type.</p>
</div>
<div class="paragraph">
<div class="title">Description</div>
<p>In <a href="#ColoredTrees">[ColoredTrees]</a>, we have seen a function that can count the number of red nodes in a <code>ColoredTree</code>.
Is it possible to define a function that can count constructors in a value of any algerbaic data type?</p>
</div>
<div class="paragraph">
<p>We exploit the subtype relation (see <a href="../Rascal/Rascal.html#Concepts-StaticTyping">Static Typing</a>)
between <a href="../Rascal/Rascal.html#Declrations-AlgebraicDataType">algebraic data types</a>s
and the type <a href="../Rascal/Rascal.html#Values-Node">node</a> to achieve this.</p>
</div>
<div class="paragraph">
<p>In real applications this becomes relevant when counting, for instance, statement types in programs.</p>
</div>
<div class="listingblock">
<div class="title">Examples</div>
<div class="content">
<pre class="highlight"><code class="language-rascal" data-lang="rascal">module demo::common::CountConstructors

import Node;
import Map;

// Define a ColoredTree data type

data ColoredTree = leaf(int N)
                 | red(ColoredTree left, ColoredTree right)
                 | black(ColoredTree left, ColoredTree right);

public ColoredTree CT = red(black(leaf(1), red(leaf(2),leaf(3))), black(leaf(3), leaf(4)));

// Define a Card data type.

data Suite = hearts() | diamonds() | clubs() | spades();

data Card =  two(Suite s) | three(Suite s) | four(Suite s) | five(Suite s) |
             six(Suite s) | seven(Suite s) | eight(Suite s) | nine(Suite s) | ten(Suite s) |
             jack(Suite s) | queen(Suite s) | king(Suite s) | ace(Suite s);

data Hand = hand(list[Card] cards);

public Hand H = hand([two(hearts()), jack(diamonds()), six(hearts()), ace(spades())]);

// Count frequencies of constructors

map[str,int] count(node N){ <i class="conum" data-value="1"></i><b>(1)</b>
  freq = (); <i class="conum" data-value="2"></i><b>(2)</b>
  visit(N){  <i class="conum" data-value="3"></i><b>(3)</b>
    case node M: { name = getName(M); <i class="conum" data-value="4"></i><b>(4)</b>
                   freq[name] ? 0 += 1;
                 }
  }
  return freq; <i class="conum" data-value="5"></i><b>(5)</b>
}

map[str,int] countRelevant(node N, set[str] relevant) = domainR(count(N), relevant); <i class="conum" data-value="6"></i><b>(6)</b></code></pre>
</div>
</div>
<div class="paragraph">
<p>Two data types are introduced <code>ColoredTree</code> and <code>Hand</code> together
with an example value of each (<code>CT</code>, respectively, <code>H</code>).</p>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>The function <code>count</code> is defined.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Introduces an empty map to maintain the frequencies.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>Defines a visit of argument <code>N</code>; it traverses the complete value of <code>N</code>.</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>Defines the case that we encounter a node and we update its frequency count.
First the name of the constructor is retrieved (using <a href="../Libraries/Libraries.html#Node-getName">getName</a>) and then the
frequency is updated. The <a href="../Rascal/Rascal.html#Assignment-IsDefined">isDefined</a> operator is used to provide a default value of 0 when
the name was not yet in the map.</td>
</tr>
<tr>
<td><i class="conum" data-value="5"></i><b>5</b></td>
<td>The map <code>freq</code> is returned as result.</td>
</tr>
<tr>
<td><i class="conum" data-value="6"></i><b>6</b></td>
<td>Defines a variant <code>countRelevant</code>; it gets is an extra argument of relevant constructors
names that is used to filter the map that is returned by <code>count</code> using <a href="../Libraries/Libraries.html#Map-domainR">domainR</a>.</td>
</tr>
</table>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-rascal-shell" data-lang="rascal-shell">rascal&gt;import demo::common::CountConstructors;
rascal2rvm: Parsing and checking |std:///demo/common/CountConstructors.rsc|
rascal2rvm: Compiling |std:///demo/common/CountConstructors.rsc|
r2mu: entering ... demo::common::CountConstructors
mu2rvm: Compiling module demo::common::CountConstructors
Compiling |std:///demo/common/CountConstructors.rsc|: check: 15, compile: 1952, total: 1967 ms
compile: Writing RVMModule |compressed+home:///bin-console/demo/common/CountConstructors.rvm.gz|
Removing |compressed+home:///bin-console/ConsoleInput_imports.rvm.gz|
ok
rascal&gt;count(CT);
map[str, int]: ("red":2,"leaf":5,"black":2)
rascal&gt;count(H);
map[str, int]: ("six":1,"ace":1,"two":1,"hearts":2,"spades":1,"hand":1,"diamonds":1,"jack":1)
rascal&gt;countRelevant(H, {"hearts", "spades"});
map[str, int]: ("hearts":2,"spades":1)</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="Common-Derivative">2.6. Derivative</h3>
<div class="paragraph">
<div class="title">Synopsis</div>
<p>Symbolic differentiation.</p>
</div>
<div class="paragraph">
<div class="title">Description</div>
<p>Computing the <a href="http://en.wikipedia.org/wiki/Differentiation_(mathematics)">derivative</a> of an expression with respect to some variable is a classical calculus problem. Loosely speaking, a derivative can be thought of as how much one quantity is changing in response to changes in some other quantity; for example, the derivative of the position of a moving object with respect to time is the object&#8217;s instantaneous velocity.</p>
</div>
<div class="paragraph">
<p>We present here rules for determining the derivative <code>dE/dX</code> of simple expressions <code>E</code> for a given variable <code>X</code>. Recall that for number <code>N</code>, variables <code>X</code> and <code>Y</code>, and expressions <code>E1</code> and <code>E2</code> the following rules apply:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>dN / dX = 0</code>.</p>
</li>
<li>
<p><code>dX / dX = 1</code>.</p>
</li>
<li>
<p><code>dX / dY = 0</code>, when <code>X != Y</code>.</p>
</li>
<li>
<p><code>d(E1 + E2) /dX = dE1 / dX + d E2 /dX</code>.</p>
</li>
<li>
<p><code>d(E1 * E2) / dX =  (d E1 / dX  * E2) + (E1 * d E2 /dX)</code>.</p>
</li>
</ul>
</div>
<div class="paragraph">
<div class="title">Examples</div>
<p>Here is our solution followed by a list of explanations:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-rascal" data-lang="rascal">module demo::common::Derivative

data Exp = con(int n) <i class="conum" data-value="1"></i><b>(1)</b>
         | var(str name)
         | mul(Exp e1, Exp e2)
         | add(Exp e1, Exp e2)
         ;

public Exp E = add(mul(con(3), var("y")), mul(con(5), var("x"))); <i class="conum" data-value="2"></i><b>(2)</b>

Exp dd(con(n), var(V))              = con(0); <i class="conum" data-value="3"></i><b>(3)</b>
Exp dd(var(V1), var(V2))            = con((V1 == V2) ? 1 : 0);
Exp dd(add(Exp e1, Exp e2), var(V)) = add(dd(e1, var(V)), dd(e2, var(V)));
Exp dd(mul(Exp e1, Exp e2), var(V)) = add(mul(dd(e1, var(V)), e2), mul(e1, dd(e2, var(V))));

Exp simp(add(con(n), con(m))) = con(n + m); <i class="conum" data-value="4"></i><b>(4)</b>
Exp simp(mul(con(n), con(m))) = con(n * m);

Exp simp(mul(con(1), Exp e))  = e;
Exp simp(mul(Exp e, con(1)))  = e;
Exp simp(mul(con(0), Exp e))  = con(0);
Exp simp(mul(Exp e, con(0)))  = con(0);

Exp simp(add(con(0), Exp e))  = e;
Exp simp(add(Exp e, con(0)))  = e;

default Exp simp(Exp e)       = e; <i class="conum" data-value="5"></i><b>(5)</b>

Exp simplify(Exp e){ <i class="conum" data-value="6"></i><b>(6)</b>
  return bottom-up visit(e){
           case Exp e1 =&gt; simp(e1)
         }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Define a data type <code>Exp</code> to represent expressions.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Introduce an example expression <code>E</code> for later use.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>Define the actual differentiation function <code>dd</code>. Observe that this definition depends on the use of patterns in function declarations, see [Rascal:Function].</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>Define simplification rules.</td>
</tr>
<tr>
<td><i class="conum" data-value="5"></i><b>5</b></td>
<td>A default rule is give for the case that no simplification applies.</td>
</tr>
<tr>
<td><i class="conum" data-value="6"></i><b>6</b></td>
<td>Define the actual simplication function <code>simplify</code> that performs a bottom up traversal of the expression, application simplification
rules on the the up.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Let&#8217;s differentiate the example expression <code>E</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-rascal-shell" data-lang="rascal-shell">rascal&gt;import demo::common::Derivative;
rascal2rvm: Parsing and checking |std:///demo/common/Derivative.rsc|
rascal2rvm: Compiling |std:///demo/common/Derivative.rsc|
r2mu: entering ... demo::common::Derivative
mu2rvm: Compiling module demo::common::Derivative
Compiling |std:///demo/common/Derivative.rsc|: check: 15, compile: 607, total: 622 ms
compile: Writing RVMModule |compressed+home:///bin-console/demo/common/Derivative.rvm.gz|
Removing |compressed+home:///bin-console/ConsoleInput_imports.rvm.gz|
ok
rascal&gt;dd(E, var("x"));
Exp: add(
  add(
    mul(
      con(0),
      var("y")),
    mul(
      con(3),
      con(0))),
  add(
    mul(
      con(0),
      var("x")),
    mul(
      con(5),
      con(1))))</code></pre>
</div>
</div>
<div class="paragraph">
<p>As you can see, we managed to compute a derivative, but the result is far more complex than we would like.
This is where simplification comes in. First try a simple case:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-rascal-shell" data-lang="rascal-shell">rascal&gt;simplify(mul(var("x"), add(con(3), con(5))));
Exp: mul(
  var("x"),
  con(8))</code></pre>
</div>
</div>
<div class="paragraph">
<p>Now apply simplification to the result of differentiation:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-rascal-shell" data-lang="rascal-shell">rascal&gt;simplify(dd(E, var("x")));
Exp: con(5)</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="Common-StringTemplate">2.7. String Template</h3>
<div class="paragraph">
<div class="title">Synopsis</div>
<p>Using string templates to generate code.</p>
</div>
<div class="paragraph">
<div class="title">Description</div>
<p>Many websites and code generators use template-based code generation. They start from a text template that contains embedded variables and code. The template is "executed" by replacing the embedded variables and code by their string value. Languages like PHP and Ruby are popular for this feature. Let&#8217;s see how we can do this in Rascal.</p>
</div>
<div class="paragraph">
<p>Rascal provides string templates that rival what is provided in
<a href="http://www.ruby-doc.org/stdlib/libdoc/erb/rdoc/ERB.html">Ruby</a>, <a href="http://www.php.net/">PHP</a> or <a href="http://www.stringtemplate.org/">ANTLR</a>.
They are fully described in <a href="../Rascal/Rascal.html#Values-String">string values</a>.</p>
</div>
<div class="paragraph">
<div class="title">Examples</div>
<p>The problem we want to solve is as follows:
given a number of fields (with a name and a type)
how can we generate a Java class with getters and setters for those fields?</p>
</div>
<div class="paragraph">
<p>Here is a solution:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-rascal" data-lang="rascal">module demo::common::StringTemplate

import String;
import IO;
import Set;
import List;

// Capitalize the first character of a string

str capitalize(str s) { <i class="conum" data-value="1"></i><b>(1)</b>
  return toUpperCase(substring(s, 0, 1)) + substring(s, 1);
}

// Helper function to generate a setter
private str genSetter(map[str,str] fields, str x) {
  return "public void set&lt;capitalize(x)&gt;(&lt;fields[x]&gt; &lt;x&gt;) {
         '  this.&lt;x&gt; = &lt;x&gt;;
         '}";
}

// Helper function to generate a getter
private str genGetter(map[str,str] fields, str x) {
  return "public &lt;fields[x]&gt; get&lt;capitalize(x)&gt;() {
         '  return &lt;x&gt;;
         '}";
}

// Generate a class with given name and fields.
// The field names are processed in sorted order.
str genClass(str name, map[str,str] fields) { <i class="conum" data-value="2"></i><b>(2)</b>
  return
    "public class &lt;name&gt; {
    '  &lt;for (x &lt;- sort([f | f &lt;- fields])) {&gt;
    '  private &lt;fields[x]&gt; &lt;x&gt;;
    '  &lt;genSetter(fields, x)&gt;
    '  &lt;genGetter(fields, x)&gt;&lt;}&gt;
    '}";
}

map[str, str] fields = (
     "name" : "String",
     "age" : "Integer",
     "address" : "String"
  );

str cperson =
  // Do not change a single space in the string below!
  "public class Person {
    '
    '  private String address;
    '  public void setAddress(String address) {
    '    this.address = address;
    '  }
    '  public String getAddress() {
    '    return address;
    '  }
    '  private Integer age;
    '  public void setAge(Integer age) {
    '    this.age = age;
    '  }
    '  public Integer getAge() {
    '    return age;
    '  }
    '  private String name;
    '  public void setName(String name) {
    '    this.name = name;
    '  }
    '  public String getName() {
    '    return name;
    '  }
    '}";</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>An auxiliary function <code>capitalize</code> is defined to capitalize the first character of a string.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Here is the heavy lifting done: <code>genClass</code> is defined that takes as arguments:</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Function <code>genClass</code> returns a string that contains several <em>string interpolations</em> delimited by <code>&lt;</code> and <code>&gt;</code>.
Let&#8217;s discuss some of them:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>In each line, only the text following <code>'</code> is contributed to the output. The text before (and including) <code>'</code> can be used to properly indent
the string.</p>
</li>
<li>
<p>The output of each interpolated call, like to <code>genMethod</code> is auto-indented.</p>
</li>
<li>
<p><code>public class &lt;name&gt;</code>: insert the desired class name in the result.</p>
</li>
<li>
<p><code>&lt;for x&#8592;fields){&gt;</code> &#8230;&#8203; <code>&lt;}&gt;</code>: loops over the fields and contributes the text produced by its body to the result.</p>
</li>
<li>
<p><code>private &lt;fields[x]&gt; &lt;x&gt;;</code>: finds for the current field <code>x</code> its type and produces an appropriate private field declaration.</p>
</li>
<li>
<p><code>public void set&lt;capitalize(x)&gt;(&lt;fields[x]&gt; &lt;x&gt;)</code>: method header for the setter for field <code>x</code>.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Let&#8217;s see how this works out on actual data:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-rascal-shell" data-lang="rascal-shell">rascal&gt;import demo::common::StringTemplate;
rascal2rvm: Parsing and checking |std:///demo/common/StringTemplate.rsc|
rascal2rvm: Compiling |std:///demo/common/StringTemplate.rsc|
r2mu: entering ... demo::common::StringTemplate
mu2rvm: Compiling module demo::common::StringTemplate
Compiling |std:///demo/common/StringTemplate.rsc|: check: 21, compile: 871, total: 892 ms
compile: Writing RVMModule |compressed+home:///bin-console/demo/common/StringTemplate.rvm.gz|
Removing |compressed+home:///bin-console/ConsoleInput_imports.rvm.gz|
ok
rascal&gt;import IO;
ok
rascal&gt;fields = (
&gt;&gt;&gt;&gt;&gt;&gt;&gt;     "name" : "String",
&gt;&gt;&gt;&gt;&gt;&gt;&gt;     "age" : "Integer",
&gt;&gt;&gt;&gt;&gt;&gt;&gt;     "address" : "String"
&gt;&gt;&gt;&gt;&gt;&gt;&gt;  );
map[str, str]: ("name":"String","address":"String","age":"Integer")
rascal&gt;println(genClass("Person", fields));
public class Person {

  private String address;
  public void setAddress(String address) {
    this.address = address;
  }
  public String getAddress() {
    return address;
  }
  private Integer age;
  public void setAge(Integer age) {
    this.age = age;
  }
  public Integer getAge() {
    return age;
  }
  private String name;
  public void setName(String name) {
    this.name = name;
  }
  public String getName() {
    return name;
  }
}
ok</code></pre>
</div>
</div>
<div class="ulist">
<div class="title">Benefits</div>
<ul>
<li>
<p>String templates are ideal to generate arbitrary output. In particular, no grammar is needed to describe this output.</p>
</li>
<li>
<p>Auto-indent helps to be able to compose templates from reusable parts.</p>
</li>
</ul>
</div>
<div class="ulist">
<div class="title">Pitfalls</div>
<ul>
<li>
<p>Since no grammar is used to control output, errors in generated code can only be detected by a downstream processor such as a compiler for the generated code.</p>
</li>
<li>
<p>In more complex cases, it can be better to introduce an abstract datatype to represent the desired code and to use string templates to
produce the actual textual representation of that code.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="Common-WordCount">2.8. Word Count</h3>
<div class="paragraph">
<div class="title">Synopsis</div>
<p>Counting words in strings.</p>
</div>
<div class="paragraph">
<div class="title">Examples</div>
<p>The purpose of WordCount is to count the number of <em>words</em> in a list of lines (strings).
A word is here defined as one or more letters (lowercase or uppercase), digits and the underscore character (<code>_</code>).</p>
</div>
<div class="paragraph">
<p>We split the problem in two parts:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Count the words in a single line. We explore three ways to do this in an imperative (<a href="#WordCount-CountInLine1">CountInLine1</a>], <a href="#WordCount-CountInLine2">CountInLine2</a>)
and a functional style (<a href="#WordCount-CountInLine3">CountInLine3</a>).</p>
</li>
<li>
<p>Next we apply the single line counter to all the lines.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><code>wordCount</code> is a function with two arguments:
*  A list of lines.
*  A function that returns the number of words in a line.</p>
</div>
<div class="paragraph">
<p>The main task of <code>wordCount</code> is to loop over all lines and to add the word counts per line.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-rascal" data-lang="rascal">module demo::common::WordCount::WordCount

import demo::common::WordCount::CountInLine1;
import demo::common::WordCount::CountInLine2;
import demo::common::WordCount::CountInLine3;
import demo::common::WordCount::Jabberwocky;

import String;

// wordCount takes a list of strings and a count function
// that is applied to each line. The total number of words is returned

int wordCount(list[str] input, int (str s) countInLine)
{
  count = 0;
  for(str line &lt;- input){ <i class="conum" data-value="1"></i><b>(1)</b>
     count += countInLine(line); <i class="conum" data-value="2"></i><b>(2)</b>
  }
  return count;
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>An <a href="../Rascal/Rascal.html#Comprehensions-Enumerator">enumerator</a> is used to generated all the lines in the list of lines.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>The argument function <code>countInLine</code> is applied to count the number of words in each line.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Let&#8217;s now do some experiments using the <a href="#WordCount-Jabberwocky">Jabberwocky</a> poem by Lewis Carrol as input.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-rascal-shell" data-lang="rascal-shell">rascal&gt;import demo::common::WordCount::WordCount;
rascal2rvm: Parsing and checking |std:///demo/common/WordCount/WordCount.rsc|
rascal2rvm: Compiling |std:///demo/common/WordCount/WordCount.rsc|
r2mu: entering ... demo::common::WordCount::WordCount
mu2rvm: Compiling module demo::common::WordCount::WordCount
Compiling |std:///demo/common/WordCount/WordCount.rsc|: check: 18, compile: 62, total: 80 ms
compile: Writing RVMModule |compressed+home:///bin-console/demo/common/WordCount/WordCount.rvm.gz|
rascal2rvm: Parsing and checking |std:///demo/common/WordCount/Jabberwocky.rsc|
rascal2rvm: Compiling |std:///demo/common/WordCount/Jabberwocky.rsc|
r2mu: entering ... demo::common::WordCount::Jabberwocky
mu2rvm: Compiling module demo::common::WordCount::Jabberwocky
Compiling |std:///demo/common/WordCount/Jabberwocky.rsc|: check: 7, compile: 11, total: 18 ms
compile: Writing RVMModule |compressed+home:///bin-console/demo/common/WordCount/Jabberwocky.rvm.gz|
Removing |compressed+home:///bin-console/ConsoleInput_imports.rvm.gz|
ok
rascal&gt;import demo::common::WordCount::CountInLine1;
ok
rascal&gt;import demo::common::WordCount::CountInLine2;
ok
rascal&gt;import demo::common::WordCount::CountInLine3;
ok
rascal&gt;import demo::common::WordCount::Jabberwocky;
ok
rascal&gt;wordCount(Jabberwocky, countInLine1);
int: 216
rascal&gt;wordCount(Jabberwocky, countInLine2);
int: 216
rascal&gt;wordCount(Jabberwocky, countInLine3);
int: 216</code></pre>
</div>
</div>
<div class="paragraph">
<p>It is satisfactory that the three ways of counting words all yield the same result.</p>
</div>
<div class="paragraph">
<p>If you are into one-liners, we can include everything you learned from this example
in the following alternative <code>wordCount2</code> function:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-rascal-shell" data-lang="rascal-shell">rascal&gt;int wordCount2(list[str] lines) = (0 | it + (0 | it + 1 | /\w+/ := line) | str line &lt;- lines);
ok
rascal&gt;wordCount2(Jabberwocky);
int: 216</code></pre>
</div>
</div>
<div class="paragraph">
<p>Explain what is going on in this function.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-rascal-shell" data-lang="rascal-shell"></code></pre>
</div>
</div>
<div class="sect3">
<h4 id="WordCount-CountInLine1">2.8.1. CountInLine1</h4>
<div class="paragraph">
<div class="title">Synopsis</div>
<p>Count words in a line.</p>
</div>
<div class="paragraph">
<div class="title">Examples</div>
<p>We count words using a regular expression match in a for loop.
Each time that the pattern <code>/[a-zA-Z0-9_]+/</code> matches, the body of the loop is executed
and <code>count</code> is incremented.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-rascal" data-lang="rascal">module demo::common::WordCount::CountInLine1

int countInLine1(str S){
  int count = 0;
  for(/[a-zA-Z0-9_]+/ := S){
       count += 1;
  }
  return count;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Let&#8217;s try it:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-rascal-shell" data-lang="rascal-shell">rascal&gt;import demo::common::WordCount::CountInLine1;
rascal2rvm: Parsing and checking |std:///demo/common/WordCount/CountInLine1.rsc|
rascal2rvm: Compiling |std:///demo/common/WordCount/CountInLine1.rsc|
r2mu: entering ... demo::common::WordCount::CountInLine1
mu2rvm: Compiling module demo::common::WordCount::CountInLine1
Compiling |std:///demo/common/WordCount/CountInLine1.rsc|: check: 5, compile: 15, total: 20 ms
compile: Writing RVMModule |compressed+home:///bin-console/demo/common/WordCount/CountInLine1.rvm.gz|
Removing |compressed+home:///bin-console/ConsoleInput_imports.rvm.gz|
ok
rascal&gt;countInLine1("Jabberwocky by Lewis Carroll");
int: 4</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="WordCount-CountInLine2">2.8.2. CountInLine2</h4>
<div class="paragraph">
<div class="title">Synopsis</div>
<p>Count words in a line.</p>
</div>
<div class="paragraph">
<div class="title">Examples</div>
<p>A slighly more involved manner of using regular matching in a loop.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-rascal" data-lang="rascal">module demo::common::WordCount::CountInLine2

int countInLine2(str S){
  int count = 0;

  // \w matches any word character
  // \W matches any non-word character
  // &lt;...&gt; are groups and should appear at the top level.
  while (/^\W*&lt;word:\w+&gt;&lt;rest:.*$&gt;/ := S) {
    count += 1;
    S = rest;
  }
  return count;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The pattern <code>/^\W*&lt;word:\w+&gt;&lt;rest:.*$&gt;/</code> can be understood as follows:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>The <code>^</code> makes it <em>anchored</em>, only matches at the begin of the substring <code>S</code>.</p>
</li>
<li>
<p><code>\W*</code> matches zero or more non-word characters.</p>
</li>
<li>
<p><code>&lt;word:\w+&gt;</code> matches one or more word characters and assigns the result to the variable <code>word</code>.</p>
</li>
<li>
<p><code>&lt;rest:.*$&gt;</code> matches the remaining part of <code>S</code>.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Inside the loop <code>count</code> is incremented and the new value of <code>S</code> becomes
the remainder of the current match. To summarize: each iteration
removes the first word from <code>S</code> and counts it.</p>
</div>
<div class="paragraph">
<p>Here is <code>countInLine2</code> in action:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-rascal-shell" data-lang="rascal-shell">rascal&gt;import demo::common::WordCount::CountInLine2;
rascal2rvm: Parsing and checking |std:///demo/common/WordCount/CountInLine2.rsc|
rascal2rvm: Compiling |std:///demo/common/WordCount/CountInLine2.rsc|
r2mu: entering ... demo::common::WordCount::CountInLine2
mu2rvm: Compiling module demo::common::WordCount::CountInLine2
Compiling |std:///demo/common/WordCount/CountInLine2.rsc|: check: 5, compile: 230, total: 235 ms
compile: Writing RVMModule |compressed+home:///bin-console/demo/common/WordCount/CountInLine2.rvm.gz|
Removing |compressed+home:///bin-console/ConsoleInput_imports.rvm.gz|
ok
rascal&gt;countInLine2("Jabberwocky by Lewis Carroll");
int: 4</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="WordCount-CountInLine3">2.8.3. CountInLine3</h4>
<div class="paragraph">
<div class="title">Synopsis</div>
<p>Count words in a line.</p>
</div>
<div class="paragraph">
<div class="title">Examples</div>
<p>Here is a clever, albeit rather dense, solution that illustrates several Rascal concepts.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-rascal" data-lang="rascal">module demo::common::WordCount::CountInLine3

int countInLine3(str S){
  return (0 | it + 1 | /\w+/ := S);
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>We use a <a href="../Rascal/Rascal.html#Expressions-Reducer">reducer</a> that is a recipe to reduce the values produced by one or more generators
  to a single value:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>0</code> is the initial value of the reducer</p>
</li>
<li>
<p>The pattern match <code>/\w+/ := S</code> matches all words in <code>S</code>.</p>
</li>
<li>
<p>Reduction is done by <code>it + 1</code>. In the latter <code>it</code> is a keyword that refers to the
value that has been reduced sofar. Effectively, the matches are reduced to a match count.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Let&#8217;s try it:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-rascal-shell" data-lang="rascal-shell">rascal&gt;import demo::common::WordCount::CountInLine3;
rascal2rvm: Parsing and checking |std:///demo/common/WordCount/CountInLine3.rsc|
rascal2rvm: Compiling |std:///demo/common/WordCount/CountInLine3.rsc|
r2mu: entering ... demo::common::WordCount::CountInLine3
mu2rvm: Compiling module demo::common::WordCount::CountInLine3
Compiling |std:///demo/common/WordCount/CountInLine3.rsc|: check: 5, compile: 143, total: 148 ms
compile: Writing RVMModule |compressed+home:///bin-console/demo/common/WordCount/CountInLine3.rvm.gz|
Removing |compressed+home:///bin-console/ConsoleInput_imports.rvm.gz|
ok
rascal&gt;countInLine3("Jabberwocky by Lewis Carroll");
int: 4</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="WordCount-Jabberwocky">2.8.4. Jabberwocky</h4>
<div class="paragraph">
<div class="title">Synopsis</div>
<p>Lewis Carroll&#8217;s well-known poem.</p>
</div>
<div class="listingblock">
<div class="title">Examples</div>
<div class="content">
<pre class="highlight"><code class="language-rascal" data-lang="rascal">module demo::common::WordCount::Jabberwocky

public list[str] Jabberwocky = [
	"Jabberwocky by Lewis Carroll",
	"",
	"\'Twas brillig, and the slithy toves",
	"Did gyre and gimble in the wabe;",
	"All mimsy were the borogoves,",
	"And the mome raths outgrabe.",
	"",
	"\"Beware the Jabberwock, my son!",
	"The jaws that bite, the claws that catch!",
	"Beware the Jubjub bird, and shun",
	"The frumious Bandersnatch!\"",
	"",
	"\'Twas brillig, and the slithy toves",
	"Did gyre and gimble in the wabe;",
	"All mimsy were the borogoves,",
	"And the mome raths outgrabe.",
	"",
	"\"Beware the Jabberwock, my son!",
	"The jaws that bite, the claws that catch!",
	"Beware the Jubjub bird, and shun",
	"The frumious Bandersnatch!\"",
	"",
	"He took his vorpal sword in hand:",
	"Long time the manxome foe he sought.",
	"So rested he by the Tumtum tree,",
	"And stood awhile in thought.",
	"",
	"And as in uffish thought he stood,",
	"The Jabberwock, with eyes of flame,",
	"Came whiffling through the tulgey wood",
	"And burbled as it came!",
	"",
	"One, two! One, two! and through and through",
	"The vorpal blade went snicker-snack!",
	"He left it dead, and with its head",
	"He went galumphing back.",
	"",
	"\"And hast thou slain the Jabberwock?",
	"Come to my arms, my beamish boy!",
	"O frabjous day! Callooh! Callay!",
	"He chortled in his joy.",
	"",
	"\'Twas brillig, and the slithy toves",
	"Did gyre and gimble in the wabe;",
	"All mimsy were the borogoves,",
	"And the mome raths outgrabe."
];</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="Common-WordReplacement">2.9. Word Replacement</h3>
<div class="paragraph">
<div class="title">Synopsis</div>
<p>Replace words in a string.</p>
</div>
<div class="paragraph">
<div class="title">Description</div>
<p>Suppose you are a book editor and want to ensure that all chapter
and section titles are properly capitalized. Here is how to do this.</p>
</div>
<div class="listingblock">
<div class="title">Examples</div>
<div class="content">
<pre class="highlight"><code class="language-rascal" data-lang="rascal">module demo::common::WordReplacement

import String;

// capitalize: convert first letter of a word to uppercase

str capitalize(str word) <i class="conum" data-value="1"></i><b>(1)</b>
{
   if(/^&lt;letter:[a-z]&gt;&lt;rest:.*$&gt;/ := word){
     return toUpperCase(letter) + rest;
   } else {
     return word;
   }
}

test bool capitalize1() = capitalize("1") == "1";
test bool capitalize2() = capitalize("rascal") == "Rascal";

// Capitalize all words in a string

// Version 1: capAll1: using a while loop

str capAll1(str S) <i class="conum" data-value="2"></i><b>(2)</b>
{
 result = "";
 while (/^&lt;before:\W*&gt;&lt;word:\w+&gt;&lt;after:.*$&gt;/ := S) {
    result = result + before + capitalize(word);
    S = after;
  }
  return result;
}

test bool tstCapAll1() =  capAll1("turn this into a title") == "Turn This Into A Title";

// Version 2: capAll2: using visit

str capAll2(str S) <i class="conum" data-value="3"></i><b>(3)</b>
{
   return visit(S){
   	case /^&lt;word:\w+&gt;/i =&gt; capitalize(word)
   };
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>We start by introducing a helper function <code>capitalize</code> that does the actual capitalization of a single word.
See <a href="../Rascal/Rascal.html#Patterns-Regular">Regular Pattern</a> for details about regular expression patterns.
Next we give two versions of a capitalization functions for a sentence:</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td><code>capAll1</code> uses a while loop to find subsequent words and to replace them by a capitalized version.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td><code>capAll2</code> uses a [Rascal:Visit] to visit all words in the sentence and replace them by a capitalized version.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Here are some examples:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-rascal-shell" data-lang="rascal-shell">rascal&gt;import demo::common::WordReplacement;
rascal2rvm: Parsing and checking |std:///demo/common/WordReplacement.rsc|
rascal2rvm: Compiling |std:///demo/common/WordReplacement.rsc|
r2mu: entering ... demo::common::WordReplacement
mu2rvm: Compiling module demo::common::WordReplacement
Compiling |std:///demo/common/WordReplacement.rsc|: check: 13, compile: 905, total: 918 ms
compile: Writing RVMModule |compressed+home:///bin-console/demo/common/WordReplacement.rvm.gz|
Removing |compressed+home:///bin-console/ConsoleInput_imports.rvm.gz|
ok
rascal&gt;capitalize("rascal");
str: "Rascal"
rascal&gt;capAll1("turn this into a capitalized title")
str: "Turn This Into A Capitalized Title"
rascal&gt;capAll2("turn this into a capitalized title")
str: "Turn This Into A Capitalized Title"</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="Recipes-Languages">3. Languages</h2>
<div class="sectionbody">
<div class="paragraph">
<div class="title">Synopsis</div>
<p>Definitions of several languages and their tools.</p>
</div>
<div class="paragraph">
<div class="title">Description</div>
<p>Examples of several languages and the implementation of tools like interpreters and compilers:</p>
</div>
<div class="paragraph">
<p>Other languages that we are considering (but are not yet described):</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Oberon0: a scaled down version of the Oberon language.</p>
</li>
<li>
<p>MissGrant: a state machine language.</p>
</li>
</ul>
</div>
<div class="sect2">
<h3 id="Languages-Exp">3.1. Exp</h3>
<div class="paragraph">
<div class="title">Synopsis</div>
<p>The <em>hello world</em> of syntax definition and language definition.
It illustrates how to define concrete and abstract syntax and how to use concrete and abstract patterns to evaluate expressions.</p>
</div>
<div class="paragraph">
<div class="title">Description</div>
<p>Our sample language Exp contains the following elements:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Integer constants, e.g., <code>123</code>.</p>
</li>
<li>
<p>A multiplication operator, e.g., <code>3*4</code>.</p>
</li>
<li>
<p>An addition operator, e.g., <code>3+4</code>.</p>
</li>
<li>
<p>Multiplication is left-associative and has precedence over addition.</p>
</li>
<li>
<p>Addition is left-associative.</p>
</li>
<li>
<p>Parentheses can be used to override the precedence of the operators.</p>
</li>
</ul>
</div>
<div class="ulist">
<div class="title">Examples</div>
<ul>
<li>
<p><code>123</code></p>
</li>
<li>
<p><code>2+3+4</code></p>
</li>
<li>
<p><code>2+3*4</code></p>
</li>
<li>
<p><code>(2+3)*4</code></p>
</li>
</ul>
</div>
<div class="sect3">
<h4 id="Exp-Abstract">3.1.1. Abstract</h4>
<div class="paragraph">
<div class="title">Synopsis</div>
<p>A version of Exp based on abstract syntax.</p>
</div>
<div class="paragraph">
<div class="title">Description</div>
<p>The <a href="http://en.wikipedia.org/wiki/Abstract_syntax">abstract syntax</a> for a language is a
data type that is used to represent programs in the language in an <em>abstract</em> form.
Abstract syntax has the following properties:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>It is "abstract" in the sense that it does not contain textual details such as parentheses,
layout, and the like.</p>
</li>
<li>
<p>While a language has one grammar (also known as, <em>concrete syntax</em>) it may have several abstract syntaxes
for different purposes: type analysis, code generation, etc.</p>
</li>
</ul>
</div>
<div class="paragraph">
<div class="title">Examples</div>
<p>The abstract syntax for Exp looks like this:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-rascal" data-lang="rascal">module demo::lang::Exp::Abstract::Syntax

data Exp = con(int n)          <i class="conum" data-value="1"></i><b>(1)</b>
         | mul(Exp e1, Exp e2) <i class="conum" data-value="2"></i><b>(2)</b>
         | add(Exp e1, Exp e2) <i class="conum" data-value="3"></i><b>(3)</b>
         ;</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Defines integer constants, e.g., <code>con(123)</code>.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Defines multiplication, e.g., <code>mul(con(2),con(3))</code>.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>Defines addition, e.g., <code>add(con(2),con(3))</code>.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Given the abstract syntax for Exp, we can define an interpreter that evaluates
expressions:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-rascal" data-lang="rascal">module demo::lang::Exp::Abstract::Eval
import demo::lang::Exp::Abstract::Syntax;

int eval(con(int n)) = n;                            <i class="conum" data-value="1"></i><b>(1)</b>
int eval(mul(Exp e1, Exp e2)) = eval(e1) * eval(e2); <i class="conum" data-value="2"></i><b>(2)</b>
int eval(add(Exp e1, Exp e2)) = eval(e1) + eval(e2); <i class="conum" data-value="3"></i><b>(3)</b></code></pre>
</div>
</div>
<div class="paragraph">
<p>Here we see Rascal&#8217;s <em>pattern-directed invocation</em> in action (see <a href="../Rascal/Rascal.html#Declarations-Function">Function Declaration</a>).
The essence is this: in other languages the formal parameters in a function declaration
are just that: formal parameters, i.e., single names that can be used inside the function and
that are bound when the function is called.
In Rascal, however, the formal parameters are actually a <em>pattern</em> and functions
can have arbitrarily complex patterns as (single) formal parameter.
These patterns may bind variables and thus introduce variables that can be used in tthe function body.</p>
</div>
<div class="paragraph">
<p>The big advantage of pattern-directed invocation is modularity and extensibility:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>The treatment of the cases in the abstract syntax is decoupled.</p>
</li>
<li>
<p>If the abstract is extended later on with new cases, the functions for the old cases can be reused.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>In this example we use this mechanism to define separate functions for each case in the abstract syntax.</p>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Defines the case for evaluating integer constants: they evaluate to themselves.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Defines the case for evaluating multiplication: first evaluate the arguments <code>e1</code> and <code>e2</code>
and return the multiplication of their values.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>Defines the case for evaluating addition: first evaluate the arguments <code>e1</code> and <code>e2</code>
and return the addition of their values.</td>
</tr>
</table>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-rascal-shell" data-lang="rascal-shell">rascal&gt;import demo::lang::Exp::Abstract::Syntax;
ok
rascal&gt;import demo::lang::Exp::Abstract::Eval;
ok
rascal&gt;eval(mul(con(7), con(3)));
int: 21
rascal&gt;eval(add(con(3), mul(con(4), con(5))));
int: 23</code></pre>
</div>
</div>
<div class="paragraph">
<p>Entering expressions in abstract syntax form is no fun, and this is where concrete syntax comes to the rescue.</p>
</div>
</div>
<div class="sect3">
<h4 id="Exp-Combined">3.1.2. Combined</h4>
<div class="paragraph">
<div class="title">Synopsis</div>
<p>Combine concrete syntax with abstract syntax.</p>
</div>
<div class="paragraph">
<div class="title">Description</div>
<p>Concrete syntax gives full control over the textual appearance of a language and leads to parse trees
in a standard format (i.e., values of type <code>Tree</code>).</p>
</div>
<div class="paragraph">
<p>Abstract syntax can be designed by the Rascal programmer according to his/her needs regarding
the type checking, code generation, transformation, or optimization to be done on the abstract syntax trees.</p>
</div>
<div class="paragraph">
<p>How can we bridge this gap? We discuss two approaches:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="#Combined-Manual">Manual</a>: a transformation is written manually to convert parse trees to abstract syntax trees.</p>
</li>
<li>
<p><a href="#Combined-Automatic">Automatic</a>: the library function [Rascal:implode] is used to automate this transformation.</p>
</li>
</ul>
</div>
<div class="sect4">
<h5 id="Combined-Automatic">Automatic</h5>
<div class="paragraph">
<div class="title">Synopsis</div>
<p>Use implode to translate an Exp parse tree to an abstract syntax tree.</p>
</div>
<div class="paragraph">
<div class="title">Description</div>
<p><a href="../Libraries/Libraries.html#ParseTree-implode">implode</a> is a function that automates the mapping between parse trees and abstract syntax trees.
It takes two arguments:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>The <em>reified</em> type of the desired abstract syntax. (In Rascal, types can not be used freely as values.
A reified type, is a type that is wrapped in such a way that it can be passed as an argument to a function.)</p>
</li>
<li>
<p>The parse tree to be converted.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><code>implode</code> is smart in trying to find a mapping, but it needs some guidance.
A necessary step is therefore to label the rules in the grammar with the name of the
constructor to which it has to be mapped.</p>
</div>
<div class="paragraph">
<div class="title">Examples</div>
<p>Let&#8217;s first label the syntax rules of the Exp grammar with constructor names:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-rascal" data-lang="rascal">module demo::lang::Exp::Combined::Automatic::Syntax

lexical LAYOUT = [\t-\n\r\ ];

layout LAYOUTLIST = LAYOUT*  !&gt;&gt; [\t-\n\r\ ] ;

lexical IntegerLiteral = [0-9]+;

start syntax Exp =
                   con: IntegerLiteral   <i class="conum" data-value="1"></i><b>(1)</b>
                 | bracket "(" Exp ")"
                 &gt; left mul: Exp "*" Exp <i class="conum" data-value="2"></i><b>(2)</b>
                 &gt; left add: Exp "+" Exp <i class="conum" data-value="3"></i><b>(3)</b>
                 ;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Observe that at <span class="image"><img src="../images//1.png" alt="1"></span>, <span class="image"><img src="../images//2.png" alt="2"></span> and <span class="image"><img src="../images//3.png" alt="3"></span> these labels have been added.</p>
</div>
<div class="paragraph">
<p>It is good practice to introduce separate modules for parsing and for the conversion itself:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>A <code>Parse</code> module defines a parse function and returns a parse tree. It imports only the concrete syntax.</p>
</li>
<li>
<p>A <code>Load</code> module defines a load function that first calls the above <code>parse</code> function and then applies <code>implode</code> to it.
This is the only module that imports both concrete and abstract syntax at the same time and is therefore the only place to be
concerned about name clashes. (If I mention <code>Exp</code>, do you know which one I mean?).</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Here is the <code>Parse</code> module for Exp &#8230;&#8203;</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-rascal" data-lang="rascal">module demo::lang::Exp::Combined::Automatic::Parse

import demo::lang::Exp::Combined::Automatic::Syntax;
import ParseTree;

Tree parseExp(str txt) = parse(#Exp, txt);</code></pre>
</div>
</div>
<div class="paragraph">
<p>and this is how it works:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-rascal-shell" data-lang="rascal-shell">rascal&gt;import demo::lang::Exp::Combined::Automatic::Parse;
rascal2rvm: Parsing and checking |std:///demo/lang/Exp/Combined/Automatic/Parse.rsc|
rascal2rvm: Compiling |std:///demo/lang/Exp/Combined/Automatic/Parse.rsc|
r2mu: entering ... demo::lang::Exp::Combined::Automatic::Parse
mu2rvm: Compiling module demo::lang::Exp::Combined::Automatic::Parse
Compiling |std:///demo/lang/Exp/Combined/Automatic/Parse.rsc|: check: 13, compile: 1338, total: 1351 ms
compile: Writing RVMModule |compressed+home:///bin-console/demo/lang/Exp/Combined/Automatic/Parse.rvm.gz|
rascal2rvm: Parsing and checking |std:///demo/lang/Exp/Combined/Automatic/Syntax.rsc|
rascal2rvm: Compiling |std:///demo/lang/Exp/Combined/Automatic/Syntax.rsc|
r2mu: entering ... demo::lang::Exp::Combined::Automatic::Syntax
mu2rvm: Compiling module demo::lang::Exp::Combined::Automatic::Syntax
Compiling |std:///demo/lang/Exp/Combined/Automatic/Syntax.rsc|: check: 4, compile: 12, total: 16 ms
compile: Writing RVMModule |compressed+home:///bin-console/demo/lang/Exp/Combined/Automatic/Syntax.rvm.gz|
Removing |compressed+home:///bin-console/ConsoleInput_imports.rvm.gz|
ok
rascal&gt;parseExp("2+3*4");
Exp: (Exp) `2+3*4`</code></pre>
</div>
</div>
<div class="paragraph">
<p>We can use <code>parse</code> to define <code>load</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-rascal" data-lang="rascal">module demo::lang::Exp::Combined::Automatic::Load

import demo::lang::Exp::Combined::Automatic::Parse; <i class="conum" data-value="1"></i><b>(1)</b>
import demo::lang::Exp::Abstract::Syntax; <i class="conum" data-value="2"></i><b>(2)</b>
import ParseTree; <i class="conum" data-value="3"></i><b>(3)</b>

Exp load(str txt) = implode(#Exp, parseExp(txt));</code></pre>
</div>
</div>
<div class="paragraph">
<p>Notes:</p>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>We also need the <code>parse</code> function, as defined above.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>We also need the abstract syntax as already defined earlier in [Exp/Abstract].</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>We need [Rascal:ParseTree] since it provides the [Rascal:implode] function.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Let&#8217;s try it:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-rascal-shell" data-lang="rascal-shell">rascal&gt;import demo::lang::Exp::Combined::Automatic::Load;
rascal2rvm: Parsing and checking |std:///demo/lang/Exp/Combined/Automatic/Load.rsc|
rascal2rvm: Compiling |std:///demo/lang/Exp/Combined/Automatic/Load.rsc|
r2mu: entering ... demo::lang::Exp::Combined::Automatic::Load
mu2rvm: Compiling module demo::lang::Exp::Combined::Automatic::Load
Compiling |std:///demo/lang/Exp/Combined/Automatic/Load.rsc|: check: 15, compile: 391, total: 406 ms
compile: Writing RVMModule |compressed+home:///bin-console/demo/lang/Exp/Combined/Automatic/Load.rvm.gz|
rascal2rvm: Parsing and checking |std:///demo/lang/Exp/Abstract/Syntax.rsc|
rascal2rvm: Compiling |std:///demo/lang/Exp/Abstract/Syntax.rsc|
r2mu: entering ... demo::lang::Exp::Abstract::Syntax
mu2rvm: Compiling module demo::lang::Exp::Abstract::Syntax
Compiling |std:///demo/lang/Exp/Abstract/Syntax.rsc|: check: 5, compile: 13, total: 18 ms
compile: Writing RVMModule |compressed+home:///bin-console/demo/lang/Exp/Abstract/Syntax.rvm.gz|
Removing |compressed+home:///bin-console/ConsoleInput_imports.rvm.gz|
ok
rascal&gt;load("2+3*4");
Exp: add(
  con(2)[
    @location=|unknown:///|(0,1,&lt;1,0&gt;,&lt;1,1&gt;),
    @comments=()
  ],
  mul(
    con(3)[
      @location=|unknown:///|(2,1,&lt;1,2&gt;,&lt;1,3&gt;),
      @comments=()
    ],
    con(4)[
      @location=|unknown:///|(4,1,&lt;1,4&gt;,&lt;1,5&gt;),
      @comments=()
    ])[
    @location=|unknown:///|(2,3,&lt;1,2&gt;,&lt;1,5&gt;),
    @comments=()
  ])[
  @location=|unknown:///|(0,5,&lt;1,0&gt;,&lt;1,5&gt;),
  @comments=()
]</code></pre>
</div>
</div>
<div class="paragraph">
<p>Remains the definition of the <code>eval</code> function:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-rascal" data-lang="rascal">module demo::lang::Exp::Combined::Automatic::Eval

import demo::lang::Exp::Abstract::Syntax;
import demo::lang::Exp::Abstract::Eval;
import demo::lang::Exp::Combined::Automatic::Load;

int eval(str txt) = eval(load(txt));</code></pre>
</div>
</div>
<div class="paragraph">
<p>Here is the end result:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-rascal-shell" data-lang="rascal-shell">rascal&gt;import demo::lang::Exp::Combined::Automatic::Eval;
rascal2rvm: Parsing and checking |std:///demo/lang/Exp/Abstract/Eval.rsc|
rascal2rvm: Compiling |std:///demo/lang/Exp/Abstract/Eval.rsc|
r2mu: entering ... demo::lang::Exp::Abstract::Eval
mu2rvm: Compiling module demo::lang::Exp::Abstract::Eval
Compiling |std:///demo/lang/Exp/Abstract/Eval.rsc|: check: 8, compile: 152, total: 160 ms
compile: Writing RVMModule |compressed+home:///bin-console/demo/lang/Exp/Abstract/Eval.rvm.gz|
rascal2rvm: Parsing and checking |std:///demo/lang/Exp/Combined/Automatic/Eval.rsc|
rascal2rvm: Compiling |std:///demo/lang/Exp/Combined/Automatic/Eval.rsc|
r2mu: entering ... demo::lang::Exp::Combined::Automatic::Eval
mu2rvm: Compiling module demo::lang::Exp::Combined::Automatic::Eval
Compiling |std:///demo/lang/Exp/Combined/Automatic/Eval.rsc|: check: 15, compile: 59, total: 74 ms
compile: Writing RVMModule |compressed+home:///bin-console/demo/lang/Exp/Combined/Automatic/Eval.rvm.gz|
Removing |compressed+home:///bin-console/ConsoleInput_imports.rvm.gz|
ok
rascal&gt;eval("2+3*4");
int: 14</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="Combined-Manual">Manual</h5>
<div class="paragraph">
<div class="title">Synopsis</div>
<p>An Exp evaluator that uses a manually written conversion from parse tree to abstract syntax tree.</p>
</div>
<div class="paragraph">
<div class="title">Examples</div>
<p>First we define a <code>parse</code> function for Exp:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-rascal" data-lang="rascal">module demo::lang::Exp::Combined::Manual::Parse
import demo::lang::Exp::Concrete::WithLayout::Syntax;
import ParseTree;

demo::lang::Exp::Concrete::WithLayout::Syntax::Exp
 parseExp(str txt) = parse(#Exp, txt);</code></pre>
</div>
</div>
<div class="paragraph">
<p>and test it:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-rascal-shell" data-lang="rascal-shell">rascal&gt;import demo::lang::Exp::Combined::Manual::Parse;
rascal2rvm: Parsing and checking |std:///demo/lang/Exp/Combined/Manual/Parse.rsc|
rascal2rvm: Compiling |std:///demo/lang/Exp/Combined/Manual/Parse.rsc|
r2mu: entering ... demo::lang::Exp::Combined::Manual::Parse
mu2rvm: Compiling module demo::lang::Exp::Combined::Manual::Parse
Compiling |std:///demo/lang/Exp/Combined/Manual/Parse.rsc|: check: 12, compile: 1101, total: 1113 ms
compile: Writing RVMModule |compressed+home:///bin-console/demo/lang/Exp/Combined/Manual/Parse.rvm.gz|
Removing |compressed+home:///bin-console/ConsoleInput_imports.rvm.gz|
ok
rascal&gt;parseExp("2+3");
Exp: (Exp) `2+3`</code></pre>
</div>
</div>
<div class="paragraph">
<p>Next, we define a <code>load</code> function:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-rascal" data-lang="rascal">module demo::lang::Exp::Combined::Manual::Load

import demo::lang::Exp::Concrete::WithLayout::Syntax; <i class="conum" data-value="1"></i><b>(1)</b>
import demo::lang::Exp::Abstract::Syntax; <i class="conum" data-value="2"></i><b>(2)</b>
import demo::lang::Exp::Combined::Manual::Parse; <i class="conum" data-value="3"></i><b>(3)</b>
import String;

demo::lang::Exp::Abstract::Syntax::Exp loadExp(str txt) = load(parseExp(txt)); <i class="conum" data-value="4"></i><b>(4)</b>

demo::lang::Exp::Abstract::Syntax::Exp load((Exp)`&lt;IntegerLiteral l&gt;`) <i class="conum" data-value="5"></i><b>(5)</b>
       = con(toInt("&lt;l&gt;"));
demo::lang::Exp::Abstract::Syntax::Exp load((Exp)`&lt;Exp e1&gt; * &lt;Exp e2&gt;`)
       = mul(load(e1), load(e2));
demo::lang::Exp::Abstract::Syntax::Exp load((Exp)`&lt;Exp e1&gt; + &lt;Exp e2&gt;`)
       = add(load(e1), load(e2));
demo::lang::Exp::Abstract::Syntax::Exp load((Exp)`( &lt;Exp e&gt; )`)
       = load(e);</code></pre>
</div>
</div>
<div class="paragraph">
<p>Some comments:</p>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>We reuse the previously defined concrete syntax with layout.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>We also reuse the previously defined abstract syntax.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>Import the <code>Parse</code> module defined above.</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>The top level <code>load</code> function that converts a string to an abstract syntax tree.</td>
</tr>
<tr>
<td><i class="conum" data-value="5"></i><b>5</b></td>
<td>The conversion from parse tree to abstract syntax tree start here. Note that we
explicitly use <code>demo::lang::Exp::Concrete::WithLayout::Syntax::Exp</code> in these
rules to distinguish from <code>demo::lang::Exp::Abstract::Syntax::Exp</code>.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Let&#8217;s try it:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-rascal-shell" data-lang="rascal-shell">rascal&gt;import demo::lang::Exp::Combined::Manual::Load;
rascal2rvm: Parsing and checking |std:///demo/lang/Exp/Combined/Manual/Load.rsc|
rascal2rvm: Compiling |std:///demo/lang/Exp/Combined/Manual/Load.rsc|
r2mu: entering ... demo::lang::Exp::Combined::Manual::Load
mu2rvm: Compiling module demo::lang::Exp::Combined::Manual::Load
Compiling |std:///demo/lang/Exp/Combined/Manual/Load.rsc|: check: 17, compile: 207, total: 224 ms
compile: Writing RVMModule |compressed+home:///bin-console/demo/lang/Exp/Combined/Manual/Load.rvm.gz|
Removing |compressed+home:///bin-console/ConsoleInput_imports.rvm.gz|
ok
rascal&gt;loadExp("2+3");
Exp: add(
  con(2),
  con(3))</code></pre>
</div>
</div>
<div class="paragraph">
<p>What remains is to write the interpreter using the above components:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-rascal" data-lang="rascal">module demo::lang::Exp::Combined::Manual::Eval

import demo::lang::Exp::Abstract::Syntax;
import demo::lang::Exp::Abstract::Eval;
import demo::lang::Exp::Combined::Manual::Load;

public int eval(str txt) = eval(loadExp(txt));</code></pre>
</div>
</div>
<div class="paragraph">
<p>Here is how it works:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-rascal-shell" data-lang="rascal-shell">rascal&gt;import demo::lang::Exp::Combined::Manual::Eval;
rascal2rvm: Parsing and checking |std:///demo/lang/Exp/Combined/Manual/Eval.rsc|
rascal2rvm: Compiling |std:///demo/lang/Exp/Combined/Manual/Eval.rsc|
r2mu: entering ... demo::lang::Exp::Combined::Manual::Eval
mu2rvm: Compiling module demo::lang::Exp::Combined::Manual::Eval
Compiling |std:///demo/lang/Exp/Combined/Manual/Eval.rsc|: check: 16, compile: 172, total: 188 ms
compile: Writing RVMModule |compressed+home:///bin-console/demo/lang/Exp/Combined/Manual/Eval.rvm.gz|
Removing |compressed+home:///bin-console/ConsoleInput_imports.rvm.gz|
ok
rascal&gt;eval("2+3");
int: 5</code></pre>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="Exp-Concrete">3.1.3. Concrete</h4>
<div class="paragraph">
<div class="title">Synopsis</div>
<p>Various versions of Exp based on concrete syntax.</p>
</div>
<div class="paragraph">
<div class="title">Description</div>
<p>We discuss several versions of Exp based on concrete syntax:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="#Concrete-NoLayout">No Layout</a>: is the simplest version that does not consider layout symbols in expressions.</p>
</li>
<li>
<p><a href="#Concrete-WithLayout">With Layout</a>: adds layout information to Exp&#8217;s synax definition.</p>
</li>
</ul>
</div>
<div class="sect4">
<h5 id="Concrete-NoLayout">No Layout</h5>
<div class="paragraph">
<div class="title">Synopsis</div>
<p>A version of Exp based on concrete syntax.</p>
</div>
<div class="paragraph">
<div class="title">Description</div>
<p>We describe howto write a grammar for Exp and how to use it to implement an evaluator.</p>
</div>
<div class="paragraph">
<div class="title">Examples</div>
<p>Here is the grammar for Exp:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-rascal" data-lang="rascal">module demo::lang::Exp::Concrete::NoLayout::Syntax

lexical IntegerLiteral = [0-9]+; <i class="conum" data-value="1"></i><b>(1)</b>

start syntax Exp        <i class="conum" data-value="2"></i><b>(2)</b>
  = IntegerLiteral      <i class="conum" data-value="3"></i><b>(3)</b>
  | bracket "(" Exp ")" <i class="conum" data-value="4"></i><b>(4)</b>
  &gt; left Exp "*" Exp    <i class="conum" data-value="5"></i><b>(5)</b>
  &gt; left Exp "+" Exp    <i class="conum" data-value="6"></i><b>(6)</b>
  ;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Notes:</p>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Defines a lexical syntax rule for IntegerLiterals; they consist of one or more digits.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Defines the alternatives for Exp. The keyword <code>start</code> means that this is a start symbol of the grammar.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>Defines alternative #1: an <code>IntegerLiteral</code>.</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>Defines alternative #2: parentheses. The <code>|</code> says that this alternative has the same priority as the previous one.
The keyword <code>bracket</code> marks this as an alternative that defines parentheses.</td>
</tr>
<tr>
<td><i class="conum" data-value="5"></i><b>5</b></td>
<td>Defines alternative #3: multiplication. The <code>&gt;</code> says that the previous rule has a higher priorrity than the current one.
The keyword <code>left</code> marks this as a left-associative rule.</td>
</tr>
<tr>
<td><i class="conum" data-value="6"></i><b>6</b></td>
<td>Defines alternative #4: addition. The <code>&gt;</code> says again that the previous rule has a higher priorrity than the current one.
The keyword <code>left</code> marks this as a left-associative rule.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Now that the grammar is in place we want to use it to build an evaluator. Here is how:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-rascal" data-lang="rascal">module demo::lang::Exp::Concrete::NoLayout::Eval
import demo::lang::Exp::Concrete::NoLayout::Syntax;

import String;
import ParseTree; <i class="conum" data-value="1"></i><b>(1)</b>

int eval(str txt) = eval(parse(#Exp, txt)); <i class="conum" data-value="2"></i><b>(2)</b>

int eval((Exp)`&lt;IntegerLiteral l&gt;`) = toInt("&lt;l&gt;");       <i class="conum" data-value="3"></i><b>(3)</b>
int eval((Exp)`&lt;Exp e1&gt;*&lt;Exp e2&gt;`) = eval(e1) * eval(e2); <i class="conum" data-value="4"></i><b>(4)</b>
int eval((Exp)`&lt;Exp e1&gt;+&lt;Exp e2&gt;`) = eval(e1) + eval(e2); <i class="conum" data-value="5"></i><b>(5)</b>
int eval((Exp)`(&lt;Exp e&gt;)`) = eval(e);                     <i class="conum" data-value="6"></i><b>(6)</b></code></pre>
</div>
</div>
<div class="paragraph">
<p>Notes:</p>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>We import [Rascal:ParseTree] because we will need the <code>parse</code> function below.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>The main function <code>eval</code> that evaluates an expression as string to an integer. It proceeds in two steps:</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>Converts an IntegerLiteral to an integer. Let&#8217;s dissect this further:</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>Handle the multiplication case.</td>
</tr>
<tr>
<td><i class="conum" data-value="5"></i><b>5</b></td>
<td>Handle the addition case.</td>
</tr>
<tr>
<td><i class="conum" data-value="6"></i><b>6</b></td>
<td>Handles the case of parentheses.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>What remains, is to check that <code>eval</code> works as expected.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-rascal-shell" data-lang="rascal-shell">rascal&gt;import demo::lang::Exp::Concrete::NoLayout::Syntax;
rascal2rvm: Parsing and checking |std:///demo/lang/Exp/Concrete/NoLayout/Syntax.rsc|
rascal2rvm: Compiling |std:///demo/lang/Exp/Concrete/NoLayout/Syntax.rsc|
r2mu: entering ... demo::lang::Exp::Concrete::NoLayout::Syntax
mu2rvm: Compiling module demo::lang::Exp::Concrete::NoLayout::Syntax
Compiling |std:///demo/lang/Exp/Concrete/NoLayout/Syntax.rsc|: check: 4, compile: 9, total: 13 ms
compile: Writing RVMModule |compressed+home:///bin-console/demo/lang/Exp/Concrete/NoLayout/Syntax.rvm.gz|
Removing |compressed+home:///bin-console/ConsoleInput_imports.rvm.gz|
ok
rascal&gt;import ParseTree;
ok</code></pre>
</div>
</div>
<div class="paragraph">
<p>Just checking that <code>parse</code> returns a sort of parse tree:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-rascal-shell" data-lang="rascal-shell">rascal&gt;parse(#Exp, "2+3");
Exp: (Exp) `2+3`</code></pre>
</div>
</div>
<div class="paragraph">
<p>You will see such parse trees only once, unless you are a researcher in parsing ;-)
Here is a demonstration of <code>eval</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-rascal-shell" data-lang="rascal-shell">rascal&gt;import demo::lang::Exp::Concrete::NoLayout::Eval;
rascal2rvm: Parsing and checking |std:///demo/lang/Exp/Concrete/NoLayout/Eval.rsc|
rascal2rvm: Compiling |std:///demo/lang/Exp/Concrete/NoLayout/Eval.rsc|
r2mu: entering ... demo::lang::Exp::Concrete::NoLayout::Eval
mu2rvm: Compiling module demo::lang::Exp::Concrete::NoLayout::Eval
Compiling |std:///demo/lang/Exp/Concrete/NoLayout/Eval.rsc|: check: 17, compile: 782, total: 799 ms
compile: Writing RVMModule |compressed+home:///bin-console/demo/lang/Exp/Concrete/NoLayout/Eval.rvm.gz|
Removing |compressed+home:///bin-console/ConsoleInput_imports.rvm.gz|
ok
rascal&gt;eval("2+3");
int: 5
rascal&gt;eval("2+3*4");
int: 14
rascal&gt;eval("(2+3)*4");
int: 20</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="Concrete-WithLayout">With Layout</h5>
<div class="paragraph">
<div class="title">Synopsis</div>
<p>Defines a concrete syntax for Exp with layout.</p>
</div>
<div class="paragraph">
<div class="title">Description</div>
<p>In Rascal, the major difference between lexical syntax and non-lexical syntax is that:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Strings that are parsed according to the lexical syntax <em>do not</em> contain additional layout characters
such as spaces, new lines, and source code comments.</p>
</li>
<li>
<p>Strings that are parsed according to the normal (non-lexical) syntax <em>can</em> contain layout characters between
each element.</p>
</li>
<li>
<p>Which 'layout' (whitespace and/or source code comments) will be accepted has to be defined explicitly by the grammar writer.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The following example extends the grammar for <code>Exp</code> in <a href="#Concrete-NoLayout">No Layout</a> with a layout definition:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-rascal" data-lang="rascal">module demo::lang::Exp::Concrete::WithLayout::Syntax

layout Whitespace = [\t-\n\r\ ]*; <i class="conum" data-value="1"></i><b>(1)</b>

lexical IntegerLiteral = [0-9]+;

start syntax Exp
  = IntegerLiteral
  | bracket "(" Exp ")"
  &gt; left Exp "*" Exp
  &gt; left Exp "+" Exp
  ;</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Using the <code>layout</code> definition, we defcoine that the <code>Whitespace</code> non-terminal is used <em>in between every symbol</em> of the <code>syntax</code> productions in the current module.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>And now we can use spaces in our definition of the eval function as well:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-rascal" data-lang="rascal">module demo::lang::Exp::Concrete::WithLayout::Eval
import demo::lang::Exp::Concrete::WithLayout::Syntax;

import String;
import ParseTree;

int eval(str txt) = eval(parse(#start[Exp], txt).top);

int eval((Exp)`&lt;IntegerLiteral l&gt;`) = toInt("&lt;l&gt;");
int eval((Exp)`&lt;Exp e1&gt; * &lt;Exp e2&gt;`) = eval(e1) * eval(e2);
int eval((Exp)`&lt;Exp e1&gt; + &lt;Exp e2&gt;`) = eval(e1) + eval(e2);
int eval((Exp)`( &lt;Exp e&gt; )`) = eval(e);</code></pre>
</div>
</div>
<div class="paragraph">
<p>Note that <a href="../Rascal/Rascal.html#Concepts-PatternMatching">Pattern Matching</a> will <em>ignore</em> all trees in layout positions, such that the parse tree of "1 + \\n1" will match against <code>&lt;Exp e1&gt; + &lt;Exp e2&gt;</code>. The same goes for equality on parse trees.</p>
</div>
<div class="paragraph">
<p>For the above example Rascal will insert the <code>Whitespace</code> non-terminal between every element of the syntax rules for <code>Exp</code>.
Moreover, for the start production (See <a href="#Concrete-NoLayout">No Layout</a>) <code>Whitespace</code> will be added before and after the <code>Exp</code>.</p>
</div>
<div class="paragraph">
<div class="title">Examples</div>
<p>The effect of the layout definition is that before parser generation the following grammar is derived for <code>Exp</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-rascal" data-lang="rascal">syntax Exp
  = IntegerLiteral
  | bracket "(" Whitespace Exp Whitespace ")"
  &gt; left Exp Whitespace "*" Whitespace Exp
  &gt; left Exp Whitespace "+" Whitespace Exp
  ;

syntax start[Exp] = Whitespace Exp top Whitespace;</code></pre>
</div>
</div>
<div class="paragraph">
<p>To put this all to the test:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-rascal-shell" data-lang="rascal-shell">rascal&gt;import demo::lang::Exp::Concrete::WithLayout::Syntax;
ok
rascal&gt;import demo::lang::Exp::Concrete::WithLayout::Eval;
rascal2rvm: Parsing and checking |std:///demo/lang/Exp/Concrete/WithLayout/Eval.rsc|
rascal2rvm: Compiling |std:///demo/lang/Exp/Concrete/WithLayout/Eval.rsc|
r2mu: entering ... demo::lang::Exp::Concrete::WithLayout::Eval
mu2rvm: Compiling module demo::lang::Exp::Concrete::WithLayout::Eval
Compiling |std:///demo/lang/Exp/Concrete/WithLayout/Eval.rsc|: check: 18, compile: 1867, total: 1885 ms
compile: Writing RVMModule |compressed+home:///bin-console/demo/lang/Exp/Concrete/WithLayout/Eval.rvm.gz|
Removing |compressed+home:///bin-console/ConsoleInput_imports.rvm.gz|
ok
rascal&gt;eval("2 +  3");
int: 5
rascal&gt;eval("2   +  3*4");
int: 14
rascal&gt;eval("( 2+3 )* 4");
int: 20</code></pre>
</div>
</div>
<div class="ulist">
<div class="title">Pitfalls</div>
<ul>
<li>
<p>If the grammar for <code>Exp</code> would contain an optional symbol, as in <code>syntax Exp = Exp "+"? Exp</code>, then it would be ambiguous. Does a space in "1 1", belong to the <code>Whitespace</code> before or after the missing <code>+</code>? To disambiguate the <code>layout</code> definition should be changed to <code>layout Whitespace = [\ \t\n\r]* !&gt;&gt; [\ \t\n\r]</code>. That will make sure the space goes with the first Whitespace, because even an empty Whitespace list must never be followed immediately by a space.</p>
</li>
</ul>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="Languages-Func">3.2. Func</h3>
<div class="paragraph">
<div class="title">Synopsis</div>
<p>Func is a tiny functional language; we present several interpreters for it.</p>
</div>
<div class="paragraph">
<div class="title">Description</div>
<p>Func is a functional language with the following features:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>A program consists of a number of function declarations.</p>
</li>
<li>
<p>A function declaration consists of a name, zero or more formal parameter names and an expression.</p>
</li>
<li>
<p>An expression can be one of:</p>
<div class="ulist">
<ul>
<li>
<p>an integer constant.</p>
</li>
<li>
<p>a variable.</p>
</li>
<li>
<p>arithmetic operators <code>+</code>, <code>-</code>, <code>*</code> and <code>/</code>.</p>
</li>
<li>
<p>comparison operators <code>&lt;</code>, <code>&#8656;</code>, <code>&gt;</code> and <code>&gt;=</code>.</p>
</li>
<li>
<p>a call of a function.</p>
</li>
<li>
<p>an <code>if</code> expression.</p>
</li>
<li>
<p>a sequence of expressions (<code>;</code>).</p>
</li>
<li>
<p>an assignment (<code>:=</code>).</p>
</li>
<li>
<p>a <code>let</code> expression to introduce new bindings for local variables.</p>
</li>
<li>
<p>an address of a variables (denoted by <code>&amp;</code>).</p>
</li>
<li>
<p>derefence of a variable (denoted by <code>*</code>).</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
<div class="paragraph">
<p>Some features add more complexity to an interpreter, therefore
we present four interpreters <a href="#Func-Eval0">Eval0</a>, <a href="#Func-Eval1">Eval1</a>, <a href="#Func-Eval2">Eval2</a> and <a href="#Func-Eval2">Eval2</a>
that implement increasingly complex features:</p>
</div>
<table class="tableblock frame-all grid-all spread">
<colgroup>
<col style="width: 20%;">
<col style="width: 20%;">
<col style="width: 20%;">
<col style="width: 20%;">
<col style="width: 20%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Feature</th>
<th class="tableblock halign-left valign-top">Eval0</th>
<th class="tableblock halign-left valign-top">Eval1</th>
<th class="tableblock halign-left valign-top">Eval2</th>
<th class="tableblock halign-left valign-top">Eval3</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">function declaration</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">y</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">y</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">y</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">y</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">integer constant</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">y</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">y</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">y</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">y</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">variable</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">y</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">y</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">y</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">y</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">arithmetic operators</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">y</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">y</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">y</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">y</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">comparison operators</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">y</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">y</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">y</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">y</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">call</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">y</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">y</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">y</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">y</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">if</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">y</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">y</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">y</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">y</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">let</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">y</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">y</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">y</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">sequence</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">y</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">y</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">assignment</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">y</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">y</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">address operator</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">y</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">dereference operator</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">y</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<div class="title">Examples</div>
<p>Here are several versions of the factorial function
that use more and more features of the Func language:</p>
</div>
<div class="paragraph">
<p><code>F0.func</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-rascal" data-lang="rascal">fact(n) = if n &lt;= 1 then
             1
          else
             n * fact(n-1)
          end</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>F1.func</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-rascal" data-lang="rascal">fact(n) = let
	        x = n
          in
	        if x &lt;= 1 then
	           x
	        else
		       x * fact(x-1)
	        end
	      end</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>F2.func</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-rascal" data-lang="rascal">fact(n) = if n &lt;= 1 then
             n := 1
	      else
	         n := n * fact(n-1)
	      end;
	      n</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>F3.func</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-rascal" data-lang="rascal">swap(a, b) =
          let
	        temp = *a
	      in
            *a := *b;
	        *b := temp
	      end

fact(n) = let
	        x = 1,
	        y = 0
	      in
	        if n &lt;= 1 then
	           x := 1
	        else
	           x := n * fact(n-1)
	        end;
	        swap(&amp;x, &amp;y);
	        y
	      end</code></pre>
</div>
</div>
<div class="paragraph">
<p>For convenience, we use two versions of these examples for each <em>F</em><sub>i</sub>:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>A file <em>F<sub>i</sub></em>`.func` that contains the code as shown above.</p>
</li>
<li>
<p>A file <em>F<sub>i</sub></em>`.rsc` a Rascal file that declares a string variable <em>F<sub>i</sub></em> with the same content.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>For instance, <code>F0.rsc</code> looks like this</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-rascal" data-lang="rascal">module demo::lang::Func::programs::F0

public str F0 =
"fact(n) = if n \&lt;= 1 then
             1
          else
             n * fact(n-1)
          end";</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Note the escaped <code>&lt;</code> character in <code>\&lt;=</code>. This is necessary since <code>&lt;</code> and <code>&gt;</code> are used
in strings to enclose interpolations (insertion of the value of a Rascal expression).
Both symbols need to be escaped when used as literal symbol and not as interpolation.
</td>
</tr>
</table>
</div>
<div class="sect3">
<h4 id="Func-AbstractSyntax">3.2.1. Abstract Syntax</h4>
<div class="paragraph">
<div class="title">Synopsis</div>
<p>The abstract syntax for Func.</p>
</div>
<div class="paragraph">
<div class="title">Examples</div>
<p>Here is the abstract syntax for Func:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-rascal" data-lang="rascal">module demo::lang::Func::AST

data Prog = prog(list[Func] funcs);
data Func = func(str name, list[str] formals, Exp body);

data Exp = let(list[Binding] bindings, Exp exp)
         | cond(Exp cond, Exp then, Exp otherwise)
         | var(str name)
         | nat(int nat)
         | call(str name, list[Exp] args)

         | address(str var)
         | deref(Exp exp)

         | mul(Exp lhs, Exp rhs)
         | div(Exp lhs, Exp rhs)
         | add(Exp lhs, Exp rhs)
         | sub(Exp lhs, Exp rhs)
         | gt(Exp lhs, Exp rhs)
         | lt(Exp lhs, Exp rhs)
         | geq(Exp lhs, Exp rhs)
         | leq(Exp lhs, Exp rhs)

         | seq(Exp lhs, Exp rhs)
         | assign(Exp lhs, Exp rhs);

data Binding = binding(str var, Exp exp);</code></pre>
</div>
</div>
<div class="paragraph">
<p>Observe that the abstract syntax follows the structur of the <a href="#Func-ConcreteSyntax">Concrete Syntax</a> but
omits details such as operator priorities, parentheses, and the like.</p>
</div>
</div>
<div class="sect3">
<h4 id="Func-ConcreteSyntax">3.2.2. Concrete Syntax</h4>
<div class="paragraph">
<div class="title">Synopsis</div>
<p>The concrete syntax of Func.</p>
</div>
<div class="listingblock">
<div class="title">Examples</div>
<div class="content">
<pre class="highlight"><code class="language-rascal" data-lang="rascal">module demo::lang::Func::Func

lexical Ident =  [a-zA-Z][a-zA-Z0-9]* !&gt;&gt; [a-zA-Z0-9];

lexical Natural = [0-9]+ !&gt;&gt; [0-9];

lexical LAYOUT = [\t-\n\r\ ];

layout LAYOUTLIST = LAYOUT*  !&gt;&gt; [\t-\n\r\ ] ;

start syntax Prog = prog: Func* ;

syntax Func = func: Ident name "(" {Ident ","}* ")" "=" Exp;

syntax Exp = let: "let" {Binding ","}* "in" Exp "end"
           | cond: "if" Exp "then" Exp "else" Exp "end"
           | bracket "(" Exp ")"
           | var: Ident
           | nat: Natural
           | call: Ident "(" {Exp ","}* ")"
           | address: "&amp;" Ident
           &gt; deref: "*" Exp
           &gt; non-assoc (
               left mul: Exp "*" Exp
             | non-assoc div: Exp "/" Exp
           )
           &gt; left (
               left add: Exp "+" Exp
             | left sub: Exp "-" Exp
           )
           &gt;
           non-assoc (
               non-assoc gt: Exp "\&gt;" Exp
             | non-assoc lt:  Exp "\&lt;" Exp
             | non-assoc geq:  Exp "\&gt;=" Exp
             | non-assoc leq:  Exp "\&lt;=" Exp
           )
           &gt;
           right assign: Exp ":=" Exp
           &gt;
           right seq: Exp ";" Exp;

syntax Binding = binding: Ident "=" Exp;</code></pre>
</div>
</div>
<div class="paragraph">
<p>The concrete syntax of Func uses many features of Rascal&#8217;s syntax definitions. Some notes:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>The definition of lexical syntax follows the pattern:</p>
<div class="ulist">
<ul>
<li>
<p>Define lexical symbols (<code>Ident</code>, <code>Natural</code>).</p>
</li>
<li>
<p>Define rules for layout.</p>
</li>
<li>
<p>Use follow restrictions (<code>!&gt;&gt;</code>) to enforce the longest match of lexical symbols.</p>
</li>
</ul>
</div>
</li>
<li>
<p>The definition of lexical also follows a common pattern:</p>
<div class="ulist">
<ul>
<li>
<p>List of non-terminal is defined with their alternatives.</p>
</li>
<li>
<p>One non-terminal is designated as start symbol (<code>Prog</code>).</p>
</li>
<li>
<p>Each alternative has a label, this is for the benefit of converting parse trees to abstract syntaxt trees.</p>
</li>
<li>
<p>Each alternative spells out its priority and associativity.</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="Func-Eval0">3.2.3. Eval0</h4>
<div class="paragraph">
<div class="title">Synopsis</div>
<p>A Func interpreter that does not support let-expressions and pointers.</p>
</div>
<div class="paragraph">
<div class="title">Description</div>
<p>Interpreter Eval0 supports the following features of Func:</p>
</div>
<table class="tableblock frame-all grid-all spread">
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Feature</th>
<th class="tableblock halign-left valign-top">Eval0</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">function declaration</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">y</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">integer constant</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">y</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">variable</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">y</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">arithmetic operators</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">y</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">comparison operators</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">y</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">call</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">y</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">if</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">y</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">let</p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">sequence</p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">assignment</p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">address operator</p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">dereference operator</p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<div class="title">Examples</div>
<p>Here is the code for Eval0:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-rascal" data-lang="rascal">module demo::lang::Func::Eval0

// No let

import demo::lang::Func::AST;
import List;

alias PEnv = map[str, Func]; <i class="conum" data-value="1"></i><b>(1)</b>

value eval0(str main, list[int] args, Prog prog) { <i class="conum" data-value="2"></i><b>(2)</b>
  penv = ( f.name: f | f &lt;- prog.funcs );
  f = penv[main];
  return eval0(subst(f.body, f.formals, args), penv);
}


Exp subst(Exp exp, list[str] vars, list[int] values) { <i class="conum" data-value="3"></i><b>(3)</b>
  env = ( vars[i]: values[i] | i &lt;- index(vars) );
  return visit (exp) {
    case var(str name) =&gt; nat(env[name])
  };
}

int eval0(nat(int nat), PEnv penv)  = nat; <i class="conum" data-value="4"></i><b>(4)</b>

int eval0(mul(Exp lhs, Exp rhs), PEnv penv) = eval0(lhs, penv) * eval0(rhs, penv);

int eval0(div(Exp lhs, Exp rhs), PEnv penv) = eval0(lhs, penv) / eval0(rhs, penv);

int eval0(add(Exp lhs, Exp rhs), PEnv penv) = eval0(lhs, penv) + eval0(rhs, penv);

int eval0(sub(Exp lhs, Exp rhs), PEnv penv) = eval0(lhs, penv) - eval0(rhs, penv);

int eval0(gt(Exp lhs, Exp rhs), PEnv penv) = eval0(lhs, penv) &gt; eval0(rhs, penv) ? 1 : 0;

int eval0(lt(Exp lhs, Exp rhs), PEnv penv) = eval0(lhs, penv) &lt; eval0(rhs, penv) ? 1 : 0;

int eval0(geq(Exp lhs, Exp rhs), PEnv penv) = eval0(lhs, penv) &gt;= eval0(rhs, penv) ? 1 : 0;

int eval0(leq(Exp lhs, Exp rhs), PEnv penv) = eval0(lhs, penv) &lt;= eval0(rhs, penv) ? 1 : 0;

int eval0(cond(Exp cond, Exp then, Exp otherwise), PEnv penv) =  <i class="conum" data-value="5"></i><b>(5)</b>
    (eval0(cond, penv) != 0) ? eval0(then, penv) : eval0(otherwise, penv);

int eval0(call(str name, list[Exp] args), PEnv penv) =  <i class="conum" data-value="6"></i><b>(6)</b>
    eval0(subst(penv[name].body, penv[name].formals, [ eval0(a, penv) | a &lt;- args]), penv);</code></pre>
</div>
</div>
<div class="paragraph">
<p>Some points to note:</p>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td><code>PEnv</code> is used as an alias for a map from names to functions. Such maps are used to represent the function definitions in the program.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Here the top level interpreter <code>eval0</code> is defined. It takes the name of the main function, a list of actual parameters, and the complete Func program. Binding of variables is done by substitution.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>The substitution function is defined. It takes an expression, a list of variables, and a list of integer values to be substituted for them. Note how a [Rascal:Visit] is used to find all the variables in the expression and to replace them.</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>The versions of <code>eval0</code> for each implemented construct. They all have a <code>PEnv</code> argument that is needed
to resolve calls.</td>
</tr>
<tr>
<td><i class="conum" data-value="5"></i><b>5</b></td>
<td>The if expression is defined: the then-branch is taken when the test evaluates to a non-zero integer.</td>
</tr>
<tr>
<td><i class="conum" data-value="6"></i><b>6</b></td>
<td>The call expression is interpreted. It contains the following steps:</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Let&#8217;s try this on example <code>F0</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-rascal" data-lang="rascal">fact(n) = if n &lt;= 1 then
             1
          else
             n * fact(n-1)
          end</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-rascal-shell" data-lang="rascal-shell">rascal&gt;import demo::lang::Func::Load;
ok
rascal&gt;import demo::lang::Func::Eval0;
rascal2rvm: Parsing and checking |std:///demo/lang/Func/Eval0.rsc|
rascal2rvm: Compiling |std:///demo/lang/Func/Eval0.rsc|
r2mu: entering ... demo::lang::Func::Eval0
mu2rvm: Compiling module demo::lang::Func::Eval0
Compiling |std:///demo/lang/Func/Eval0.rsc|: check: 18, compile: 1456, total: 1474 ms
compile: Writing RVMModule |compressed+home:///bin-console/demo/lang/Func/Eval0.rvm.gz|
Removing |compressed+home:///bin-console/ConsoleInput_imports.rvm.gz|
ok
rascal&gt;import demo::lang::Func::programs::F0;
ok
rascal&gt;eval0("fact", [10], load(F0));
int: 3628800</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="Func-Eval1">3.2.4. Eval1</h4>
<div class="paragraph">
<div class="title">Description</div>
<p>Interpreter Eval1 supports the following features of Func:</p>
</div>
<table class="tableblock frame-all grid-all spread">
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Feature</th>
<th class="tableblock halign-left valign-top">Eval1</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">function declaration</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">y</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">integer constant</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">y</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">variable</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">y</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">arithmetic operators</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">y</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">comparison operators</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">y</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">call</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">y</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">if</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">y</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><em>let</em></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">y</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">sequence</p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">assignment</p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">address operator</p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">dereference operator</p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>In particular, the let construct is supported and this requires the addition
of an extra environment for &lt;name, value&gt; bindings.</p>
</div>
<div class="listingblock">
<div class="title">Examples</div>
<div class="content">
<pre class="highlight"><code class="language-rascal" data-lang="rascal">module demo::lang::Func::Eval1

// using env, allowing let

import demo::lang::Func::AST;

import List;

alias Env = map[str, int];  <i class="conum" data-value="1"></i><b>(1)</b>
alias PEnv = map[str, Func];

int eval1(str main, list[int] args, Prog prog) {
  penv = ( f.name: f | f &lt;- prog.funcs );
  f = penv[main];
  env = ( f.formals[i] : args[i] | i &lt;- index(f.formals) );
  return eval1(f.body, env, penv);
}


int eval1(nat(int nat), Env env, PEnv penv)  = nat;

int eval1(var(str n), Env env, PEnv penv)  = env[n]; <i class="conum" data-value="2"></i><b>(2)</b>

int eval1(mul(Exp lhs, Exp rhs), Env env, PEnv penv) =
    eval1(lhs, env, penv) * eval1(rhs, env, penv);

int eval1(div(Exp lhs, Exp rhs), Env env, PEnv penv) =
    eval1(lhs, env, penv) / eval1(rhs, env, penv);

int eval1(add(Exp lhs, Exp rhs), Env env, PEnv penv) =
    eval1(lhs, env, penv) + eval1(rhs, env, penv);

int eval1(sub(Exp lhs, Exp rhs), Env env, PEnv penv) =
    eval1(lhs, env, penv) - eval1(rhs, env, penv);

int eval1(gt(Exp lhs, Exp rhs), Env env, PEnv penv) =
    eval1(lhs, env, penv) &gt; eval1(rhs, env, penv) ? 1 : 0;

int eval1(lt(Exp lhs, Exp rhs), Env env, PEnv penv) =
    eval1(lhs, env, penv) &lt; eval1(rhs, env, penv) ? 1 : 0;

int eval1(geq(Exp lhs, Exp rhs), Env env, PEnv penv) =
    eval1(lhs, env, penv) &gt;= eval1(rhs, env, penv) ? 1 : 0;

int eval1(leq(Exp lhs, Exp rhs), Env env, PEnv penv) =
    eval1(lhs, env, penv) &lt;= eval1(rhs, env, penv) ? 1 : 0;

int eval1(cond(Exp cond, Exp then, Exp otherwise), Env env, PEnv penv) =
    (eval1(cond, env, penv) != 0) ? eval1(then, env, penv) : eval1(otherwise, env, penv);

int eval1(call(str name, list[Exp] args), Env env, PEnv penv) {
   f = penv[name];
   env =  ( f.formals[i]: eval1(args[i], env, penv) | i &lt;- index(f.formals) );
   return eval1(f.body, env, penv);
}

int eval1(let(list[Binding] bindings, Exp exp), Env env, PEnv penv) { <i class="conum" data-value="3"></i><b>(3)</b>
   env += ( b.var : eval1(b.exp, env, penv) | b &lt;- bindings );
   return eval1(exp, env, penv);
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>The alias <code>Env</code> is introduced that maps strings to integers.
All evaluation functions get an extra Env argument.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>The environment is used to retrieve a variable&#8217;s value.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>The environment is extended with new bindings.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Let&#8217;s try this with F1:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-rascal" data-lang="rascal">fact(n) = let
	        x = n
          in
	        if x &lt;= 1 then
	           x
	        else
		       x * fact(x-1)
	        end
	      end</code></pre>
</div>
</div>
<div class="paragraph">
<p>The result:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-rascal-shell" data-lang="rascal-shell">rascal&gt;import demo::lang::Func::Load;
ok
rascal&gt;import demo::lang::Func::Eval1;
rascal2rvm: Parsing and checking |std:///demo/lang/Func/Eval1.rsc|
rascal2rvm: Compiling |std:///demo/lang/Func/Eval1.rsc|
r2mu: entering ... demo::lang::Func::Eval1
mu2rvm: Compiling module demo::lang::Func::Eval1
Compiling |std:///demo/lang/Func/Eval1.rsc|: check: 22, compile: 672, total: 694 ms
compile: Writing RVMModule |compressed+home:///bin-console/demo/lang/Func/Eval1.rvm.gz|
Removing |compressed+home:///bin-console/ConsoleInput_imports.rvm.gz|
ok
rascal&gt;import demo::lang::Func::programs::F1;
rascal2rvm: Parsing and checking |std:///demo/lang/Func/programs/F1.rsc|
rascal2rvm: Compiling |std:///demo/lang/Func/programs/F1.rsc|
r2mu: entering ... demo::lang::Func::programs::F1
mu2rvm: Compiling module demo::lang::Func::programs::F1
Compiling |std:///demo/lang/Func/programs/F1.rsc|: check: 3, compile: 12, total: 15 ms
compile: Writing RVMModule |compressed+home:///bin-console/demo/lang/Func/programs/F1.rvm.gz|
Removing |compressed+home:///bin-console/ConsoleInput_imports.rvm.gz|
ok
rascal&gt;eval1("fact", [10], load(F1));
int: 3628800</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="Func-Eval2">3.2.5. Eval2</h4>
<div class="paragraph">
<div class="title">Description</div>
<p>Interpreter Eval2 supports the following features of Func:</p>
</div>
<table class="tableblock frame-all grid-all spread">
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Feature</th>
<th class="tableblock halign-left valign-top">Eval2</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">function declaration</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">y</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">integer constant</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">y</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">variable</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">y</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">arithmetic operators</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">y</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">comparison operators</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">y</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">call</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">y</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">if</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">y</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">let</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">y</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><em>sequence</em></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">y</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><em>assignment</em></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">y</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">address operator</p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">dereference operator</p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>The main additions are local side effects and the sequence operator.</p>
</div>
<div class="listingblock">
<div class="title">Examples</div>
<div class="content">
<pre class="highlight"><code class="language-rascal" data-lang="rascal">module demo::lang::Func::Eval2

// local side effects, returning env

import demo::lang::Func::AST;

import List;

alias Env = map[str, int];
alias PEnv = map[str, Func];

alias Result2 = tuple[Env, int];  <i class="conum" data-value="1"></i><b>(1)</b>

Result2 eval2(str main, list[int] args, Prog prog) {
  penv = ( f.name: f | f &lt;- prog.funcs );
  f = penv[main];
  env = ( f.formals[i] : args[i] | i &lt;- index(f.formals) );
  return eval2(f.body, env, penv);
}

Result2 eval2(nat(int nat), Env env, PEnv penv) = &lt;env, nat&gt;;

Result2 eval2(var(str name), Env env, PEnv penv) = &lt;env, env[name]&gt;;

Result2 eval2(mul(Exp lhs, Exp rhs), Env env, PEnv penv) {  <i class="conum" data-value="2"></i><b>(2)</b>
  &lt;env, x&gt; = eval2(lhs, env, penv);
  &lt;env, y&gt; = eval2(rhs, env, penv);
  return &lt;env, x * y&gt;;
}

Result2 eval2(div(Exp lhs, Exp rhs), Env env, PEnv penv) {
  &lt;env, x&gt; = eval2(lhs, env, penv);
  &lt;env, y&gt; = eval2(rhs, env, penv);
  return &lt;env, x / y&gt;;
}

Result2 eval2(add(Exp lhs, Exp rhs), Env env, PEnv penv)  {
  &lt;env, x&gt; = eval2(lhs, env, penv);
  &lt;env, y&gt; = eval2(rhs, env, penv);
  return &lt;env, x + y&gt;;
}

Result2 eval2(sub(Exp lhs, Exp rhs), Env env, PEnv penv)  {
  &lt;env, x&gt; = eval2(lhs, env, penv);
  &lt;env, y&gt; = eval2(rhs, env, penv);
  return &lt;env, x - y&gt;;
}

Result2 eval2(gt(Exp lhs, Exp rhs), Env env, PEnv penv)  {
  &lt;env, x&gt; = eval2(lhs, env, penv);
  &lt;env, y&gt; = eval2(rhs, env, penv);
  return &lt;env, (x &gt; y) ? 1 : 0&gt;;
}

Result2 eval2(lt(Exp lhs, Exp rhs), Env env, PEnv penv)  {
  &lt;env, x&gt; = eval2(lhs, env, penv);
  &lt;env, y&gt; = eval2(rhs, env, penv);
  return &lt;env, (x &lt; y) ? 1 : 0&gt;;
}

Result2 eval2(geq(Exp lhs, Exp rhs), Env env, PEnv penv)  {
  &lt;env, x&gt; = eval2(lhs, env, penv);
  &lt;env, y&gt; = eval2(rhs, env, penv);
  return &lt;env, (x &gt;= y) ? 1 : 0&gt;;
}

Result2 eval2(leq(Exp lhs, Exp rhs), Env env, PEnv penv)  {
  &lt;env, x&gt; = eval2(lhs, env, penv);
  &lt;env, y&gt; = eval2(rhs, env, penv);
  return &lt;env, (x &lt;= y) ? 1 : 0&gt;;
}

Result2 eval2(cond(Exp cond, Exp then, Exp otherwise), Env env, PEnv penv)  {
  &lt;env, c&gt; = eval2(cond, env, penv);
  return (c != 0) ? eval2(then, env, penv) : eval2(otherwise, env, penv);
}

Result2 eval2(call(str name, list[Exp] args), Env env, PEnv penv)  {
   f = penv[name];
   for (i &lt;- index(f.formals)) {
     &lt;env, v&gt; = eval2(args[i], env, penv);
     env[f.formals[i]] = v;
   }
   return eval2(f.body, env, penv);
}

Result2 eval2(let(list[Binding] bindings, Exp exp), Env env, PEnv penv)  {
   for (b &lt;- bindings) {
     &lt;env, x&gt; = eval2(b.exp, env, penv);
     env[b.var] = x;
   }
   return eval2(exp, env, penv);
}

Result2 eval2(assign(var(str name), Exp exp), Env env, PEnv penv)  { <i class="conum" data-value="3"></i><b>(3)</b>
  &lt;env, v&gt; = eval2(exp, env, penv);
  env[name] = v;
  return &lt;env, v&gt;;
}

Result2 eval2(seq(Exp lhs, Exp rhs), Env env, PEnv penv)  {  <i class="conum" data-value="4"></i><b>(4)</b>
  &lt;env, _&gt; = eval2(lhs, env, penv);
  return eval2(rhs, env, penv);
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>The alias <code>Result</code> is introduced: a pair of an environment and an integer value.
 All evaluator functions are changed from returning an integer (the result of evaluation) to
<code>Result</code> (the result of evaluation <em>and</em> the local side effects).</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>The effect of this change can be seen in all functions. For instance, when evaluating
multiplication, the environment produced by the left operand ahs to be passed as
argument to the right operand of the multiplication. This is needed, to propagate any side effects
caused by the left operand to propagate to the right one.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>Assignment is implemented.</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>Sequencing is implemented. Observe that that the value of the left operand is ignored and that
the value of the right operand is returned.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>We apply <code>eval2</code> to example <code>F2</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-rascal" data-lang="rascal">fact(n) = if n &lt;= 1 then
             n := 1
	      else
	         n := n * fact(n-1)
	      end;
	      n</code></pre>
</div>
</div>
<div class="paragraph">
<p>Let&#8217;s try this.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-rascal-shell" data-lang="rascal-shell">rascal&gt;import demo::lang::Func::Load;
ok
rascal&gt;import demo::lang::Func::Eval2;
rascal2rvm: Parsing and checking |std:///demo/lang/Func/Eval2.rsc|
rascal2rvm: Compiling |std:///demo/lang/Func/Eval2.rsc|
r2mu: entering ... demo::lang::Func::Eval2
mu2rvm: Compiling module demo::lang::Func::Eval2
Compiling |std:///demo/lang/Func/Eval2.rsc|: check: 29, compile: 1372, total: 1401 ms
compile: Writing RVMModule |compressed+home:///bin-console/demo/lang/Func/Eval2.rvm.gz|
Removing |compressed+home:///bin-console/ConsoleInput_imports.rvm.gz|
ok
rascal&gt;import demo::lang::Func::programs::F2;
rascal2rvm: Parsing and checking |std:///demo/lang/Func/programs/F2.rsc|
rascal2rvm: Compiling |std:///demo/lang/Func/programs/F2.rsc|
r2mu: entering ... demo::lang::Func::programs::F2
mu2rvm: Compiling module demo::lang::Func::programs::F2
Compiling |std:///demo/lang/Func/programs/F2.rsc|: check: 3, compile: 9, total: 12 ms
compile: Writing RVMModule |compressed+home:///bin-console/demo/lang/Func/programs/F2.rvm.gz|
Removing |compressed+home:///bin-console/ConsoleInput_imports.rvm.gz|
ok
rascal&gt;eval2("fact", [10], load(F2));
tuple[map[str, int],int]: &lt;("n":3628800),3628800&gt;</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="Func-Eval3">3.2.6. Eval3</h4>
<div class="paragraph">
<div class="title">Description</div>
<p>Interpreter Eval3 supports the following features of Func:</p>
</div>
<table class="tableblock frame-all grid-all spread">
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Feature</th>
<th class="tableblock halign-left valign-top">Eval3</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">function declaration</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">y</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">integer constant</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">y</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">variable</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">y</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">arithmetic operators</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">y</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">comparison operators</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">y</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">call</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">y</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">if</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">y</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">let</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">y</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">sequence</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">y</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">assignment</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">y</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><em>address operator</em></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">y</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><em>dereference operator</em></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">y</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>The main additions are the address and dereference operators.</p>
</div>
<div class="listingblock">
<div class="title">Examples</div>
<div class="content">
<pre class="highlight"><code class="language-rascal" data-lang="rascal">module demo::lang::Func::Eval3

// pointers into the stack

import demo::lang::Func::AST;

import List;

alias Env = map[str, Address];
alias PEnv = map[str, Func];

alias Result3 = tuple[Mem, int];

alias Address = int;
alias Mem = list[int];

Address push(Mem mem) {
  return size(mem);
}

tuple[Mem, Address] alloc(Mem mem, int v) {
  mem += [v];
  return &lt;mem, size(mem) - 1&gt;;
}

Mem pop(Mem mem, Address scope) {
  return slice(mem, 0, scope);
}

Result3 eval3(str main, list[int] args, Prog prog) {
  penv = ( f.name: f | f &lt;- prog.funcs );
  f = penv[main];
  mem = [];
  &lt;mem, env&gt; = bind(f.formals, args, mem);
  return eval3(f.body, env, penv, mem);
}

tuple[Mem, Env] bind(list[str] fs, list[int] args, Mem mem) {
  env = ();
  for (i &lt;- index(fs)) {
    &lt;mem, a&gt; = alloc(mem, args[i]);
    env[fs[i]] = a;
  }
  return &lt;mem, env&gt;;
}

Result3 eval3(nat(int nat), Env env, PEnv penv, Mem mem) = &lt;mem, nat&gt;;

Result3 eval3(var(str name), Env env, PEnv penv, Mem mem) = &lt;mem, mem[env[name]]&gt;;


Result3 eval3(mul(Exp lhs, Exp rhs), Env env, PEnv penv, Mem mem) {
  &lt;mem, x&gt; = eval3(lhs, env, penv, mem);
  &lt;mem, y&gt; = eval3(rhs, env, penv, mem);
  return &lt;mem, x * y&gt;;
}

Result3 eval3(div(Exp lhs, Exp rhs), Env env, PEnv penv, Mem mem) {
  &lt;mem, x&gt; = eval3(lhs, env, penv, mem);
  &lt;mem, y&gt; = eval3(rhs, env, penv, mem);
  return &lt;mem, x / y&gt;;
}

Result3 eval3(add(Exp lhs, Exp rhs), Env env, PEnv penv, Mem mem) {
  &lt;mem, x&gt; = eval3(lhs, env, penv, mem);
  &lt;mem, y&gt; = eval3(rhs, env, penv, mem);
  return &lt;mem, x + y&gt;;
}

Result3 eval3(sub(Exp lhs, Exp rhs), Env env, PEnv penv, Mem mem) {
  &lt;mem, x&gt; = eval3(lhs, env, penv, mem);
  &lt;mem, y&gt; = eval3(rhs, env, penv, mem);
  return &lt;mem, x - y&gt;;
}

Result3 eval3(gt(Exp lhs, Exp rhs), Env env, PEnv penv, Mem mem) {
  &lt;mem, x&gt; = eval3(lhs, env, penv, mem);
  &lt;mem, y&gt; = eval3(rhs, env, penv, mem);
  return &lt;mem, (x &gt; y) ? 1 : 0&gt;;
}

Result3 eval3(lt(Exp lhs, Exp rhs), Env env, PEnv penv, Mem mem) {
  &lt;mem, x&gt; = eval3(lhs, env, penv, mem);
  &lt;mem, y&gt; = eval3(rhs, env, penv, mem);
  return &lt;mem, (x &lt; y) ? 1 : 0&gt;;
}

Result3 eval3(geq(Exp lhs, Exp rhs), Env env, PEnv penv, Mem mem) {
  &lt;mem, x&gt; = eval3(lhs, env, penv, mem);
  &lt;mem, y&gt; = eval3(rhs, env, penv, mem);
  return &lt;mem, (x &gt;= y) ? 1 : 0&gt;;
}

Result3 eval3(leq(Exp lhs, Exp rhs), Env env, PEnv penv, Mem mem) {
  &lt;mem, x&gt; = eval3(lhs, env, penv, mem);
  &lt;mem, y&gt; = eval3(rhs, env, penv, mem);
  return &lt;mem, (x &lt;= y) ? 1 : 0&gt;;
}

Result3 eval3(cond(Exp cond, Exp then, Exp otherwise), Env env, PEnv penv, Mem mem) {
  &lt;mem, c&gt; = eval3(cond, env, penv, mem);
  return (c != 0) ? eval3(then, env, penv, mem) : eval3(otherwise, env, penv, mem);
}

Result3 eval3(call(str name, list[Exp] args), Env env, PEnv penv, Mem mem) {
   f = penv[name];
   scope = push(mem);
   vs = for (a &lt;- args) {
     &lt;mem, v&gt; = eval3(a, env, penv, mem);
     append v;
   }
   &lt;mem, env&gt; = bind(f.formals, vs, mem);
   &lt;mem, v&gt; = eval3(f.body, env, penv, mem);
   return &lt;pop(mem, scope), v&gt;;
}

Result3 eval3(address(str var), Env env, PEnv penv, Mem mem) = &lt;mem, env[var]&gt;;

Result3 eval3(deref(Exp exp), Env env, PEnv penv, Mem mem) {
  &lt;mem, v&gt; = eval3(exp, env, penv, mem);
  return &lt;mem, mem[v]&gt;;
}

Result3 eval3(let(list[Binding] bindings, Exp exp), Env env, PEnv penv, Mem mem) {
   scope = push(mem);
   for (b &lt;- bindings) {
     &lt;mem, v&gt; = eval3(b.exp, env, penv, mem);
     &lt;mem, a&gt; = alloc(mem, v);
     env[b.var] = a;
   }
   &lt;mem, v&gt; = eval3(exp, env, penv, mem);
   return &lt;pop(mem, scope), v&gt;;
}

Result3 eval3(seq(Exp lhs, Exp rhs), Env env, PEnv penv, Mem mem) {
  &lt;mem, _&gt; = eval3(lhs, env, penv, mem);
  return eval3(rhs, env, penv, mem);
}

Result3 eval3(assign(var(str name), Exp e), Env env, PEnv penv, Mem mem) {
  &lt;mem, v&gt; = eval3(e, env, penv, mem);
  mem[env[name]] = v;
  return &lt;mem, v&gt;;
}

Result3 eval3(assign(deref(Exp lvalue), Exp e), Env env, PEnv penv, Mem mem) {
  &lt;mem, addr&gt; = eval3(lvalue, env, penv, mem);
  &lt;mem, v&gt; = eval3(e, env, penv, mem);
  mem[addr] = v;
  return &lt;mem, v&gt;;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>We apply <code>eval3</code> to example <code>F3</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-rascal" data-lang="rascal">swap(a, b) =
          let
	        temp = *a
	      in
            *a := *b;
	        *b := temp
	      end

fact(n) = let
	        x = 1,
	        y = 0
	      in
	        if n &lt;= 1 then
	           x := 1
	        else
	           x := n * fact(n-1)
	        end;
	        swap(&amp;x, &amp;y);
	        y
	      end</code></pre>
</div>
</div>
<div class="paragraph">
<p>Let&#8217;s try this.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-rascal-shell" data-lang="rascal-shell">rascal&gt;import demo::lang::Func::Load;
ok
rascal&gt;import demo::lang::Func::Eval3;
rascal2rvm: Parsing and checking |std:///demo/lang/Func/Eval3.rsc|
rascal2rvm: Compiling |std:///demo/lang/Func/Eval3.rsc|
r2mu: entering ... demo::lang::Func::Eval3
mu2rvm: Compiling module demo::lang::Func::Eval3
Compiling |std:///demo/lang/Func/Eval3.rsc|: check: 40, compile: 1210, total: 1250 ms
compile: Writing RVMModule |compressed+home:///bin-console/demo/lang/Func/Eval3.rvm.gz|
Removing |compressed+home:///bin-console/ConsoleInput_imports.rvm.gz|
ok
rascal&gt;import demo::lang::Func::programs::F3;
rascal2rvm: Parsing and checking |std:///demo/lang/Func/programs/F3.rsc|
rascal2rvm: Compiling |std:///demo/lang/Func/programs/F3.rsc|
r2mu: entering ... demo::lang::Func::programs::F3
mu2rvm: Compiling module demo::lang::Func::programs::F3
Compiling |std:///demo/lang/Func/programs/F3.rsc|: check: 4, compile: 11, total: 15 ms
compile: Writing RVMModule |compressed+home:///bin-console/demo/lang/Func/programs/F3.rvm.gz|
Removing |compressed+home:///bin-console/ConsoleInput_imports.rvm.gz|
ok
rascal&gt;eval3("fact", [10], load(F3));
ParseError(|unknown:///|(111,1,&lt;9,0&gt;,&lt;9,1&gt;))
No call stack available

ok</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="Func-LoadAST">3.2.7. Load AST</h4>
<div class="paragraph">
<div class="title">Synopsis</div>
<p>Parse Func program from string or file and convert to an abstract syntax tree.</p>
</div>
<div class="paragraph">
<div class="title">Description</div>
<p>To simplify later processing, Func programs are converted to an abstract syntax tree.</p>
</div>
<div class="paragraph">
<div class="title">Examples</div>
<p>The concrete syntax for Func is described in <a href="#Func-ConcreteSyntax">Concrete Syntax</a> and its
abstract syntax in <a href="#Func-AbstractSyntax">Abstract Syntax</a>.
Rather than manually writing conversion rules from Func parse trees to Func abstract syntax trees
we use our secret weapon: <a href="../Libraries/Libraries.html#PareTree-implode">implode</a> that performs the mapping for us.
As you see when you compare the concrete and abstract syntax, the ground work has already been done
by appropriately labelling concrete rules with constructor names of the abstract syntax.</p>
</div>
<div class="paragraph">
<p>Here is the code for the <code>load</code> funcion:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-rascal" data-lang="rascal">module demo::lang::Func::Load

import demo::lang::Func::Func;
import demo::lang::Func::AST;
import demo::lang::Func::Parse;

import ParseTree;

demo::lang::Func::AST::Prog implode(demo::lang::Func::Func::Prog p) =
    implode(#demo::lang::Func::AST::Prog, p);

demo::lang::Func::AST::Prog load(loc l) = implode(parse(l));
demo::lang::Func::AST::Prog load(str s) = implode(parse(s));</code></pre>
</div>
</div>
<div class="paragraph">
<p>This looks simple but also slightly intimidating due to the many qualified names.
The issue is that the names in the concrete and abstract syntax are (on purpose) overloaded.
A name like <code>Prog</code> can be the one from the concrete syntax(i.e., <code>demo::lang::Func::Func::Prog</code>)
or the one from the abstract syntax (i.e., <code>demo::lang::Func::AST::Prog</code>).</p>
</div>
<div class="paragraph">
<p>For instance, the local version of <code>implode</code> defined here get a concrete <code>Prog</code> as argument and returns an abstract one.
Both <code>load</code> function return an abstract <code>Prog</code>.</p>
</div>
<div class="paragraph">
<p>Let&#8217;s try this on example <code>F0</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-rascal" data-lang="rascal">fact(n) = if n &lt;= 1 then
             1
          else
             n * fact(n-1)
          end</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-rascal-shell" data-lang="rascal-shell">rascal&gt;import demo::lang::Func::Load;
rascal2rvm: Parsing and checking |std:///demo/lang/Func/AST.rsc|
rascal2rvm: Compiling |std:///demo/lang/Func/AST.rsc|
r2mu: entering ... demo::lang::Func::AST
mu2rvm: Compiling module demo::lang::Func::AST
Compiling |std:///demo/lang/Func/AST.rsc|: check: 6, compile: 13, total: 19 ms
compile: Writing RVMModule |compressed+home:///bin-console/demo/lang/Func/AST.rvm.gz|
rascal2rvm: Parsing and checking |std:///demo/lang/Func/Func.rsc|
rascal2rvm: Compiling |std:///demo/lang/Func/Func.rsc|
r2mu: entering ... demo::lang::Func::Func
mu2rvm: Compiling module demo::lang::Func::Func
Compiling |std:///demo/lang/Func/Func.rsc|: check: 7, compile: 23, total: 30 ms
compile: Writing RVMModule |compressed+home:///bin-console/demo/lang/Func/Func.rvm.gz|
rascal2rvm: Parsing and checking |std:///demo/lang/Func/Load.rsc|
rascal2rvm: Compiling |std:///demo/lang/Func/Load.rsc|
r2mu: entering ... demo::lang::Func::Load
mu2rvm: Compiling module demo::lang::Func::Load
Compiling |std:///demo/lang/Func/Load.rsc|: check: 16, compile: 405, total: 421 ms
compile: Writing RVMModule |compressed+home:///bin-console/demo/lang/Func/Load.rvm.gz|
rascal2rvm: Parsing and checking |std:///demo/lang/Func/Parse.rsc|
rascal2rvm: Compiling |std:///demo/lang/Func/Parse.rsc|
r2mu: entering ... demo::lang::Func::Parse
mu2rvm: Compiling module demo::lang::Func::Parse
Compiling |std:///demo/lang/Func/Parse.rsc|: check: 19, compile: 521, total: 540 ms
compile: Writing RVMModule |compressed+home:///bin-console/demo/lang/Func/Parse.rvm.gz|
Removing |compressed+home:///bin-console/ConsoleInput_imports.rvm.gz|
ok
rascal&gt;import demo::lang::Func::programs::F0;
rascal2rvm: Parsing and checking |std:///demo/lang/Func/programs/F0.rsc|
rascal2rvm: Compiling |std:///demo/lang/Func/programs/F0.rsc|
r2mu: entering ... demo::lang::Func::programs::F0
mu2rvm: Compiling module demo::lang::Func::programs::F0
Compiling |std:///demo/lang/Func/programs/F0.rsc|: check: 3, compile: 11, total: 14 ms
compile: Writing RVMModule |compressed+home:///bin-console/demo/lang/Func/programs/F0.rvm.gz|
Removing |compressed+home:///bin-console/ConsoleInput_imports.rvm.gz|
ok
rascal&gt;load(F0);
Prog: prog([func(
      "fact",
      ["n"],
      cond(
        leq(
          var("n")[
            @location=|unknown:///|(13,1,&lt;1,13&gt;,&lt;1,14&gt;),
            @comments=()
          ],
          nat(1)[
            @location=|unknown:///|(18,1,&lt;1,18&gt;,&lt;1,19&gt;),
            @comments=()
          ])[
          @location=|unknown:///|(13,6,&lt;1,13&gt;,&lt;1,19&gt;),
          @comments=()
        ],
        nat(1)[
          @location=|unknown:///|(38,1,&lt;2,13&gt;,&lt;2,14&gt;),
          @comments=()
        ],
        mul(
          var("n")[
            @location=|unknown:///|(70,1,&lt;4,13&gt;,&lt;4,14&gt;),
            @comments=()
          ],
          call(
            "fact",
            [sub(
                var("n")[
                  @location=|unknown:///|(79,1,&lt;4,22&gt;,&lt;4,23&gt;),
                  @comments=()
                ],
                nat(1)[
                  @location=|unknown:///|(81,1,&lt;4,24&gt;,&lt;4,25&gt;),
                  @comments=()
                ])[
                @location=|unknown:///|(79,3,&lt;4,22&gt;,&lt;4,25&gt;),
                @comments=()
              ]])[
            @location=|unknown:///|(74,9,&lt;4,17&gt;,&lt;4,26&gt;),
            @comments=()
          ])[
          @location=|unknown:///|(70,13,&lt;4,13&gt;,&lt;4,26&gt;),
          @comments=()
        ])[
        @location=|unknown:///|(10,87,&lt;1,10&gt;,&lt;5,13&gt;),
        @comments=()
      ])[
      @location=|unknown:///|(0,97,&lt;1,0&gt;,&lt;5,13&gt;),
      @comments=()
    ]])[
  @location=|unknown:///|(0,97,&lt;1,0&gt;,&lt;5,13&gt;),
  @comments=()
]</code></pre>
</div>
</div>
<div class="paragraph">
<p>We get the original program and its <em>abstract syntax tree</em> of type <code>Prog</code> back.
In case of doubt, compare this with the result in <a href="#Func-Parse">Parse</a> where we did obtain a parse tree.
Next, we try the same from a file:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-rascal-shell" data-lang="rascal-shell">rascal&gt;load(|std:///demo/lang/Func/programs/F0.func|);
Prog: prog([func(
      "fact",
      ["n"],
      cond(
        leq(
          var("n")[
            @location=|std:///demo/lang/Func/programs/F0.func|(13,1,&lt;1,13&gt;,&lt;1,14&gt;),
            @comments=()
          ],
          nat(1)[
            @location=|std:///demo/lang/Func/programs/F0.func|(18,1,&lt;1,18&gt;,&lt;1,19&gt;),
            @comments=()
          ])[
          @location=|std:///demo/lang/Func/programs/F0.func|(13,6,&lt;1,13&gt;,&lt;1,19&gt;),
          @comments=()
        ],
        nat(1)[
          @location=|std:///demo/lang/Func/programs/F0.func|(38,1,&lt;2,13&gt;,&lt;2,14&gt;),
          @comments=()
        ],
        mul(
          var("n")[
            @location=|std:///demo/lang/Func/programs/F0.func|(70,1,&lt;4,13&gt;,&lt;4,14&gt;),
            @comments=()
          ],
          call(
            "fact",
            [sub(
                var("n")[
                  @location=|std:///demo/lang/Func/programs/F0.func|(79,1,&lt;4,22&gt;,&lt;4,23&gt;),
                  @comments=()
                ],
                nat(1)[
                  @location=|std:///demo/lang/Func/programs/F0.func|(81,1,&lt;4,24&gt;,&lt;4,25&gt;),
                  @comments=()
                ])[
                @location=|std:///demo/lang/Func/programs/F0.func|(79,3,&lt;4,22&gt;,&lt;4,25&gt;),
                @comments=()
              ]])[
            @location=|std:///demo/lang/Func/programs/F0.func|(74,9,&lt;4,17&gt;,&lt;4,26&gt;),
            @comments=()
          ])[
          @location=|std:///demo/lang/Func/programs/F0.func|(70,13,&lt;4,13&gt;,&lt;4,26&gt;),
          @comments=()
...</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="Func-Parse">3.2.8. Parse</h4>
<div class="paragraph">
<div class="title">Synopsis</div>
<p>Parse a Func program from a string or a file.</p>
</div>
<div class="paragraph">
<div class="title">Description</div>
<p>Parsing uses the syntax rules for a given start non-terminnal to parse a string and turn it into a parse tree.
The work horse is the <a href="../Libraries/Libraries.html#ParseTree-parse">parse</a> function that is available in the
<a href="../Libraries/Libraries.html#Prelude-ParseTree">PareTree</a> library.</p>
</div>
<div class="paragraph">
<div class="title">Examples</div>
<p>Here is how to parse Func programs from a string or file:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-rascal" data-lang="rascal">module demo::lang::Func::Parse

import demo::lang::Func::Func;
import ParseTree;

Prog parse(loc l) = parse(#Prog, l);
Prog parse(str s) = parse(#Prog, s);</code></pre>
</div>
</div>
<div class="paragraph">
<p>Let&#8217;s try this on example <code>F0.func</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-rascal" data-lang="rascal">fact(n) = if n &lt;= 1 then
             1
          else
             n * fact(n-1)
          end</code></pre>
</div>
</div>
<div class="paragraph">
<p>First, we try the version with a string argument:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-rascal-shell" data-lang="rascal-shell">rascal&gt;import demo::lang::Func::Parse;
ok
rascal&gt;import demo::lang::Func::programs::F0;
ok
rascal&gt;parse(F0);
Prog: (Prog) `fact(n) = [35mif[39m n &lt;= 1 [35mthen[39m
             1
          [35melse[39m
             n * fact(n[35m-[39m1)
          [35mend[39m`</code></pre>
</div>
</div>
<div class="paragraph">
<p>This must be defined as success: we get the original program and its parse tree back.
Next, we try the same from a file. We use the scheme <code>std</code> that refers to files that reside in the Rascal library.
See [$Rascal:Expressions/Values/Location] for further details on other schemes.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-rascal-shell" data-lang="rascal-shell">rascal&gt;parse(|std:///demo/lang/Func/programs/F0.func|);
Prog: (Prog) `fact(n) = [35mif[39m n &lt;= 1 [35mthen[39m
             1
          [35melse[39m
             n * fact(n[35m-[39m1)
          [35mend[39m`</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="Languages-Lisra">3.3. Lisra</h3>
<div class="paragraph">
<div class="title">Synopsis</div>
<p>A lisp interpreter in Rascal.</p>
</div>
<div class="paragraph">
<div class="title">Description</div>
<p>Writing a Lisp interpreter is a classical challenge.
Popular word has that all large applications evolve until they include a Lisp interpreter.
(A variant says the same about including an email client in every large application).</p>
</div>
<div class="paragraph">
<p>We will closely follow and <strong>reuse parts of</strong> Peter Norvig&#8217;s excellent page
on <a href="http://norvig.com/lispy.html">Lispy</a>, a Lisp interpreter written in Python.
The Lisp variant to be implemented is the following subset of the <a href="http://en.wikipedia.org/wiki/Scheme_(programming_language)">Scheme</a>
 language:</p>
</div>
<table class="tableblock frame-all grid-all spread">
<colgroup>
<col style="width: 20%;">
<col style="width: 20%;">
<col style="width: 60%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Form</th>
<th class="tableblock halign-left valign-top">Syntax</th>
<th class="tableblock halign-left valign-top">Semantics and Example</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="http://www.schemers.org/Documents/Standards/R5RS/HTML/r5rs-Z-H-7.html#%_sec_4.1.1">variable reference</a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><em>var</em></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">A symbol is interpreted as a variable name;
  its value is the variable&#8217;s
  value. Example: <code>x</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="http://www.schemers.org/Documents/Standards/R5RS/HTML/r5rs-Z-H-7.html#%_sec_4.1.2">constant literal</a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><em>number</em></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">A number evaluates to itself. Example: <code>12</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="http://www.schemers.org/Documents/Standards/R5RS/HTML/r5rs-Z-H-7.html#%_sec_4.1.2">quotation</a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(quote <em>exp</em>)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Return the <em>exp</em> literally; do not evaluate it. Example:
  <code>(quote (a b c)) &#8658;; (a b c)</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="http://www.schemers.org/Documents/Standards/R5RS/HTML/r5rs-Z-H-7.html#%_sec_4.1.5">conditional</a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(if <em>test conseq alt</em>)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Evaluate <em>test</em>; if true,
  evaluate and return <em>conseq</em>; otherwise evaluate and return
  <em>alt</em>. &lt;br&gt;Example: <code>(if (&lt; 10 20) (+ 1 1) (+ 3 3)) &#8658; 2</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="http://www.schemers.org/Documents/Standards/R5RS/HTML/r5rs-Z-H-7.html#%_sec_4.1.6">assignment</a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(set! <em>var exp</em>)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Evaluate <em>exp</em> and assign that value to
  <em>var</em>, which must have been previously defined (with a
  <code>define</code> or as a parameter to an enclosing procedure).
   Example: <code>(set! x2 (* x x))</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="http://www.schemers.org/Documents/Standards/R5RS/HTML/r5rs-Z-H-8.html#%_sec_5.2">definition</a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(define <em>var</em> <em>exp</em>)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Define a new variable in the innermost environment and give it
  the value of evaluating the expression <em>exp</em>.
  Examples: <code>(define r 3)</code> <em>or</em> <code>(define square (lambda (x) (* x x)))</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="http://www.schemers.org/Documents/Standards/R5RS/HTML/r5rs-Z-H-7.html#%_sec_4.1.4">procedure</a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(lambda (<em>var&#8230;&#8203;</em>) <em>exp</em>)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Create a procedure
  with parameter(s) named <em>var&#8230;&#8203;</em> and the expression as the body.
  Example: <code>(lambda (r) (* r r))</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="http://www.schemers.org/Documents/Standards/R5RS/HTML/r5rs-Z-H-7.html#%_sec_4.2.3">sequencing</a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(begin <em>exp&#8230;&#8203;</em>)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Evaluate each of the expressions in left-to-right order, and return the final value.
  Example: `(begin (set! x 1) (set! x (+ x 1)) (* x 2)) &#8658; 4</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="http://www.schemers.org/Documents/Standards/R5RS/HTML/r5rs-Z-H-7.html#%_sec_4.1.3">procedure call</a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(<em>proc exp&#8230;&#8203;</em>)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">If <em>proc</em> is
   anything other than one of the symbols <code>if</code>, <code>set!</code>, <code>define</code>,
   <code>lambda</code>, <code>begin</code>, or <code>quote</code> then it is treated as a procedure.  It is
   evaluated using the same rules defined here. All the expressions
   are evaluated as well, and then the procedure is called with the list
   of expressions as arguments.
   Example: &lt;`(square 12) &#8658; 144</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>In this table, <em>var</em> must be a symbol&#8212;&#8203;an identifier such as x or square&#8212;&#8203;and number must be an integer number,
while the other italicized words can be any expression. The notation <em>exp</em>&#8230;&#8203; means zero or more repetitions of <em>exp</em>.</p>
</div>
<div class="paragraph">
<p>A Lisp interpreter consists of the following parts:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>A <em>parser</em> that reads a Lisp program in text form and converts it to a runtime representation that is suitable for the interpreter.</p>
</li>
<li>
<p>The <em>interpreter</em> itself that executes the program in runtime representation and computes its outcome.</p>
</li>
<li>
<p>A <em>pretty printer</em> that converts the outcome in internal representation back to text.</p>
</li>
<li>
<p>Finally, an interactive  <em>console</em> is needed that interact with the user.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>We discuss all these aspects:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="#Lisra-Syntax">Syntax</a>: The textual syntax of Lisp.</p>
</li>
<li>
<p><a href="#Lisra-Runtime">Runtime</a>: The runtime representation of Lisp programs and data.</p>
</li>
<li>
<p><a href="#Lisra-Parse">Parse</a>: Parsing a Lisp expression.</p>
</li>
<li>
<p><a href="#Lisra-Pretty">Pretty</a>: A Lisp pretty printer.</p>
</li>
<li>
<p><a href="#Lisra-Eval">Eval</a>: A Lisp interpreter.</p>
</li>
<li>
<p><a href="#Lisra-Test">Test</a>: Tests for the Lisp interpreter.</p>
</li>
</ul>
</div>
<div class="sect3">
<h4 id="Lisra-Syntax">3.3.1. Syntax</h4>
<div class="paragraph">
<div class="title">Synopsis</div>
<p>The textual syntax of Lisp.</p>
</div>
<div class="paragraph">
<div class="title">Description</div>
<p>The first step in defining Lisp&#8217;s textual format, we define a grammar for it:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-rascal" data-lang="rascal">module demo::lang::Lisra::Syntax

layout Whitespace      = [\t-\n\r\ ]*;
lexical IntegerLiteral = [0-9]+ !&gt;&gt; [0-9];
lexical AtomExp        = (![0-9()\t-\n\r\ ])+ !&gt;&gt;  ![0-9()\t-\n\r\ ];

start syntax LispExp            // TODO: remove constructor names (needed for compiler)
      = int_lit: IntegerLiteral
      | atom_exp: AtomExp
      | par_exp: "(" LispExp* ")"
      ;</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>Whitespace</code> defines the characters that can be ignored between tokens.</p>
</div>
<div class="paragraph">
<p><code>IntegerLiteral</code> defines integer constants. In a first approximation <code>[0-9]</code> is enough.
However, to ensure that the longest possible sequence of digits is used, the <code>!&gt;&gt; [0-9]</code> part
ensures that an integer cannot be followed by another digit.</p>
</div>
<div class="paragraph">
<p><code>AtomExp</code> defines a Lisp symbol that may contain a wide range of characters (except layout and digits).</p>
</div>
<div class="paragraph">
<p>The main syntactic concept is a <code>LispExp</code> that may be an <code>IntegerLiteral</code>, <code>AtomExp</code> or a list
of `LispExp`s surrouned by parentheses.</p>
</div>
<div class="paragraph">
<div class="title">Examples</div>
<p>This grammar is demonstrated in <a href="#Lisra-Parse">Parse</a>.</p>
</div>
</div>
<div class="sect3">
<h4 id="Lisra-Runtime">3.3.2. Runtime</h4>
<div class="paragraph">
<div class="title">Synopsis</div>
<p>The runtime representation of Lisp programs and data.</p>
</div>
<div class="paragraph">
<div class="title">Description</div>
<p>There are several aspects of the runtime representation of Lisp programs and Lisp data
that have to be described:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>The representation of values (see <code>Lval</code> below).</p>
</li>
<li>
<p>The handling of the <em>scope</em> of variables (see <code>Scope</code>, <code>Env</code>, <code>makeEnv</code> and <code>find</code> below).</p>
</li>
<li>
<p>The way the interpreter returns its results (see <code>Result</code> below).</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-rascal" data-lang="rascal">module demo::lang::Lisra::Runtime

import Prelude;

data Lval <i class="conum" data-value="1"></i><b>(1)</b>
     = Integer(int n)
     | Atom(str name)
     | List(list[Lval] elms)
     | Closure(Result(list[Lval] args, Env env))
     ;

alias Scope  = map[Lval,Lval]; <i class="conum" data-value="2"></i><b>(2)</b>
alias Env    = list[Scope];

public Env emptyEnv = [()];

Env makeEnv(list[Lval] vars, list[Lval] values, Env outer) = <i class="conum" data-value="3"></i><b>(3)</b>
   [(vars[i] : values[i] | i &lt;- index(vars))] + outer;

int find(Lval sym, Env e){ <i class="conum" data-value="4"></i><b>(4)</b>
   for(n &lt;- index(e))
       if(e[n][sym]?)
          return n;
   return -1;
}

public Lval TRUE  = Atom("#t"); <i class="conum" data-value="5"></i><b>(5)</b>
public Lval FALSE = Atom("#f");

alias Result = tuple[Lval val, Env env]; <i class="conum" data-value="6"></i><b>(6)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>The data type <code>Lval</code> takes care of the representation of Lisp values.
It covers integers, atoms, lists and closures (the representation of a functions and
the context in which it will be executed).</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>A <code>Scope</code> describes the binding of several related variables to their value.
 Since scopes may be nested, an environment (<code>Env</code>) consisted of a list of scope.
The most inner scope is at the start of the list and the most global one at the end.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>Creating a new scope is done by <code>makeEnv</code> which takes a list of variables
(represented by <code>Lval`s, in most cases this will be an atom like `Atom("X")</code>),
a list of values and creates a new scope in front of the current environment.</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>The function <code>find</code> tries to locate the scope in which a name was previously defined.
 It searches the nested scopes inside-out and returns the <em>index</em> in the given environment
of the scope in which the name is defined, or <code>-1</code> if it is not found.</td>
</tr>
<tr>
<td><i class="conum" data-value="5"></i><b>5</b></td>
<td>We define useful constants for true and false (the atoms <code>#t</code> and <code>#f</code>, respectively).</td>
</tr>
<tr>
<td><i class="conum" data-value="6"></i><b>6</b></td>
<td>Finally, we define <code>Result</code> as a tuple of an <code>Lval</code> and an <code>Env</code>.
Each step during interpretation will thus return the value it computed and
a possibly modified environment.</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="Lisra-Parse">3.3.3. Parse</h4>
<div class="paragraph">
<div class="title">Synopsis</div>
<p>Parsing a Lisp expression.</p>
</div>
<div class="paragraph">
<div class="title">Description</div>
<p>Given the Lisp <a href="#Lisra-Syntax">Syntax</a>, we can now apply it to parse textual Lisp expressions
and convert them to the runtime representation <code>Lval</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-rascal" data-lang="rascal">module demo::lang::Lisra::Parse

import Prelude;
import demo::lang::Lisra::Syntax;
import demo::lang::Lisra::Runtime;

Lval parse(str txt) = build(parse(#LispExp, txt)); <i class="conum" data-value="1"></i><b>(1)</b>

// Build Abstract Synax Tree: Transform a LispExp to an Lval

Lval build((LispExp)`&lt;IntegerLiteral il&gt;`) = Integer(toInt("&lt;il&gt;"));      <i class="conum" data-value="2"></i><b>(2)</b>
Lval build((LispExp)`&lt;AtomExp at&gt;`)        = Atom("&lt;at&gt;");                <i class="conum" data-value="3"></i><b>(3)</b>
Lval build((LispExp)`( &lt;LispExp* lst&gt; )`)  = List([build(l) | l &lt;- lst]); <i class="conum" data-value="4"></i><b>(4)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>First we define the actual <code>parse</code> function: it takes a string as argument and returns an <code>Lval</code>.
It proceeds in two steps:</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Function <code>build</code> is defined in cases, to handle the various parse tree forms.
Fortunately, we do not have to spell out the details of the parse tree, but we can use concrete
patterns instead (see <a href="#Concrete Patterns">[Concrete Patterns]</a>, below).</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>The text of the atom is reconstructed in a similar fashion.</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>The concrete list elements in <code>lst</code> are converted one-by-one using build and are then used to
create a new <code>List</code> value.</td>
</tr>
</table>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">Concrete Patterns</div>
<div class="paragraph">
<p>We use concrete patterns in these definitions. For instance, the argument pattern</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-rascal" data-lang="rascal">(LispExp)`&lt;IntegerLiteral il&gt;`</code></pre>
</div>
</div>
<div class="paragraph">
<p>says:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Match something of type <code>LispExp</code>.</p>
</li>
<li>
<p>It should be an <code>IntegerLiteral</code> and bind it to a variable <code>il</code>.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>More precisely, the text between backquotes should be a string that can be parsed according to the non-terminal
that precedes it (<code>LispExp</code> in this example). This is illustrated by the list case where the parentheses appear in the concrete pattern:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-rascal" data-lang="rascal">(LispExp)`( &lt;LispExp* lst&gt; )`</code></pre>
</div>
</div>
</div>
</div>
<div class="listingblock">
<div class="title">Examples</div>
<div class="content">
<pre class="highlight"><code class="language-rascal-shell" data-lang="rascal-shell">rascal&gt;import demo::lang::Lisra::Parse;
ok
rascal&gt;import demo::lang::Lisra::Runtime;
ok
rascal&gt;parse("1");
Lval: Integer(1)
rascal&gt;parse("x");
Lval: Atom("x")
rascal&gt;parse("(+ 5 7)");
Lval: List([
    Atom("+"),
    Integer(5),
    Integer(7)
  ])</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="Lisra-Pretty">3.3.4. Pretty</h4>
<div class="paragraph">
<div class="title">Synopsis</div>
<p>A Lisp pretty printer.</p>
</div>
<div class="paragraph">
<div class="title">Description</div>
<p>The purpose of a pretty printer is to convert an internal structure to text.
We define here the simplest possible solution:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-rascal" data-lang="rascal">module demo::lang::Lisra::Pretty

import demo::lang::Lisra::Runtime;

// Pretty print: transform an Lval to a string
str pretty(Integer(n))  = "&lt;n&gt;";
str pretty(Atom(name))  = name;
str pretty(List(list[Lval] elms)) = "( &lt;for(Lval e &lt;- elms){&gt;&lt;pretty(e)&gt; &lt;}&gt;)";
str pretty(Closure(fn)) = "Closure(&lt;fn&gt;)";</code></pre>
</div>
</div>
<div class="paragraph">
<p>Compare the definition of <code>pretty</code> with that of <code>parse</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-rascal" data-lang="rascal">Lval parse(str txt);
str pretty(Lval x);</code></pre>
</div>
</div>
<div class="paragraph">
<p>For a well-designed pair of <code>parse</code>/<code>pretty</code> functions, the latter is the inverse of the former.
In other words, for every <code>L</code> the following should hold:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-rascal" data-lang="rascal">parse(pretty(L)) == L</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">Examples</div>
<div class="content">
<pre class="highlight"><code class="language-rascal-shell" data-lang="rascal-shell">rascal&gt;import demo::lang::Lisra::Runtime;
rascal2rvm: Parsing and checking |std:///demo/lang/Lisra/Runtime.rsc|
rascal2rvm: Compiling |std:///demo/lang/Lisra/Runtime.rsc|
r2mu: entering ... demo::lang::Lisra::Runtime
mu2rvm: Compiling module demo::lang::Lisra::Runtime
Compiling |std:///demo/lang/Lisra/Runtime.rsc|: check: 26, compile: 554, total: 580 ms
compile: Writing RVMModule |compressed+home:///bin-console/demo/lang/Lisra/Runtime.rvm.gz|
Removing |compressed+home:///bin-console/ConsoleInput_imports.rvm.gz|
ok
rascal&gt;import demo::lang::Lisra::Pretty;
rascal2rvm: Parsing and checking |std:///demo/lang/Lisra/Pretty.rsc|
rascal2rvm: Compiling |std:///demo/lang/Lisra/Pretty.rsc|
r2mu: entering ... demo::lang::Lisra::Pretty
mu2rvm: Compiling module demo::lang::Lisra::Pretty
Compiling |std:///demo/lang/Lisra/Pretty.rsc|: check: 23, compile: 194, total: 217 ms
compile: Writing RVMModule |compressed+home:///bin-console/demo/lang/Lisra/Pretty.rvm.gz|
Removing |compressed+home:///bin-console/ConsoleInput_imports.rvm.gz|
ok
rascal&gt;pretty(Integer(42));
str: "42"
rascal&gt;pretty(Atom("x"));
str: "x"
rascal&gt;L = List([Atom("+"), Integer(5), Integer(7)]);
Lval: List([
    Atom("+"),
    Integer(5),
    Integer(7)
  ])
rascal&gt;pretty(L);
str: "( + 5 7 )"</code></pre>
</div>
</div>
<div class="paragraph">
<p>Now let&#8217;s explore whether <code>pretty</code> is indeed the inverse of <code>parse</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-rascal-shell" data-lang="rascal-shell">rascal&gt;import demo::lang::Lisra::Parse;
rascal2rvm: Parsing and checking |std:///demo/lang/Lisra/Parse.rsc|
rascal2rvm: Compiling |std:///demo/lang/Lisra/Parse.rsc|
r2mu: entering ... demo::lang::Lisra::Parse
mu2rvm: Compiling module demo::lang::Lisra::Parse
Compiling |std:///demo/lang/Lisra/Parse.rsc|: check: 30, compile: 1029, total: 1059 ms
compile: Writing RVMModule |compressed+home:///bin-console/demo/lang/Lisra/Parse.rvm.gz|
rascal2rvm: Parsing and checking |std:///demo/lang/Lisra/Syntax.rsc|
rascal2rvm: Compiling |std:///demo/lang/Lisra/Syntax.rsc|
r2mu: entering ... demo::lang::Lisra::Syntax
mu2rvm: Compiling module demo::lang::Lisra::Syntax
Compiling |std:///demo/lang/Lisra/Syntax.rsc|: check: 6, compile: 846, total: 852 ms
compile: Writing RVMModule |compressed+home:///bin-console/demo/lang/Lisra/Syntax.rvm.gz|
Removing |compressed+home:///bin-console/ConsoleInput_imports.rvm.gz|
ok
rascal&gt;parse(pretty(L)) == L;
bool: true</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="Lisra-Eval">3.3.5. Eval</h4>
<div class="paragraph">
<div class="title">Synopsis</div>
<p>A Lisp interpreter.</p>
</div>
<div class="paragraph">
<div class="title">Description</div>
<p>Here is the core of our Lisp interpreter. Its basic functionality is to take</p>
</div>
<div class="ulist">
<ul>
<li>
<p>An <code>Lval</code> and an Environment (both defined in <a href="#Lisra-Runtime">Runtime</a>).</p>
</li>
<li>
<p>Distinguish the various forms an <code>Lval</code> can have and compute the
effect of evaluating it.</p>
</li>
<li>
<p>Return a <code>Result</code> that captures the value just computed and possibleside-effects
on the environment.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Rascal provides pattern-directed dispatch: a function with the same name
can have complete patterns as arguments. When called, a pattern match determines which
variant of the function will be called. This is used extensively in the definitions below:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-rascal" data-lang="rascal">module demo::lang::Lisra::Eval

import Prelude;
import demo::lang::Lisra::Parse;
import demo::lang::Lisra::Runtime;

Lval eval(Lval x) = eval(x, [()]).val;

// Evaluate an Lval in a given environment and return a Result.

Result eval(str exp) = eval(parse(exp),  [()]);

Result eval(Integer(int x), Env e) = &lt;Integer(x), e&gt;; <i class="conum" data-value="1"></i><b>(1)</b>

Result eval(var:Atom(str name), Env e) { <i class="conum" data-value="2"></i><b>(2)</b>
  n = find(var, e);
  return &lt;(n &lt; 0) ? var : e[n][var], e&gt;;
}

Result eval(List([Atom("quote"), *Lval exps]), Env e) = <i class="conum" data-value="3"></i><b>(3)</b>
  &lt;size(exps) == 1 ? exps[0] : List(exps), e&gt;;

Result eval(List([Atom("set!"), var, exp]), Env e) { <i class="conum" data-value="4"></i><b>(4)</b>
  val = eval(exp, e).val;
  n = find(var, e);
  if(n &lt; 0) e[0][var] = val; else e[n][var] = val;
  return &lt;val, e&gt;;
}

Result eval(List([Atom("if"), Lval tst, Lval conseq, Lval alt]), Env e) = <i class="conum" data-value="5"></i><b>(5)</b>
  eval(tst, e).val != FALSE ? eval(conseq, e) : eval(alt, e);


Result eval(List([Atom("begin"), *Lval exps]) , Env e) { <i class="conum" data-value="6"></i><b>(6)</b>
  val = FALSE;
  for(Lval exp &lt;- exps){
      &lt;val, e&gt; = eval(exp, e);
  }
  return &lt;val, e&gt;;
}

Result eval(List([Atom("define"), var, exp]), Env e){ <i class="conum" data-value="7"></i><b>(7)</b>
   e[0][var] = eval(exp, e).val;
   return &lt;FALSE, e&gt;;
}

Result eval(List([Atom("lambda"), List(list[Lval] vars), exp]), Env defEnv) = <i class="conum" data-value="8"></i><b>(8)</b>
  &lt;Closure(Result(list[Lval] args, Env callEnv) {
                 return eval(exp, makeEnv(vars, args, tail(callEnv, size(defEnv))));
           }),
   defEnv&gt;;

default Result eval(List([ *Lval exps ]), Env e) { <i class="conum" data-value="9"></i><b>(9)</b>
  if(isEmpty(exps))
     return &lt;List([]), e&gt;;
  vals = [ eval(exp, e).val | exp &lt;- exps ];
  return apply(head(vals), tail(vals), e);
}

//default Result eval(Lval exp, Env e) = &lt;exp, e&gt;;


// Apply an Lval to a list of arguments and return a Result
Result apply(Closure(Result(list[Lval] args, Env env) fn), list[Lval] args, Env e) { <i class="conum" data-value="10"></i><b>(10)</b>
  return &lt;fn(args, e).val, e&gt;;
}

<i class="conum" data-value="11"></i><b>(11)</b>

Result apply(Atom("+"),      [Integer(x), Integer(y)],      Env e) = &lt;Integer(x + y), e&gt;;
Result apply(Atom("-"),      [Integer(x), Integer(y)],      Env e) = &lt;Integer(x - y), e&gt;;
Result apply(Atom("*"),      [Integer(x), Integer(y)],      Env e) = &lt;Integer(x * y), e&gt;;
Result apply(Atom("\&lt;"),     [Lval x, Lval y],              Env e) = &lt;x &lt; y ? TRUE : FALSE, e&gt;;
Result apply(Atom("\&gt;"),     [Lval x, Lval y],              Env e) = &lt;x &gt;= y ? TRUE : FALSE, e&gt;;
Result apply(Atom("equal?"), [Lval x, Lval y],              Env e) = &lt;x == y ? TRUE : FALSE, e&gt;;
Result apply(Atom("null?"),  [List(list[Lval] x)],          Env e) = &lt;isEmpty(x) ? TRUE : FALSE, e&gt;;
Result apply(Atom("cons"),   [Lval x, List(list[Lval] y)],  Env e) = &lt;List([x, *y]), e&gt;;
Result apply(Atom("append"), [List(list[Lval] x), Lval y],  Env e) = &lt;List([*x, *y]), e&gt;;
Result apply(Atom("car"),    [List(list[Lval] x)],          Env e) = &lt;head(x), e&gt;;
Result apply(Atom("cdr"),    [List(list[Lval] x)],          Env e) = &lt;List(tail(x)), e&gt;;
Result apply(Atom("list"),   list[Lval] x,                  Env e) = &lt;List(x), e&gt;;

default Result apply(Lval a,     list[Lval] b, Env e) { <i class="conum" data-value="12"></i><b>(12)</b>
  println("Cannot apply &lt;a&gt; to &lt;b&gt; using &lt;e&gt;");
  return &lt;FALSE, e&gt;;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>We now explain the different cases in more detail:</p>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>An integer constant evaluates to itself. Note how <code>Integer(int x)</code> is used as first
argument of this <code>eval</code> function. It is a pattern that describes that the constructor <code>Integer</code>
with an <code>int</code> argument <code>x</code> is to be matched.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>An atom evaluates to the value to which it is bound or to itself. <code>find</code> (see [Runtime]) is used
to search for the atom in question. The first argument is <code>var:Atom(str name)</code>, a pattern that matches
an <code>Atom</code>. The <code>var:</code> prefix binds the complete atom to a variable <code>var</code> to be used in the body of the function.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>A quoted list evaluates to itself. The pattern <code>List([Atom("quote"), exp*])</code> matches a <code>List</code> constructor
whose first element is <code>Atom("quote")</code>. <code>exp*</code> means that the remaining list elements are assignment to <code>exp</code>.
There are two cases: if the argument list has size 1, its first element is used, otherwise a list with all elements of <code>exp</code>
vare returned. This ensures that <code>List([Atom("quote"), Integer(17)])</code> evaluates to  <code>Integer(17)</code> and not to <code>List([ Integer(17)]</code>.</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>Evaluates a <code>set!</code> expression that assigns the value of <code>exp</code> to variable <code>var</code>.</td>
</tr>
<tr>
<td><i class="conum" data-value="5"></i><b>5</b></td>
<td>Evaluates the <code>if</code> expression. The test <code>tst</code> is evaluated and is not false, the value of <code>conseq</code> is returned and otherwise
that of <code>alt</code>.</td>
</tr>
<tr>
<td><i class="conum" data-value="6"></i><b>6</b></td>
<td>Evaluates a <code>block</code> expression. The list of expressions <code>exps</code> is evaluated one by one. Observe that in the for loop
<code>&lt;val, e&gt; = eval(exp, e);</code> captures both the value and the environment that results from executing one expression. That new environment is
is used to evaluate the next expression(s) in the list. The value of the last expression and a possible modied environment are returned.</td>
</tr>
<tr>
<td><i class="conum" data-value="7"></i><b>7</b></td>
<td>Evaluate a <code>define</code> expression that binds the value of <code>exp</code> to variable <code>var</code>.
The value of the expression is bound <code>var</code> in the local scope.</td>
</tr>
<tr>
<td><i class="conum" data-value="8"></i><b>8</b></td>
<td>Evaluate a lambda expression. Essentially we return a <code>Closure</code> value that contains the expression in the lambda expression
 properly wrapped to do variable binding and environment management.
 A Closure contains a function that return type <code>Results</code> and has two arguments:
<code>list[lval] args</code> the actual parameter values when the closure is applied, and
<code>Env e</code> the environment at the site of the call.
 In the body of the closure we construct a new environment <code>makeEnv(vars, args, tail(callEnv, size(defEnv)))</code> that binds the variables
 in the lambda expression to the actual parameter values. What is special here is that we shorten the calling environment to the
 same length as the defining environment. This implements <em>lexical scoping</em> and avoids that names are visible in the called
 function that were not visible when the function was defined. Remember that Rascal values are immutable, meaning that after a value was
 created it cannot be changed. Using the above trick, we ensure that the called function has access to the most recent version of
 its environment.</td>
</tr>
<tr>
<td><i class="conum" data-value="9"></i><b>9</b></td>
<td>Evaluates an arbitrary list. As a special case, the empty list is returned as false.
Otherwise, all elements are evaluated and the auxiliary function ` apply` is used to apply the value of the first element to the values of
the remaining elements.</td>
</tr>
<tr>
<td><i class="conum" data-value="10"></i><b>10</b></td>
<td>Apply an <code>Lval</code> to a list of arguments and return a <code>Result</code>. The first case handles a <code>Closure</code>; it amounts
to calling the function in the closure (environment handling and parameter binding are done in the closure as discussed above.</td>
</tr>
<tr>
<td><i class="conum" data-value="11"></i><b>11</b></td>
<td>Definition of all built-in functions.</td>
</tr>
<tr>
<td><i class="conum" data-value="12"></i><b>12</b></td>
<td>A default function that prints an error message when an undefined function is called.</td>
</tr>
</table>
</div>
<div class="listingblock">
<div class="title">Examples</div>
<div class="content">
<pre class="highlight"><code class="language-rascal-shell" data-lang="rascal-shell">rascal&gt;import demo::lang::Lisra::Runtime;
ok
rascal&gt;import demo::lang::Lisra::Eval;
rascal2rvm: Parsing and checking |std:///demo/lang/Lisra/Eval.rsc|
rascal2rvm: Compiling |std:///demo/lang/Lisra/Eval.rsc|
r2mu: entering ... demo::lang::Lisra::Eval
mu2rvm: Compiling module demo::lang::Lisra::Eval
Compiling |std:///demo/lang/Lisra/Eval.rsc|: check: 49, compile: 1258, total: 1307 ms
compile: Writing RVMModule |compressed+home:///bin-console/demo/lang/Lisra/Eval.rvm.gz|
Removing |compressed+home:///bin-console/ConsoleInput_imports.rvm.gz|
ok
rascal&gt;eval(Integer(5));
Lval: Integer(5)
rascal&gt;eval(Atom("x"));
Lval: Atom("x")
rascal&gt;eval(List([Atom("+"), Integer(5), Integer(7)]));
Lval: Integer(12)</code></pre>
</div>
</div>
<div class="ulist">
<div class="title">Benefits</div>
<ul>
<li>
<p>A very modular, rule-based, type safe Lisp interpreter.</p>
</li>
</ul>
</div>
<div class="ulist">
<div class="title">Pitfalls</div>
<ul>
<li>
<p>It is no pleasure to type in `Lval`s directly, that is why a parser is needed, see <a href="#Lisra-Parse">Parse</a>.</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="Lisra-Test">3.3.6. Test</h4>
<div class="paragraph">
<div class="title">Synopsis</div>
<p>Tests for the Lisp interpreter.</p>
</div>
<div class="paragraph">
<div class="title">Description</div>
<p>It is good practice to write tests for your software.</p>
</div>
<div class="paragraph">
<p>Here are our tests for Lisra:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-rascal" data-lang="rascal">module demo::lang::Lisra::Test

import demo::lang::Lisra::Runtime;
import demo::lang::Lisra::Eval;

test bool eval01() = eval("42").val == Integer(42);
test bool eval02() = eval("x").val == Atom("x");

test bool eval03() = eval("(quote 1)").val == Integer(1);
test bool eval04() = eval("(quote 1 2)").val == List([Integer(1), Integer(2)]);

test bool eval05() = eval("(+ 1 2)").val == Integer(3);
test bool eval06() = eval("(- 5 3)").val == Integer(2);
test bool eval07() = eval("(* 5 3)").val == Integer(15);
test bool eval08() = eval("(\&lt; 3 4)").val != FALSE;
test bool eval09() = eval("(\&lt; 3 2)").val == FALSE;
test bool eval10() = eval("(\&gt; 3 2)").val != FALSE;
test bool eval11() = eval("(\&gt;3 4)").val == FALSE;
test bool eval12() = eval("(equal? 3 3)").val != FALSE;
test bool eval13() = eval("(equal? 3 2)").val == FALSE;

test bool eval14() = eval("(null? ())").val != FALSE;
test bool eval15() = eval("(null? (quote 1 2))").val == FALSE;

test bool eval16() = eval("(begin (define swap (lambda (a b) (list b a))) (swap 1 2))").val ==
                     List([Integer(2), Integer(1)]);
test bool eval17() = eval("(begin (define * (lambda (a b) (+ a b))) (* 1 2))"). val == Integer(3);

test bool eval18() = eval("(begin (set! x 1) x)").val == Integer(1);
test bool eval19() = eval("(if (\&gt; 5 2) 10 20)").val == Integer(10);
test bool eval20() = eval("(if (\&gt; 2 5) 10 20)").val == Integer(20);

test bool eval21() = eval("(begin (define fac (lambda (n) (if (\&gt; n 1) (* n (fac (- n 1))) 1))) (fac 3))").val == Integer(6);
test bool eval22() = eval("(begin (define length (lambda (x) (if(null? x) 0 (+ 1 (length (cdr x)))))) (length (quote (1 2 3))))").val == Integer(3);
test bool eval23() = eval("(begin (define rev (lambda (x) (if (null? x) () (append (rev (cdr x)) (car x))))) (rev (quote 1 2 3)))").val == List([Integer(3), Integer(2), Integer(1)]);
test bool eval24() = eval("(begin (define F (lambda (x) y)) (set! y 10) (F 1))").val == Integer(10);</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="Languages-Pico">3.4. Pico</h3>
<div class="paragraph">
<div class="title">Synopsis</div>
<p>The classical toy language, including a specialized IDE.</p>
</div>
<div class="paragraph">
<div class="title">Description</div>
<p>Pico is a toy language that has been used as example over the years in many projects and disguishes,
Pico has a single purpose in life: being so simple that specifications of every possible language aspect are so simple that they fit on a few pages. It can be summarized as follows:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>There are two types: natural numbers and strings.</p>
</li>
<li>
<p>Variables have to be declared.</p>
</li>
<li>
<p>Statements are assignment, if-then-else and while-do.</p>
</li>
<li>
<p>Expressions may contain naturals, strings, variables, addition (<code>+</code>), subtraction (<code>-</code>) and concatenation (<code>||</code>).</p>
</li>
<li>
<p>The operators <code>+</code> and <code>-</code> have operands of type natural and their result is natural.</p>
</li>
<li>
<p>The operator <code>||</code> has operands of type string and its results is also of type string.</p>
</li>
<li>
<p>Tests in if-then-else statement and while-statement should be of type natural.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The following aspects of the Pico language will be discussed:</p>
</div>
<div class="paragraph">
<div class="title">Examples</div>
<p>Here is a&#8201;&#8212;&#8201;not so simple&#8201;&#8212;&#8201;Pico program that computes the factorial function:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-rascal" data-lang="rascal">begin declare input : natural, <i class="conum" data-value="1"></i><b>(1)</b>
              output : natural,
              repnr : natural,
              rep : natural;
      input := 14;
      output := 1;
      while input - 1 do <i class="conum" data-value="2"></i><b>(2)</b>
          rep := output;
          repnr := input;
          while repnr - 1 do
             output := output + rep;
             repnr := repnr - 1
          od;
          input := input - 1
      od
end</code></pre>
</div>
</div>
<div class="paragraph">
<p>Notes:</p>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Pico programs do not have input/output statements, so we use variables for that purpose.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Pico has no multiplication operator so we have to simulate it with repeated addition (yes, simplicity comes at a price!).</td>
</tr>
</table>
</div>
<div class="sect3">
<h4 id="Pico-Abstract">3.4.1. Abstract</h4>
<div class="paragraph">
<div class="title">Synopsis</div>
<p>Abstract syntax for Pico.</p>
</div>
<div class="paragraph">
<div class="title">Examples</div>
<p>Here is the complete abstract syntax for Pico:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-rascal" data-lang="rascal">module demo::lang::Pico::Abstract

public data TYPE = natural() | string(); <i class="conum" data-value="1"></i><b>(1)</b>

public alias PicoId = str; <i class="conum" data-value="2"></i><b>(2)</b>

public data PROGRAM = <i class="conum" data-value="3"></i><b>(3)</b>
  program(list[DECL] decls, list[STATEMENT] stats);

public data DECL =
  decl(PicoId name, TYPE tp);

public data EXP =
       id(PicoId name)
     | natCon(int iVal)
     | strCon(str sVal)
     | add(EXP left, EXP right)
     | sub(EXP left, EXP right)
     | conc(EXP left, EXP right)
     ;

public data STATEMENT =
       asgStat(PicoId name, EXP exp)
     | ifElseStat(EXP exp, list[STATEMENT] thenpart, list[STATEMENT] elsepart)
     | whileStat(EXP exp, list[STATEMENT] body)
     ;

anno loc TYPE@location; <i class="conum" data-value="4"></i><b>(4)</b>
anno loc PROGRAM@location;
anno loc DECL@location;
anno loc EXP@location;
anno loc STATEMENT@location;

public alias Occurrence = tuple[loc location, PicoId name, STATEMENT stat]; <i class="conum" data-value="5"></i><b>(5)</b></code></pre>
</div>
</div>
<div class="paragraph">
<p>Notes:</p>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>The types that may occur in a Pico program are either natural or string.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Introduce <code>PicoId</code> as an alias for Rascal&#8217;s <code>str</code> datatype.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>Define the various data types that constitute an AST for Pico. Observe that the constructor names match the names used in the concrete syntax, e.g., <code>strCon</code>, <code>add</code>, <code>ifElseStat</code>.</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>Define an annotation with name <code>location</code> and of type <code>loc</code> (source code location) for all AST types. This will be used when imploding
a parse tree into an abstract syntax tree.</td>
</tr>
<tr>
<td><i class="conum" data-value="5"></i><b>5</b></td>
<td>Introduce <code>Occurrence</code> as a genereic way of describing the location of various items in the AST.</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="Pico-Assembly">3.4.2. Assembly</h4>
<div class="paragraph">
<div class="title">Synopsis</div>
<p>Assembly language for Pico.</p>
</div>
<div class="paragraph">
<div class="title">Examples</div>
<p>The <a href="#Pico-Compile">Compile</a>r will translate Pico programs into the following assembly language.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-rascal" data-lang="rascal">module demo::lang::Pico::Assembly

import demo::lang::Pico::Abstract;

public data Instr =
       dclNat(PicoId Id)    // Reserve a memory location for a natural variable
     | dclStr(PicoId Id)    // Reserve a memory location for a string variable
     | pushNat(int intCon)  // Push integer constant on the stack
     | pushStr(str strCon)  // Push string constant on the stack
     | rvalue(PicoId Id)    // Push the value of a variable on the stack
     | lvalue(PicoId Id)    // Push the address of a variable on the stack
     | assign()             // Assign value on top, to variable at address top-1
     | add2()               // Replace top two stack values by their sum
     | sub2()               // Replace top two stack values by their difference
     | conc2()              // Replace top two stack values by their concatenation
     | label(str label)     // Associate a label with the next instruction
     | go(str  label)       // Go to instruction with given label
     | gotrue(str label)    // Go to instruction with given label, if top equals 0
     | gofalse(str label)   // Go to instruction with given label, if top not equal to 0
     ;</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="Pico-Compile">3.4.3. Compile</h4>
<div class="paragraph">
<div class="title">Synopsis</div>
<p>Compile a Pico program to assembly language.</p>
</div>
<div class="paragraph">
<div class="title">Examples</div>
<p>The Pico compiler translates Pico programs to <a href="#Pico-Assembly">Assembly</a> language programs.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-rascal" data-lang="rascal">module demo::lang::Pico::Compile

import Prelude;
import demo::lang::Pico::Abstract;
import demo::lang::Pico::Assembly;
import demo::lang::Pico::Load;

alias Instrs = list[Instr]; <i class="conum" data-value="1"></i><b>(1)</b>

// compile Expressions.

Instrs compileExp(natCon(int N)) = [pushNat(N)]; <i class="conum" data-value="2"></i><b>(2)</b>

Instrs compileExp(strCon(str S)) = [pushStr(substring(S,1,size(S)-1))];

Instrs compileExp(id(PicoId Id)) = [rvalue(Id)];

public Instrs compileExp(add(EXP E1, EXP E2)) = <i class="conum" data-value="3"></i><b>(3)</b>
  [*compileExp(E1), *compileExp(E2), add2()];

Instrs compileExp(sub(EXP E1, EXP E2)) =
  [*compileExp(E1), *compileExp(E2), sub2()];

Instrs compileExp(conc(EXP E1, EXP E2)) =
  [*compileExp(E1), *compileExp(E2), conc2()];

// Unique label generation

private int nLabel = 0; <i class="conum" data-value="4"></i><b>(4)</b>

private str nextLabel() {
  nLabel += 1;
  return "L&lt;nLabel&gt;";
}

// Compile a statement

Instrs compileStat(asgStat(PicoId Id, EXP Exp)) =
	[lvalue(Id), *compileExp(Exp), assign()];

Instrs compileStat(ifElseStat(EXP Exp, <i class="conum" data-value="5"></i><b>(5)</b>
                              list[STATEMENT] Stats1,
                              list[STATEMENT] Stats2)){

  elseLab = nextLabel();
  endLab = nextLabel();
  return [*compileExp(Exp),
          gofalse(elseLab),
          *compileStats(Stats1),
          go(endLab),
          label(elseLab),
          *compileStats(Stats2),
          label(endLab)];
}

Instrs compileStat(whileStat(EXP Exp,
                             list[STATEMENT] Stats1)) {
  entryLab = nextLabel();
  endLab = nextLabel();
  return [label(entryLab),
          *compileExp(Exp),
          gofalse(endLab),
          *compileStats(Stats1),
          go(entryLab),
          label(endLab)];
}

// Compile a list of statements
Instrs compileStats(list[STATEMENT] Stats1) = <i class="conum" data-value="6"></i><b>(6)</b>
  [ *compileStat(S) | S &lt;- Stats1 ];

// Compile declarations

Instrs compileDecls(list[DECL] Decls) =
  [ ((tp == natural()) ? dclNat(Id) : dclStr(Id)) | <i class="conum" data-value="7"></i><b>(7)</b>
    decl(PicoId Id, TYPE tp) &lt;- Decls
  ];

// Compile a Pico program

public Instrs compileProgram(PROGRAM P){ <i class="conum" data-value="8"></i><b>(8)</b>
  nLabel = 0;
  if(program(list[DECL] Decls, list[STATEMENT] Series) := P){
     return [*compileDecls(Decls), *compileStats(Series)];
  } else
    throw "Cannot happen";
}

public Instrs compileProgram(str txt) = compileProgram(load(txt));</code></pre>
</div>
</div>
<div class="paragraph">
<p>Notes:</p>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>We introduce <code>Instrs</code> as an alias for a list of assembly language instructions.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>The compiler consists of the functions <code>compileExp</code>, <code>compileStat</code>, <code>compileStats</code>, <code>compileDecls</code> and <code>compileProgram</code>.
They all have a program fragment as argument and return the corresponding list of instructions.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>When compiling expressions, note how <em>list splicing</em> (see [Rascal:Values/List]) is used to insert the instructions that are generated for the operands of an operator into the list of instructions for the whole expression.</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>In order to conveniently write code generators for statements, we introduce a unique label generator. The global variable <code>nLabel</code> contains
the index of the last generated label and <code>nextLabel</code> uses this to generate a new, unique label.</td>
</tr>
<tr>
<td><i class="conum" data-value="5"></i><b>5</b></td>
<td>Consider code generation for an if-the-else statement:</td>
</tr>
<tr>
<td><i class="conum" data-value="6"></i><b>6</b></td>
<td>Compiling a list of statements conveniently uses a list comprehension and list splicing.</td>
</tr>
<tr>
<td><i class="conum" data-value="7"></i><b>7</b></td>
<td>Compiling declarations allocates memory locations of the appropriate type for each declared variable.</td>
</tr>
<tr>
<td><i class="conum" data-value="8"></i><b>8</b></td>
<td><code>compileProgram</code> compiles a gives Pico program to assembly language.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Here is an example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-rascal-shell" data-lang="rascal-shell">rascal&gt;import demo::lang::Pico::Compile;
rascal2rvm: Parsing and checking |std:///demo/lang/Pico/Compile.rsc|
rascal2rvm: Compiling |std:///demo/lang/Pico/Compile.rsc|
r2mu: entering ... demo::lang::Pico::Compile
mu2rvm: Compiling module demo::lang::Pico::Compile
Compiling |std:///demo/lang/Pico/Compile.rsc|: check: 55, compile: 570, total: 625 ms
compile: Writing RVMModule |compressed+home:///bin-console/demo/lang/Pico/Compile.rvm.gz|
rascal2rvm: Parsing and checking |std:///demo/lang/Pico/Assembly.rsc|
rascal2rvm: Compiling |std:///demo/lang/Pico/Assembly.rsc|
r2mu: entering ... demo::lang::Pico::Assembly
mu2rvm: Compiling module demo::lang::Pico::Assembly
Compiling |std:///demo/lang/Pico/Assembly.rsc|: check: 7, compile: 19, total: 26 ms
compile: Writing RVMModule |compressed+home:///bin-console/demo/lang/Pico/Assembly.rvm.gz|
Removing |compressed+home:///bin-console/ConsoleInput_imports.rvm.gz|
ok
rascal&gt;compileProgram("begin declare x : natural; x := 47 end");
list[Instr]: [
  dclNat("x"),
  lvalue("x"),
  pushNat(47),
  assign()
]</code></pre>
</div>
</div>
<div class="paragraph">
<p>Here is the compilation of the factorial program:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-rascal-shell" data-lang="rascal-shell">rascal&gt;compileProgram("begin declare input : natural,
&gt;&gt;&gt;&gt;&gt;&gt;&gt;               '              output : natural,
&gt;&gt;&gt;&gt;&gt;&gt;&gt;               '             repnr : natural,
&gt;&gt;&gt;&gt;&gt;&gt;&gt;               '              rep : natural;
&gt;&gt;&gt;&gt;&gt;&gt;&gt;               '      input := 14;
&gt;&gt;&gt;&gt;&gt;&gt;&gt;               '      output := 1;
&gt;&gt;&gt;&gt;&gt;&gt;&gt;               '      while input - 1 do
&gt;&gt;&gt;&gt;&gt;&gt;&gt;               '          rep := output;
&gt;&gt;&gt;&gt;&gt;&gt;&gt;               '          repnr := input;
&gt;&gt;&gt;&gt;&gt;&gt;&gt;               '          while repnr - 1 do
&gt;&gt;&gt;&gt;&gt;&gt;&gt;               '             output := output + rep;
&gt;&gt;&gt;&gt;&gt;&gt;&gt;               '             repnr := repnr - 1
&gt;&gt;&gt;&gt;&gt;&gt;&gt;               '          od;
&gt;&gt;&gt;&gt;&gt;&gt;&gt;               '          input := input - 1
&gt;&gt;&gt;&gt;&gt;&gt;&gt;               '      od
&gt;&gt;&gt;&gt;&gt;&gt;&gt;               'end");
list[Instr]: [
  dclNat("input"),
  dclNat("output"),
  dclNat("repnr"),
  dclNat("rep"),
  lvalue("input"),
  pushNat(14),
  assign(),
  lvalue("output"),
  pushNat(1),
  assign(),
  label("L1"),
  rvalue("input"),
  pushNat(1),
  sub2(),
  gofalse("L2"),
  lvalue("rep"),
  rvalue("output"),
  assign(),
  lvalue("repnr"),
  rvalue("input"),
  assign(),
  label("L3"),
  rvalue("repnr"),
  pushNat(1),
  sub2(),
  gofalse("L4"),
  lvalue("output"),
  rvalue("output"),
  rvalue("rep"),
  add2(),
  assign(),
  lvalue("repnr"),
  rvalue("repnr"),
  pushNat(1),
  sub2(),
  assign(),
  go("L3"),
  label("L4"),
  lvalue("input"),
  rvalue("input"),
  pushNat(1),
  sub2(),
  assign(),
  go("L1"),
  label("L2")
]</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="Pico-ControlFlow">3.4.4. ControlFlow</h4>
<div class="paragraph">
<div class="title">Synopsis</div>
<p>Compute the control flow graph for a Pico program.</p>
</div>
<div class="paragraph">
<div class="title">Examples</div>
<p>A control flow graph shows how the entry and exit points of a program are connected with each other via all
decision points and statements in the program. Typically, an assignment statement is a single node in the graph
and an if-then-else statement creates a decision point (its test) that connects the then branch and the else branch.
The exits of each branch are connected to the exit of the if-then-else statement as a whole.</p>
</div>
<div class="paragraph">
<p>A control flow graph for Pico programs can be created as follows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-rascal" data-lang="rascal">module demo::lang::Pico::ControlFlow

import Prelude;
import  analysis::graphs::Graph;
import demo::lang::Pico::Abstract;
import demo::lang::Pico::Load;

public data CFNode <i class="conum" data-value="1"></i><b>(1)</b>
	= entry(loc location)
	| exit()
	| choice(loc location, EXP exp)
	| statement(loc location, STATEMENT stat);

alias CFGraph = tuple[set[CFNode] entry, Graph[CFNode] graph, set[CFNode] exit]; <i class="conum" data-value="2"></i><b>(2)</b>

CFGraph cflowStat(s:asgStat(PicoId Id, EXP Exp)) { <i class="conum" data-value="3"></i><b>(3)</b>
   S = statement(s@location, s);
   return &lt;{S}, {}, {S}&gt;;
}

CFGraph cflowStat(ifElseStat(EXP Exp,                  <i class="conum" data-value="4"></i><b>(4)</b>
                              list[STATEMENT] Stats1,
                              list[STATEMENT] Stats2)){
   CF1 = cflowStats(Stats1);
   CF2 = cflowStats(Stats2);
   E = {choice(Exp@location, Exp)};
   return &lt; E, (E * CF1.entry) + (E * CF2.entry) + CF1.graph + CF2.graph, CF1.exit + CF2.exit &gt;;
}

CFGraph cflowStat(whileStat(EXP Exp, list[STATEMENT] Stats)) { <i class="conum" data-value="5"></i><b>(5)</b>
   CF = cflowStats(Stats);
   E = {choice(Exp@location, Exp)};
   return &lt; E, (E * CF.entry) + CF.graph + (CF.exit * E), E &gt;;
}

CFGraph cflowStats(list[STATEMENT] Stats){ <i class="conum" data-value="6"></i><b>(6)</b>
  if(size(Stats) == 1)
     return cflowStat(Stats[0]);
  CF1 = cflowStat(Stats[0]);
  CF2 = cflowStats(tail(Stats));
  return &lt; CF1.entry, CF1.graph + CF2.graph + (CF1.exit * CF2.entry), CF2.exit &gt;;
}

public CFGraph cflowProgram(PROGRAM P){ <i class="conum" data-value="7"></i><b>(7)</b>
  if(program(list[DECL] Decls, list[STATEMENT] Series) := P){
     CF = cflowStats(Series);
     Entry = entry(P@location);
     Exit  = exit();
     return &lt;{Entry}, ({Entry} * CF.entry) + CF.graph + (CF.exit * {Exit}), {Exit}&gt;;
  } else
    throw "Cannot happen";
}

public CFGraph cflowProgram(str txt) = cflowProgram(load(txt)); <i class="conum" data-value="8"></i><b>(8)</b></code></pre>
</div>
</div>
<div class="paragraph">
<p>Notes:</p>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>First we define a data type <code>CFNODE</code> that represents the various elements of a control flow graph:</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Next we define <code>CFGRAPH</code> , an alias for a tuple consisting of the following three elements:</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>The control flow of an assignment statement is computed by wrapping
the assignment statement as a <code>CFNODE</code> and return a <code>CFGRAPH</code> with the assignment
statement as entry and exit node, and no internal connections.</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>The control flow of an if-then-else statement is computed as follows:</td>
</tr>
<tr>
<td><i class="conum" data-value="5"></i><b>5</b></td>
<td>The control flow of  while-statement is computed in a similar fashion,
except that the exit of the loop body has to be connected with the entry
of the while loop.</td>
</tr>
<tr>
<td><i class="conum" data-value="6"></i><b>6</b></td>
<td>The control flow graph for a series of statements is obtained by connecting
the exits and entries of consecutive statements.</td>
</tr>
<tr>
<td><i class="conum" data-value="7"></i><b>7</b></td>
<td>The control flow graph of a complete program is obtained by
creating an entry and an exit node and connecting them to the graph of
the statements of the program.</td>
</tr>
<tr>
<td><i class="conum" data-value="8"></i><b>8</b></td>
<td>Shows the steps from text to control flow graph.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>We can now create a CFG for a small Pico program:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-rascal-shell" data-lang="rascal-shell">rascal&gt;import demo::lang::Pico::ControlFlow;
ok
rascal&gt;cflowProgram("begin declare n : natural, s : string; n := 10; s := \"a\"; while n do s := s + \"a\"; n := n - 1 od end");
tuple[set[CFNode],rel[CFNode,CFNode],set[CFNode]]: &lt;{entry(|unknown:///|(0,100,&lt;1,0&gt;,&lt;1,100&gt;))},{
  &lt;choice(
    |unknown:///|(64,1,&lt;1,64&gt;,&lt;1,65&gt;),
    id("n")[
      @location=|unknown:///|(64,1,&lt;1,64&gt;,&lt;1,65&gt;),
      @comments=()
    ]),statement(
    |unknown:///|(69,12,&lt;1,69&gt;,&lt;1,81&gt;),
    asgStat(
      "s",
      add(
        id("s")[
          @location=|unknown:///|(74,1,&lt;1,74&gt;,&lt;1,75&gt;),
          @comments=()
        ],
        strCon("\"a\"")[
          @location=|unknown:///|(78,3,&lt;1,78&gt;,&lt;1,81&gt;),
          @comments=()
        ])[
        @location=|unknown:///|(74,7,&lt;1,74&gt;,&lt;1,81&gt;),
        @comments=()
      ])[
      @location=|unknown:///|(69,12,&lt;1,69&gt;,&lt;1,81&gt;),
      @comments=()
    ])&gt;,
  &lt;statement(
    |unknown:///|(39,7,&lt;1,39&gt;,&lt;1,46&gt;),
    asgStat(
      "n",
      natCon(10)[
        @location=|unknown:///|(44,2,&lt;1,44&gt;,&lt;1,46&gt;),
        @comments=()
      ])[
      @location=|unknown:///|(39,7,&lt;1,39&gt;,&lt;1,46&gt;),
      @comments=()
    ]),statement(
    |unknown:///|(48,8,&lt;1,48&gt;,&lt;1,56&gt;),
    asgStat(
      "s",
      strCon("\"a\"")[
        @location=|unknown:///|(53,3,&lt;1,53&gt;,&lt;1,56&gt;),
        @comments=()
      ])[
      @location=|unknown:///|(48,8,&lt;1,48&gt;,&lt;1,56&gt;),
      @comments=()
    ])&gt;,
  &lt;statement(
    |unknown:///|(83,10,&lt;1,83&gt;,&lt;1,93&gt;),
    asgStat(
      "n",
      sub(
        id("n")[
          @location=|unknown:///|(88,1,&lt;1,88&gt;,&lt;1,89&gt;),
          @comments=()
        ],
        natCon(1)[
          @location=|unknown:///|(92,1,&lt;1,92&gt;,&lt;1,93&gt;),
          @comments=()
        ])[
        @location=|unk...</code></pre>
</div>
</div>
<div class="paragraph">
<p>Is the above not very motivating to move on to <a href="#Pico-Visualize">Visualize</a>?</p>
</div>
</div>
<div class="sect3">
<h4 id="Pico-Evaluate">3.4.5. Evaluate</h4>
<div class="paragraph">
<div class="title">Synopsis</div>
<p>Evaluate a Pico program.</p>
</div>
<div class="paragraph">
<div class="title">Examples</div>
<p>A complete evaluator (interpreter) for Pico is defined below.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-rascal" data-lang="rascal">module demo::lang::Pico::Eval

import Prelude;
import demo::lang::Pico::Abstract;
import demo::lang::Pico::Load;


data PicoValue = natval(int n) | strval(str s) | errorval(loc l, str msg); <i class="conum" data-value="1"></i><b>(1)</b>

alias VENV = map[PicoId, PicoValue]; <i class="conum" data-value="2"></i><b>(2)</b>

// Evaluate Expressions.

PicoValue evalExp(exp:natCon(int N), VENV env) = natval(N);

PicoValue evalExp(exp:strCon(str S), VENV env) = strval(S);

PicoValue evalExp(exp:id(PicoId Id), VENV env)  =
    env[Id]?  ? env[Id] : errorval(exp@location, "Uninitialized variable &lt;Id&gt;");

PicoValue evalExp(exp:add(EXP E1, EXP E2), VENV env) =
   (natval(n1) := evalExp(E1, env) &amp;&amp;
    natval(n2) := evalExp(E2, env)) ? natval(n1 + n2)
                                    : errorval(exp@location, "+ requires natural arguments");

PicoValue evalExp(exp:sub(EXP E1, EXP E2), VENV env) =
   (natval(n1) := evalExp(E1, env) &amp;&amp;
    natval(n2) := evalExp(E2, env)) ? natval(n1 - n2)
                                    : errorval(exp@location, "- requires natural arguments");

PicoValue evalExp(exp:conc(EXP E1, EXP E2), VENV env) =
   (strval(s1) := evalExp(E1, env) &amp;&amp;
    strval(s2) := evalExp(E2, env)) ? strval(s1 + s2)
                                    : errorval(exp@location, "|| requires string arguments");

// Evaluate a statement

VENV evalStat(stat:asgStat(PicoId Id, EXP Exp), VENV env) {
  env[Id] = evalExp(Exp, env);
  return env;
}

VENV evalStat(stat:ifElseStat(EXP Exp,
                              list[STATEMENT] Stats1,
                              list[STATEMENT] Stats2),
              VENV env) =
  evalStats(evalExp(Exp, env) != natval(0) ? Stats1 : Stats2, env);

VENV evalStat(stat:whileStat(EXP Exp,
                             list[STATEMENT] Stats1),
              VENV env) {
    while(evalExp(Exp, env) != natval(0)){
       env = evalStats(Stats1, env);
    }
    return env;
}

// Evaluate a list of statements
VENV evalStats(list[STATEMENT] Stats1, VENV env) {
  for(S &lt;- Stats1){
      env = evalStat(S, env);
  }
  return env;
}

// Eval declarations

VENV evalDecls(list[DECL] Decls) =
    ( Id : (tp == demo::lang::Pico::Abstract::natural() ? natval(0) : strval(""))
    | decl(PicoId Id, TYPE tp) &lt;- Decls
    );

// Evaluate a Pico program

public VENV evalProgram(PROGRAM P){
  if(program(list[DECL] Decls, list[STATEMENT] Series) := P){
     VENV env = evalDecls(Decls);
     return evalStats(Series, env);
  } else
    throw "Cannot happen";
}

public VENV evalProgram(str txt) = evalProgram(load(txt));</code></pre>
</div>
</div>
<div class="paragraph">
<p>Notes:</p>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>First we introduce a data type <code>PicoValue</code> that wraps all possible values that can occur at run-time.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Compared to [Pico/Typecheck], we use <code>VENV</code>, a value environment (a map from Pico identifiers to Pico values).</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Here is how to evaluate a Pico program:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-rascal-shell" data-lang="rascal-shell">rascal&gt;import demo::lang::Pico::Eval;
rascal2rvm: Parsing and checking |std:///demo/lang/Pico/Eval.rsc|
rascal2rvm: Compiling |std:///demo/lang/Pico/Eval.rsc|
r2mu: entering ... demo::lang::Pico::Eval
mu2rvm: Compiling module demo::lang::Pico::Eval
Compiling |std:///demo/lang/Pico/Eval.rsc|: check: 43, compile: 819, total: 862 ms
compile: Writing RVMModule |compressed+home:///bin-console/demo/lang/Pico/Eval.rvm.gz|
Removing |compressed+home:///bin-console/ConsoleInput_imports.rvm.gz|
ok
rascal&gt;evalProgram("begin declare x : natural, y : natural; x := 1; y := x + 5 end");
map[str, PicoValue]: (
  "x":natval(1),
  "y":natval(6)
)</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="Pico-IDE">3.4.6. IDE</h4>
<div class="paragraph">
<div class="title">Synopsis</div>
<p>An Integrated Development Environment for Pico.</p>
</div>
<div class="listingblock">
<div class="title">Examples</div>
<div class="content">
<pre class="highlight"><code class="language-rascal" data-lang="rascal">Unresolved directive in Languages/Pico/IDE/IDE.adoc - include::/Users/paulklint/git/rascal/src/org/rascalmpl/library/demo/lang/Pico/Plugin.rsc[tags=module]</code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p>First the name of the language and its file name extension are defined (image:../images//1.png).</p>
</li>
<li>
<p>Next the connection with the parser (image:../images//2.png), checkers (image:../images//3.png), evaluator (image:../images//4.png),
compiler (image:../images//5.png), and visualizer (image:../images//6.png) are defined.</p>
</li>
<li>
<p>(image:../images//7.png) combines the above into a set of contributions to the Pico IDE.</p>
</li>
<li>
<p>The actual creation of the Pico IDE is done by <code>registerPico</code> (image:../images//8.png) that:</p>
<div class="ulist">
<ul>
<li>
<p>Registers the Pico language with name, file name extension and Parser. Whenever a user clicks on
a <code>.pico</code> file an editor will opened and the parsed file will be displayed in it.</p>
</li>
<li>
<p>Registers <em>annotators</em> for Pico programs. Annotators run whenever a change is made to a Pico program in an open editor.</p>
</li>
<li>
<p>Registers contributions to the context menu in the editor. When the user right-clicks, the context menu
pops up and it will show a Pico entry with actions defined in the contributions.</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
<div class="paragraph">
<p>Let&#8217;s write a Pico program that produces a string of "a"s:</p>
</div>
<div class="imageblock">
<div class="content">
<img src="Languages/Pico/IDE/Screenshot1.png" alt="screen 1">
</div>
</div>
<div class="paragraph">
<p>As can be seen in the editor above, we get an error since we made a typo (missing comma) in the declarations. We correct it:</p>
</div>
<div class="imageblock">
<div class="content">
<img src="Languages/Pico/IDE/Screenshot2.png" alt="screen 2">
</div>
</div>
<div class="paragraph">
<p>Now it turns out that we had erroneously used the <code>+</code> operator on strings (it should be <code>||</code>). We correct it:</p>
</div>
<div class="imageblock">
<div class="content">
<img src="Languages/Pico/IDE/Screenshot3.png" alt="screen 3">
</div>
</div>
<div class="paragraph">
<p>Now we get a warning that variable <code>n</code> is not initialized. We correct it and get an error-free and warning-free program:</p>
</div>
<div class="imageblock">
<div class="content">
<img src="Languages/Pico/IDE/Screenshot4.png" alt="screen 4">
</div>
</div>
</div>
<div class="sect3">
<h4 id="Pico-Load">3.4.7. Load</h4>
<div class="paragraph">
<div class="title">Synopsis</div>
<p>Convert a Pico parse tree into a Pico abstract syntax tree.</p>
</div>
<div class="paragraph">
<div class="title">Examples</div>
<p>The mapping between parse tree and abstract sybtax tree is achieved as follows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-rascal" data-lang="rascal"> module demo::lang::Pico::Load

import Prelude;
import demo::lang::Pico::Syntax;
import demo::lang::Pico::Abstract;

public PROGRAM  load(str txt) = implode(#PROGRAM, parse(#Program, txt));</code></pre>
</div>
</div>
<div class="paragraph">
<p>Notes:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>The function <code>load</code> takes a string as argument (supposedly the source code of a Pico program) and returns a value of type <code>PROGRAM</code>,
the abstract syntax tree of the input program. In case the input program is syntactically incorrect, a <code>ParseError</code> exception will be thrown,
see <a href="../Libraries/Libraries.html#Prelude-RunTimeException">RuntimeException</a>.</p>
</li>
<li>
<p><code>parse(#Program, txt)</code>: parse <code>txt</code> according to the non-terminal <code>Program</code>. Note that <code>#Program</code> is a <em>reified type</em>, i.e., the type <code>Program</code> is represented as an ordinary Rascal value and passed as argument to the <code>parse</code> function,
see <a href="../Rascal/Rascal.html#Values-ReifiedTypes">reified types</a>.
The <code>parse</code> function returns a parse tree of the input program.</p>
</li>
<li>
<p><code>implode(#PROGRAM, parse(#Program, txt))</code>: transform the parse returned by <code>parse</code> into an abstract syntax tree of type <code>PROGRAM</code>. The [$Rascal:implode] function performs the automatic mapping between elements in the parse tree and their counterpart in the abstract syntax.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The function <code>load</code> can be used as follows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-rascal-shell" data-lang="rascal-shell">rascal&gt;import demo::lang::Pico::Load;
ok
rascal&gt;load("begin declare x : natural; x := 3 end");
PROGRAM: program(
  [decl(
      "x",
      natural()[
        @location=|unknown:///|(18,7,&lt;1,18&gt;,&lt;1,25&gt;),
        @comments=()
      ])[
      @location=|unknown:///|(14,11,&lt;1,14&gt;,&lt;1,25&gt;),
      @comments=()
    ]],
  [asgStat(
      "x",
      natCon(3)[
        @location=|unknown:///|(32,1,&lt;1,32&gt;,&lt;1,33&gt;),
        @comments=()
      ])[
      @location=|unknown:///|(27,6,&lt;1,27&gt;,&lt;1,33&gt;),
      @comments=()
    ]])[
  @location=|unknown:///|(0,37,&lt;1,0&gt;,&lt;1,37&gt;),
  @comments=()
]</code></pre>
</div>
</div>
<div class="paragraph">
<p>Observe how the various parts of the abstract syntax tree are annotated with location attributes.</p>
</div>
</div>
<div class="sect3">
<h4 id="Pico-Syntax">3.4.8. Syntax</h4>
<div class="paragraph">
<div class="title">Synopsis</div>
<p>Concrete syntax for Pico.</p>
</div>
<div class="listingblock">
<div class="title">Examples</div>
<div class="content">
<pre class="highlight"><code class="language-rascal" data-lang="rascal">module demo::lang::Pico::Syntax

import Prelude;

lexical Id  = [a-z][a-z0-9]* !&gt;&gt; [a-z0-9];
lexical Natural = [0-9]+ ;
lexical String = "\"" ![\"]*  "\"";

layout Layout = WhitespaceAndComment* !&gt;&gt; [\ \t\n\r%];

lexical WhitespaceAndComment
   = [\ \t\n\r]
   | @category="Comment" ws2: "%" ![%]+ "%"
   | @category="Comment" ws3: "%%" ![\n]* $
   ;

start syntax Program
   = program: "begin" Declarations decls {Statement  ";"}* body "end" ;

syntax Declarations
   = "declare" {Declaration ","}* decls ";" ;

syntax Declaration = decl: Id id ":" Type tp;

syntax Type
   = natural:"natural"
   | string :"string"
   ;

syntax Statement
   = asgStat: Id var ":="  Expression val
   | ifElseStat: "if" Expression cond "then" {Statement ";"}*  thenPart "else" {Statement ";"}* elsePart "fi"
   | whileStat: "while" Expression cond "do" {Statement ";"}* body "od"
  ;

syntax Expression
   = id: Id name
   | strCon: String string
   | natCon: Natural natcon
   | bracket "(" Expression e ")"
   &gt; left conc: Expression lhs "||" Expression rhs
   &gt; left ( add: Expression lhs "+" Expression rhs
          | sub: Expression lhs "-" Expression rhs
          )
  ;

public start[Program] program(str s) {
  return parse(#start[Program], s);
}

public start[Program] program(str s, loc l) {
  return parse(#start[Program], s, l);
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Notes:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>Id</code>, <code>Natural</code> and <code>String</code> are the basic lexical tokens of the Pico language.</p>
</li>
<li>
<p><code>Layout</code> defines the white space and comments that may occur in a Pico program.</p>
</li>
<li>
<p>Some lexical rules are labeled with <code>@category="Comment"</code>. This is for the benefit of syntax highlighting.</p>
</li>
<li>
<p>The start symbol of the Pico grammar is called <code>Program</code>.</p>
</li>
<li>
<p>The rules for <code>Expression</code> describe the priority and associativity of the operators: all operators are left-associative and <code>||</code> has a higher priority then <code>+</code> and <code>-</code>.</p>
</li>
<li>
<p>Two auxiliary functions <code>program</code> are defined that parse a given string or a given location as Pico program.</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="Pico-Typecheck">3.4.9. Typecheck</h4>
<div class="paragraph">
<div class="title">Synopsis</div>
<p>Typechecker a Pico program.</p>
</div>
<div class="paragraph">
<div class="title">Examples</div>
<p>Recall the following properties of Pico that are relevant for type checking:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>There are two types: natural numbers and strings.</p>
</li>
<li>
<p>Variables have to be declared.</p>
</li>
<li>
<p>Expressions may contain naturals, strings, variables, addition (<code>+</code>), subtraction (<code>-</code>) and concatenation (<code>||</code>).</p>
</li>
<li>
<p>The operators <code>+</code> and <code>-</code> have operands of type natural and their result is natural.</p>
</li>
<li>
<p>The operator <code>||</code> has operands of type string and its results is also of type string.</p>
</li>
<li>
<p>Tests in if-then-else statement and while-statement should be of type natural.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The type checker is going to check these rules and will produce an error message when they are violated.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-rascal" data-lang="rascal">module demo::lang::Pico::Typecheck

import Prelude;
import demo::lang::Pico::Abstract;
import demo::lang::Pico::Load;

alias TENV = tuple[ map[PicoId, TYPE] symbols, list[tuple[loc l, str msg]] errors]; <i class="conum" data-value="1"></i><b>(1)</b>

TENV addError(TENV env, loc l, str msg) = env[errors = env.errors + &lt;l, msg&gt;]; <i class="conum" data-value="2"></i><b>(2)</b>

str required(TYPE t, str got) = "Required &lt;getName(t)&gt;, got &lt;got&gt;"; <i class="conum" data-value="3"></i><b>(3)</b>
str required(TYPE t1, TYPE t2) = required(t1, getName(t2));

// compile Expressions.

TENV checkExp(exp:natCon(int N), TYPE req, TENV env) = <i class="conum" data-value="4"></i><b>(4)</b>
  req == natural() ? env : addError(env, exp@location, required(req, "natural"));

TENV checkExp(exp:strCon(str S), TYPE req, TENV env) =
 req == string() ? env : addError(env, exp@location, required(req, "string"));

TENV checkExp(exp:id(PicoId Id), TYPE req, TENV env) { <i class="conum" data-value="5"></i><b>(5)</b>
  if(!env.symbols[Id]?)
     return addError(env, exp@location, "Undeclared variable &lt;Id&gt;");
  tpid = env.symbols[Id];
  return req == tpid ? env : addError(env, exp@location, required(req, tpid));
}

TENV checkExp(exp:add(EXP E1, EXP E2), TYPE req, TENV env) = <i class="conum" data-value="6"></i><b>(6)</b>
  req == natural() ? checkExp(E1, natural(), checkExp(E2, natural(), env))
                   : addError(env, exp@location, required(req, "natural"));

TENV checkExp(exp:sub(EXP E1, EXP E2), TYPE req, TENV env) = <i class="conum" data-value="7"></i><b>(7)</b>
  req == natural() ? checkExp(E1, natural(), checkExp(E2, natural(), env))
                   : addError(env, exp@location, required(req, "natural"));

TENV checkExp(exp:conc(EXP E1, EXP E2), TYPE req, TENV env) = <i class="conum" data-value="8"></i><b>(8)</b>
  req == string() ? checkExp(E1, string(), checkExp(E2, string(), env))
                   : addError(env, exp@location, required(req, "string"));


// check a statement

TENV checkStat(stat:asgStat(PicoId Id, EXP Exp), TENV env) { <i class="conum" data-value="9"></i><b>(9)</b>
  if(!env.symbols[Id]?)
     return addError(env, stat@location, "Undeclared variable &lt;Id&gt;");
  tpid = env.symbols[Id];
  return checkExp(Exp, tpid, env);
}

TENV checkStat(stat:ifElseStat(EXP Exp, <i class="conum" data-value="10"></i><b>(10)</b>
                              list[STATEMENT] Stats1,
                              list[STATEMENT] Stats2),
               TENV env){
    env0 = checkExp(Exp, natural(), env);
    env1 = checkStats(Stats1, env0);
    env2 = checkStats(Stats2, env1);
    return env2;
}

TENV checkStat(stat:whileStat(EXP Exp,
                             list[STATEMENT] Stats1),
                 TENV env) {
    env0 = checkExp(Exp, natural(), env);
    env1 = checkStats(Stats1, env0);
    return env1;
}

// check a list of statements
TENV checkStats(list[STATEMENT] Stats1, TENV env) { <i class="conum" data-value="11"></i><b>(11)</b>
  for(S &lt;- Stats1){
      env = checkStat(S, env);
  }
  return env;
}

// check declarations

TENV checkDecls(list[DECL] Decls) = <i class="conum" data-value="12"></i><b>(12)</b>
    &lt;( Id : tp  | decl(PicoId Id, TYPE tp) &lt;- Decls), []&gt;;

// check a Pico program

public TENV checkProgram(PROGRAM P){ <i class="conum" data-value="13"></i><b>(13)</b>
  if(program(list[DECL] Decls, list[STATEMENT] Series) := P){
     TENV env = checkDecls(Decls);
     return checkStats(Series, env);
  } else
    throw "Cannot happen";
}
                                                         <i class="conum" data-value="14"></i><b>(14)</b>
public list[tuple[loc l, str msg]] checkProgram(str txt) = checkProgram(load(txt)).errors;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Notes:</p>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>We will use <code>TENV</code> (short for type environment, as an alias for a tuple that contains all relevant type information:</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td><code>addError</code> is an auxiliary function to add in a given type environment an error message to the list of errors. It returns a new type environment.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td><code>required`is an auxiliarty function to produce readable messages, e.g., `"Required natural, got string"</code>.</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>The actual type checking is done by the functions <code>checkExp</code>, <code>checkStat</code>, <code>checkStats</code>, <code>checkDecls</code> and <code>checkProgram</code>. They all have three arguments:</td>
</tr>
<tr>
<td><i class="conum" data-value="5"></i><b>5</b></td>
<td>An important case is to check whether an identifier has been defined and, if so, whether it is defined with the expected type.</td>
</tr>
<tr>
<td><i class="conum" data-value="6"></i><b>6</b></td>
<td>Check <code>add</code>.</td>
</tr>
<tr>
<td><i class="conum" data-value="7"></i><b>7</b></td>
<td>Check <code>sub</code>.</td>
</tr>
<tr>
<td><i class="conum" data-value="8"></i><b>8</b></td>
<td>Check <code>conc</code>.</td>
</tr>
<tr>
<td><i class="conum" data-value="9"></i><b>9</b></td>
<td>An assignment statement is checked: the identifier on the left-hand side should have been declared and should be type compatible with the expression on the right-hand side.</td>
</tr>
<tr>
<td><i class="conum" data-value="10"></i><b>10</b></td>
<td>Checking if- and while-statements amounts to checking the embedded statements and ensuring that the type of the test is natural.</td>
</tr>
<tr>
<td><i class="conum" data-value="11"></i><b>11</b></td>
<td>Checking a list of statements amounts to checking each statement in the list.</td>
</tr>
<tr>
<td><i class="conum" data-value="12"></i><b>12</b></td>
<td>Checking declarations amounts to extracting each (id, type) pair form the declarations and using a map comprehension to build a type environment.</td>
</tr>
<tr>
<td><i class="conum" data-value="13"></i><b>13</b></td>
<td>Checking a complete Pico program is achieved by first checking the declarations of the program and using the resulting type environment to check its body.</td>
</tr>
<tr>
<td><i class="conum" data-value="14"></i><b>14</b></td>
<td><code>checkProgram</code> defines how to check the source code of a given Pico program.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Checking an erroneous program goes like this:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-rascal-shell" data-lang="rascal-shell">rascal&gt;import demo::lang::Pico::Typecheck;
rascal2rvm: Parsing and checking |std:///demo/lang/Pico/Syntax.rsc|
rascal2rvm: Compiling |std:///demo/lang/Pico/Syntax.rsc|
r2mu: entering ... demo::lang::Pico::Syntax
mu2rvm: Compiling module demo::lang::Pico::Syntax
Compiling |std:///demo/lang/Pico/Syntax.rsc|: check: 26, compile: 577, total: 603 ms
compile: Writing RVMModule |compressed+home:///bin-console/demo/lang/Pico/Syntax.rvm.gz|
rascal2rvm: Parsing and checking |std:///demo/lang/Pico/Typecheck.rsc|
rascal2rvm: Compiling |std:///demo/lang/Pico/Typecheck.rsc|
r2mu: entering ... demo::lang::Pico::Typecheck
mu2rvm: Compiling module demo::lang::Pico::Typecheck
Compiling |std:///demo/lang/Pico/Typecheck.rsc|: check: 52, compile: 1111, total: 1163 ms
compile: Writing RVMModule |compressed+home:///bin-console/demo/lang/Pico/Typecheck.rvm.gz|
rascal2rvm: Parsing and checking |std:///demo/lang/Pico/Abstract.rsc|
rascal2rvm: Compiling |std:///demo/lang/Pico/Abstract.rsc|
r2mu: entering ... demo::lang::Pico::Abstract
mu2rvm: Compiling module demo::lang::Pico::Abstract
Compiling |std:///demo/lang/Pico/Abstract.rsc|: check: 9, compile: 524, total: 533 ms
compile: Writing RVMModule |compressed+home:///bin-console/demo/lang/Pico/Abstract.rvm.gz|
rascal2rvm: Parsing and checking |std:///demo/lang/Pico/Load.rsc|
rascal2rvm: Compiling |std:///demo/lang/Pico/Load.rsc|
r2mu: entering ... demo::lang::Pico::Load
mu2rvm: Compiling module demo::lang::Pico::Load
Compiling |std:///demo/lang/Pico/Load.rsc|: check: 25, compile: 616, total: 641 ms
compile: Writing RVMModule |compressed+home:///bin-console/demo/lang/Pico/Load.rvm.gz|
Removing |compressed+home:///bin-console/ConsoleInput_imports.rvm.gz|
ok
rascal&gt;checkProgram("begin declare  x : natural; x := \"abc\" end");
lrel[loc,str]: [&lt;|unknown:///|(33,5,&lt;1,33&gt;,&lt;1,38&gt;),"Required natural, got string"&gt;]</code></pre>
</div>
</div>
<div class="paragraph">
<p>The error location will be use later to give specific messages in the IDE.</p>
</div>
</div>
<div class="sect3">
<h4 id="Pico-Uninit">3.4.10. Uninit</h4>
<div class="paragraph">
<div class="title">Synopsis</div>
<p>Find unitialized variables in a Pico program.</p>
</div>
<div class="paragraph">
<div class="title">Examples</div>
<p>Uninitialized variables are variables that are used without being initialized.
This means that there is a path in the control flow graph from the entry point of the program
to a specific use of a variable, where that path does not contain a definition of that variable.</p>
</div>
<div class="paragraph">
<p>This can be computed as follows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-rascal" data-lang="rascal">module demo::lang::Pico::Uninit

import Prelude;
import demo::lang::Pico::Abstract;
import demo::lang::Pico::Load;

import demo::lang::Pico::UseDef;
import demo::lang::Pico::ControlFlow;

import Relation;
import analysis::graphs::Graph;

public set[CFNode] defNodes(PicoId Id, set[Occurrence] Defs) =
   {statement(occ.stat@location, occ.stat) | Occurrence occ &lt;- Defs, occ.name == Id};

public set[Occurrence] uninitProgram(PROGRAM P) {
   D = defs(P); <i class="conum" data-value="1"></i><b>(1)</b>
   CFG = cflowProgram(P); <i class="conum" data-value="2"></i><b>(2)</b>
   return { occ | occ &lt;- uses(P), <i class="conum" data-value="3"></i><b>(3)</b>
                  any(CFNode N &lt;- reachX(CFG.graph, CFG.entry, defNodes(occ.name, D)),
                      N has location &amp;&amp; occ.location &lt;= N.location)
          }; <i class="conum" data-value="4"></i><b>(4)</b>
}

public set[Occurrence] uninitProgram(str txt) = uninitProgram(load(txt)); <i class="conum" data-value="5"></i><b>(5)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>First, we determine the variable definitions of the program,</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>and its control flow graph.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>Next we ask for every use of a variable the question: can it be reached from the entries
of the program without encountering a definition? This determined as follows:</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>The complete comprehension returns the set of occurrences of uninitialized variables.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The function <code>uninitProgram</code> performs this analysis on the source text of a Pico program.</p>
</div>
<div class="paragraph">
<p>Here is a simple example, where variable <code>p</code> is used without intialization:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-rascal-shell" data-lang="rascal-shell">rascal&gt;import demo::lang::Pico::Uninit;
rascal2rvm: Parsing and checking |std:///demo/lang/Pico/UseDef.rsc|
rascal2rvm: Compiling |std:///demo/lang/Pico/UseDef.rsc|
r2mu: entering ... demo::lang::Pico::UseDef
mu2rvm: Compiling module demo::lang::Pico::UseDef
Compiling |std:///demo/lang/Pico/UseDef.rsc|: check: 34, compile: 1252, total: 1286 ms
compile: Writing RVMModule |compressed+home:///bin-console/demo/lang/Pico/UseDef.rvm.gz|
rascal2rvm: Parsing and checking |std:///demo/lang/Pico/ControlFlow.rsc|
rascal2rvm: Compiling |std:///demo/lang/Pico/ControlFlow.rsc|
r2mu: entering ... demo::lang::Pico::ControlFlow
mu2rvm: Compiling module demo::lang::Pico::ControlFlow
Compiling |std:///demo/lang/Pico/ControlFlow.rsc|: check: 38, compile: 1038, total: 1076 ms
compile: Writing RVMModule |compressed+home:///bin-console/demo/lang/Pico/ControlFlow.rvm.gz|
rascal2rvm: Parsing and checking |std:///demo/lang/Pico/Uninit.rsc|
rascal2rvm: Compiling |std:///demo/lang/Pico/Uninit.rsc|
r2mu: entering ... demo::lang::Pico::Uninit
mu2rvm: Compiling module demo::lang::Pico::Uninit
Compiling |std:///demo/lang/Pico/Uninit.rsc|: check: 35, compile: 353, total: 388 ms
compile: Writing RVMModule |compressed+home:///bin-console/demo/lang/Pico/Uninit.rvm.gz|
Removing |compressed+home:///bin-console/ConsoleInput_imports.rvm.gz|
ok
rascal&gt;uninitProgram("begin declare n : natural, m : natural, p : natural; n := 10; m := n + p end");
rel[loc,str,STATEMENT]: {&lt;|unknown:///|(71,1,&lt;1,71&gt;,&lt;1,72&gt;),"p",asgStat(
    "m",
    add(
      id("n")[
        @location=|unknown:///|(67,1,&lt;1,67&gt;,&lt;1,68&gt;),
        @comments=()
      ],
      id("p")[
        @location=|unknown:///|(71,1,&lt;1,71&gt;,&lt;1,72&gt;),
        @comments=()
      ])[
      @location=|unknown:///|(67,5,&lt;1,67&gt;,&lt;1,72&gt;),
      @comments=()
    ])[
    @location=|unknown:///|(62,10,&lt;1,62&gt;,&lt;1,72&gt;),
    @comments=()
  ]&gt;}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="Pico-UseDef">3.4.11. UseDef</h4>
<div class="paragraph">
<div class="title">Synopsis</div>
<p>Compute use-def information for the variables in a Pico program.</p>
</div>
<div class="paragraph">
<div class="title">Examples</div>
<p>The <em>definitions</em> of a variable are the source code locations where a variable gets a value.
The <em>uses</em> of a variable are the location where the value of that variable is used.
Both concepts are relevant for program analysis and are defined here.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-rascal" data-lang="rascal">module demo::lang::Pico::UseDef

import Prelude;
import demo::lang::Pico::Abstract;
import demo::lang::Pico::ControlFlow;

set[Occurrence] usesExp(EXP e, STATEMENT s) =  <i class="conum" data-value="1"></i><b>(1)</b>
  u:id(PicoId Id1) := e ? {&lt; u@location, Id1, s&gt;}
                        : {&lt; u@location, Id2, s&gt; | /u:id(PicoId Id2) &lt;- e };

set[Occurrence] usesStat(s:asgStat(PicoId Id, EXP e)) = usesExp(e, s); <i class="conum" data-value="2"></i><b>(2)</b>

set[Occurrence] usesStat(s: ifElseStat(EXP e,
                              list[STATEMENT] s1,
                              list[STATEMENT] s2)) =
   usesExp(e, s) + usesStats(s1) + usesStats(s2);

set[Occurrence] usesStat(s: whileStat(EXP e,
                              list[STATEMENT] s1)) =
   usesExp(e, s) + usesStats(s1);

set[Occurrence] usesStats(list[STATEMENT] stats) =
   {*usesStat(s) | s &lt;- stats};

public set[Occurrence] uses(PROGRAM p) = usesStats(p.stats);  <i class="conum" data-value="3"></i><b>(3)</b>

public set[Occurrence] defs(PROGRAM p) =  <i class="conum" data-value="4"></i><b>(4)</b>
   { &lt; stat@location, v, stat &gt; | /stat:asgStat(PicoId v, EXP e) &lt;- p.stats};</code></pre>
</div>
</div>
<div class="paragraph">
<p>Recall that <code>Occurrence</code> was introduced in <a href="#Pico-Abstract">Abstract</a>; it is a parameterized container to associate
program entities with their location.</p>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>The function <code>usesExp</code> computes a set of occurrences (uses) of Pico identifiers in a given statement:</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td><code>useStat</code> extracts uses from all statement variants.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>The function <code>uses</code> simply applies <code>usesStats</code> to the statement part of its program argument.</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>The function <code>defs</code>  has a Pico program as argument and returns a set of occurrences (definitions) of Pico identifiers.
The definition consists of a single set comprehension that consists of the following parts:</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="Pico-Visualize">3.4.12. Visualize</h4>
<div class="paragraph">
<div class="title">Synopsis</div>
<p>Visualize Pico Control Flow Graphs.</p>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
<div class="title">Description</div>
The visualization library is being reimplemented and reorganized;
the information provided here maybe inaccurate or even incorrect.
</td>
</tr>
</table>
</div>
<div class="listingblock">
<div class="title">Examples</div>
<div class="content">
<pre class="highlight"><code class="language-rascal" data-lang="rascal">module demo::lang::Pico::Visualize

import Prelude;
import vis::Figure;
import vis::KeySym;

import util::Editors;

import demo::lang::Pico::Abstract;
import demo::lang::Pico::ControlFlow;

// Convert expressions into text

str make(natCon(int N)) = "&lt;N&gt;"; <i class="conum" data-value="1"></i><b>(1)</b>
str make(strCon(str S)) = S;
str make(demo::lang::Pico::Abstract::id(PicoId Id)) = Id;
str make(add(EXP E1, EXP E2)) = "&lt;make(E1)&gt; + &lt;make(E2)&gt;";
str make(sub(EXP E1, EXP E2)) = "&lt;make(E1)&gt; - &lt;make(E2)&gt;";
str make(conc(EXP E1, EXP E2)) = "&lt;make(E1)&gt; || &lt;make(E2)&gt;";

// Add an editor to a node

FProperty editIt(CFNode n) = <i class="conum" data-value="2"></i><b>(2)</b>
   (n has location) ? onMouseDown(bool (int butnr, map[KeyModifier,bool] modifiers){ edit(n.location,[]); return true;})
                    : onMouseDown(bool (int butnr, map[KeyModifier,bool] modifiers) {return false;});

// Visualize one CFG node

Figure visNode(CFNode n:entry(loc location)) = <i class="conum" data-value="3"></i><b>(3)</b>
       box(text("ENTRY"), vis::Figure::id(getId(n)), fillColor("red"), gap(4));

Figure visNode(CFNode n:exit()) =
       box(text("EXIT"),  vis::Figure::id(getId(n)), fillColor("grey"), gap(4));

Figure visNode(CFNode n:choice(loc location, EXP exp)) =
       ellipse(text(make(exp)),  vis::Figure::id(getId(n)), fillColor("yellow"), gap(8), editIt(n));

Figure visNode(CFNode n:statement(loc location, asgStat(PicoId Id, EXP Exp))) =
        box(text("&lt;Id&gt; := &lt;make(Exp)&gt;"),  vis::Figure::id(getId(n)), gap(8), editIt(n));

// Define the id for each CFG node

str getId(entry(loc location)) = "ENTRY"; <i class="conum" data-value="4"></i><b>(4)</b>
str getId(exit()) = "EXIT";
default str getId(CFNode n) = "&lt;n.location&gt;";

// Visualize a complete CFG

public Figure visCFG(rel[CFNode, CFNode] CFGGraph){ <i class="conum" data-value="5"></i><b>(5)</b>
       nodeSet = {};
       edges = [];
       for(&lt; CFNode cf1, CFNode cf2&gt; &lt;- CFGGraph){
           nodeSet += {cf1, cf2};
           edges += edge(getId(cf1), getId(cf2), toArrow(triangle(5, fillColor("black"))));
       }
       nodes = [visNode(n) | n &lt;- nodeSet];
       return graph(nodes, edges, hint("layered"), gap(20));
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>We want to include the text of expressions in the relevant Figure nodes, this is achieved by <code>make</code>.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>An editor property is attached to each Figure node: clicking on the node opens an editor for the corresponding file.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td><code>visNode</code> implements the visualization per CFG node.</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>Since Figure nodes in a visual graph need an <code>id</code> property, we define here a scheme to associate unique identifiers to each Figure node.</td>
</tr>
<tr>
<td><i class="conum" data-value="5"></i><b>5</b></td>
<td>The complete visualization of a CFG is implemented by <code>visCFG</code>: it gets the CFG hraph as arguments and then</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Let&#8217;s now apply this:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-rascal-shell" data-lang="rascal-shell">rascal&gt;render(visCFG(CFG.graph));</code></pre>
</div>
</div>
<div class="paragraph">
<p>The resulting visualization looks like this:</p>
</div>
<div class="imageblock">
<div class="content">
<img src="Languages/Pico/Visualize/cfg1.png" alt="Control flow graph">
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="Recipes-Metrics">4. Metrics</h2>
<div class="sectionbody">
<div class="paragraph">
<div class="title">Synopsis</div>
<p>Computing</p>
</div>
<div class="sect2">
<h3 id="Metrics-MeasuringJava">4.1. Measuring Java</h3>
<div class="paragraph">
<div class="title">Synopsis</div>
<p>A few steps using the M3 model to compute basic metrics for a Java project in Eclipse</p>
</div>
<div class="paragraph">
<div class="title">Description</div>
<p>This is a recipe for computing basic or more advanced metrics from a Java project in Eclipse. We assume:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>You have Rascal installed in an Eclipse instance.</p>
</li>
<li>
<p>You have a Java project in your Eclipse workspace that compiles without errors. Let&#8217;s call it <code>HelloWorld</code>.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Now we will follow the <a href="../EASY/EASY.html">EASY</a> paradigm:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>a library will be used to <em>parse</em> the Java code generating [Rascalopedia:AbstractSyntaxTree]</p>
</li>
<li>
<p>the same library will generate a [Rascal:Values/Relation]al model to represent interesting facts between Java source code artifacts</p>
</li>
<li>
<p>then we can write queries over the generated trees and relations using [Rascal:Expressions].</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>These are a number of recipes for measuring different things about Java:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>[MeasuringClasses]</p>
</li>
<li>
<p>[MeasuringMethods]</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="title">Examples</div>
<div class="content">
<pre class="highlight"><code class="language-rascal-shell" data-lang="rascal-shell"></code></pre>
</div>
</div>
<div class="paragraph">
<p>First we import the basic data types for representing Java. The model is called <em>M3</em>, and its definition is split acros a generic
language independent module called [Rascal:analysis/m3/Core] and a Java specific part called [Rascal:lang/java/m3/Core]. Have a look at the documentation
of these modules later. For now we will go through using them in a few examples.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-rascal-shell" data-lang="rascal-shell">rascal&gt;import lang::java::m3::Core;
ok</code></pre>
</div>
</div>
<div class="paragraph">
<p>Then we import the API for extracting an M3 model from an Eclipse project.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-rascal-shell" data-lang="rascal-shell">rascal&gt;import lang::java::jdt::m3::Core;
[error] Cannot import module lang::java::jdt::m3::Core AT |std:///experiments/Compiler/Compile.rsc|(0,51,&lt;1,0&gt;,&lt;1,51&gt;)</code></pre>
</div>
</div>
<div class="paragraph">
<p>Calling the following function generates an enormous value representing everything the Eclipse Java compiler knows about this project:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-rascal-shell" data-lang="rascal-shell">rascal&gt;myModel = createM3FromEclipseProject(|project://example-project|);
[error] Name createM3FromEclipseProject is not in scope</code></pre>
</div>
</div>
<div class="ulist">
<div class="title">Benefits</div>
<ul>
<li>
<p>Notice that <em>all</em> these [$Rascal:Values/Location] literals are hyperlinks and you can click on them to go the source code that they point to. Try it!</p>
</li>
</ul>
</div>
<div class="sect3">
<h4 id="MeasuringJava-MeasuringClasses">4.1.1. Measuring Classes</h4>
<div class="listingblock">
<div class="title">Examples</div>
<div class="content">
<pre class="highlight"><code class="language-rascal-shell" data-lang="rascal-shell"></code></pre>
</div>
</div>
<div class="paragraph">
<p>First we import the basic data types for representing Java. The model is called <em>M3</em>, and its definition is split acros a generic
language independent module called [Rascal:analysis/m3/Core] and a Java specific part called [Rascal:lang/java/m3/Core]. Have a look at the documentation
of these modules later. For now we will go through using them in a few examples.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-rascal-shell" data-lang="rascal-shell">rascal&gt;import lang::java::m3::Core;
rascal2rvm: Parsing and checking |std:///analysis/m3/AST.rsc|
rascal2rvm: Compiling |std:///analysis/m3/AST.rsc|
r2mu: entering ... analysis::m3::AST
mu2rvm: Compiling module analysis::m3::AST
Compiling |std:///analysis/m3/AST.rsc|: check: 11, compile: 35, total: 46 ms
compile: Writing RVMModule |compressed+home:///bin-console/analysis/m3/AST.rvm.gz|
rascal2rvm: Parsing and checking |std:///analysis/m3/Core.rsc|
rascal2rvm: Compiling |std:///analysis/m3/Core.rsc|
r2mu: entering ... analysis::m3::Core
mu2rvm: Compiling module analysis::m3::Core
Compiling |std:///analysis/m3/Core.rsc|: check: 37, compile: 927, total: 964 ms
compile: Writing RVMModule |compressed+home:///bin-console/analysis/m3/Core.rvm.gz|
rascal2rvm: Parsing and checking |std:///lang/java/m3/TypeSymbol.rsc|
rascal2rvm: Compiling |std:///lang/java/m3/TypeSymbol.rsc|
r2mu: entering ... lang::java::m3::TypeSymbol
mu2rvm: Compiling module lang::java::m3::TypeSymbol
Compiling |std:///lang/java/m3/TypeSymbol.rsc|: check: 10, compile: 33, total: 43 ms
compile: Writing RVMModule |compressed+home:///bin-console/lang/java/m3/TypeSymbol.rvm.gz|
rascal2rvm: Parsing and checking |std:///lang/java/m3/AST.rsc|
rascal2rvm: Compiling |std:///lang/java/m3/AST.rsc|
r2mu: entering ... lang::java::m3::AST
rlib1 = lang.java.m3.internal.EclipseJavaCompiler, rlib2 = |std:///lang/java/m3/internal/EclipseJavaCompilerCompiled.class|
resolveLibOverriding org.rascalmpl.library.lang.java.m3.internal.EclipseJavaCompiler =&gt; org.rascalmpl.library.lang.java.m3.internal.EclipseJavaCompiler
mu2rvm: Compiling module lang::java::m3::AST
Compiling |std:///lang/java/m3/AST.rsc|: check: 58, compile: 3195, total: 3253 ms
compile: Writing RVMModule |compressed+home:///bin-console/lang/java/m3/AST.rvm.gz|
rascal2rvm: Parsing and checking |std:///lang/java/m3/Registry.rsc|
rascal2rvm: Compiling |std:///lang/java/m3/Registry.rsc|
r2mu: entering ... lang::java::m3::Registry
mu2rvm: Compiling module lang::java::m3::Registry
Compiling |std:///lang/java/m3/Registry.rsc|: check: 18, compile: 571, total: 589 ms
compile: Writing RVMModule |compressed+home:///bin-console/lang/java/m3/Registry.rvm.gz|
rascal2rvm: Parsing and checking |std:///analysis/m3/TypeSymbol.rsc|
rascal2rvm: Compiling |std:///analysis/m3/TypeSymbol.rsc|
r2mu: entering ... analysis::m3::TypeSymbol
mu2rvm: Compiling module analysis::m3::TypeSymbol
Compiling |std:///analysis/m3/TypeSymbol.rsc|: check: 6, compile: 528, total: 534 ms
compile: Writing RVMModule |compressed+home:///bin-console/analysis/m3/TypeSymbol.rvm.gz|
rascal2rvm: Parsing and checking |std:///lang/java/m3/Core.rsc|
rascal2rvm: Compiling |std:///lang/java/m3/Core.rsc|
r2mu: entering ... lang::java::m3::Core
rlib1 = lang.java.m3.internal.EclipseJavaCompiler, rlib2 = |std:///lang/java/m3/internal/EclipseJavaCompilerCompiled.class|
resolveLibOverriding org.rascalmpl.library.lang.java.m3.internal.EclipseJavaCompiler =&gt; org.rascalmpl.library.lang.java.m3.internal.EclipseJavaCompiler
mu2rvm: Compiling module lang::java::m3::Core
Compiling |std:///lang/java/m3/Core.rsc|: check: 75, compile: 2411, total: 2486 ms
compile: Writing RVMModule |compressed+home:///bin-console/lang/java/m3/Core.rvm.gz|
rascal2rvm: Parsing and checking |std:///analysis/m3/Registry.rsc|
rascal2rvm: Compiling |std:///analysis/m3/Registry.rsc|
r2mu: entering ... analysis::m3::Registry
mu2rvm: Compiling module analysis::m3::Registry
Compiling |std:///analysis/m3/Registry.rsc|: check: 20, compile: 577, total: 597 ms
compile: Writing RVMModule |compressed+home:///bin-console/analysis/m3/Registry.rvm.gz|
rascal2rvm: Parsing and checking |std:///util/FileSystem.rsc|
rascal2rvm: Compiling |std:///util/FileSystem.rsc|
r2mu: entering ... util::FileSystem
mu2rvm: Compiling module util::FileSystem
Compiling |std:///util/FileSystem.rsc|: check: 14, compile: 59, total: 73 ms
compile: Writing RVMModule |compressed+home:///bin-console/util/FileSystem.rvm.gz|
Removing |compressed+home:///bin-console/ConsoleInput_imports.rvm.gz|
ok</code></pre>
</div>
</div>
<div class="paragraph">
<p>Then we import the API for extracting an M3 model from an Eclipse project.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-rascal-shell" data-lang="rascal-shell">rascal&gt;import lang::java::jdt::m3::Core;
[error] Cannot import module lang::java::jdt::m3::Core AT |std:///experiments/Compiler/Compile.rsc|(0,51,&lt;1,0&gt;,&lt;1,51&gt;)</code></pre>
</div>
</div>
<div class="paragraph">
<p>Calling the following function generates an enormous value representing everything the Eclipse Java compiler knows about this project:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-rascal-shell" data-lang="rascal-shell">rascal&gt;myModel = createM3FromEclipseProject(|project://example-project|);
[error] Name createM3FromEclipseProject is not in scope</code></pre>
</div>
</div>
<div class="paragraph">
<p>Next, let&#8217;s focus on the <em>containment</em> relation. This defines what parts of the source code are parts of which other parts:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-rascal-shell" data-lang="rascal-shell">rascal&gt;myModel@containment
[error] Name myModel is not in scope</code></pre>
</div>
</div>
<div class="paragraph">
<p>As you can read, classes contain methods, methods contain variables, etc. Classes could also contain other classes (nested classes), and methods can even contain classes (anonymous classes). Let&#8217;s focus on a specific class, and project what it contains from the relation:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-rascal-shell" data-lang="rascal-shell">rascal&gt;myModel@containment[|java+class:///HelloWorld|]
[error] Name myModel is not in scope</code></pre>
</div>
</div>
<div class="paragraph">
<p>Let&#8217;s filter the methods:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-rascal-shell" data-lang="rascal-shell">rascal&gt;helloWorldMethods = [ e | e &lt;- myModel@containment[|java+class:///HelloWorld|], e.scheme == "java+method"];
[error] Name myModel is not in scope</code></pre>
</div>
</div>
<div class="paragraph">
<p>And we are ready to compute our first metric. How many methods does this class contain?</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-rascal-shell" data-lang="rascal-shell">rascal&gt;import List;
ok
rascal&gt;size(helloWorldMethods)
[error] Name helloWorldMethods is not in scope</code></pre>
</div>
</div>
<div class="paragraph">
<p>No magic applied! It is just a little query on a model that knows everything about the code. Let&#8217;s generalize and compute the number of methods for all classes in one big expression. First a function to compute the number for a given class:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-rascal-shell" data-lang="rascal-shell">rascal&gt;int numberOfMethods(loc cl, M3 model) = size([ m | m &lt;- model@containment[cl], isMethod(m)]);
ok</code></pre>
</div>
</div>
<div class="paragraph">
<p>then we apply this new function to give us a map from classes to integers:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-rascal-shell" data-lang="rascal-shell">rascal&gt;map[loc class, int methodCount] numberOfMethodsPerClass = (cl:numberOfMethods(cl, myModel) | &lt;cl,_&gt; &lt;- myModel@containment, isClass(cl));
[error] Name myModel is not in scope
[error] Name myModel is not in scope</code></pre>
</div>
</div>
<div class="paragraph">
<p>how about the number of fields?</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-rascal-shell" data-lang="rascal-shell">rascal&gt;int numberOfFields(loc cl, M3 model) = size([ m | m &lt;- model@containment[cl], isField(m)]);
ok
rascal&gt;map[loc class, int fieldCount] numberOfFieldsPerClass = (cl:numberOfFields(cl, myModel) | &lt;cl,_&gt; &lt;- myModel@containment, isClass(cl));
[error] Name myModel is not in scope
[error] Name myModel is not in scope</code></pre>
</div>
</div>
<div class="paragraph">
<p>what is the ratio between fields and methods for each class?</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-rascal-shell" data-lang="rascal-shell">rascal&gt;(cl : (numberOfFieldsPerClass[cl] * 1.0) / (numberOfMethodsPerClass[cl] * 1.0) | cl &lt;- classes(myModel))
[error] Name numberOfMethodsPerClass is not in scope
[error] Name numberOfFieldsPerClass is not in scope
[error] Name myModel is not in scope</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="MeasuringJava-MeasuringMethods">4.1.2. Measuring Methods</h4>
<div class="listingblock">
<div class="title">Examples</div>
<div class="content">
<pre class="highlight"><code class="language-rascal-shell" data-lang="rascal-shell">rascal&gt;import lang::java::m3::Core;
ok
rascal&gt;import lang::java::jdt::m3::Core;
[error] Cannot import module lang::java::jdt::m3::Core AT |std:///experiments/Compiler/Compile.rsc|(0,51,&lt;1,0&gt;,&lt;1,51&gt;)
rascal&gt;import lang::java::jdt::m3::AST;
[error] Cannot import module lang::java::jdt::m3::AST AT |std:///experiments/Compiler/Compile.rsc|(0,51,&lt;1,0&gt;,&lt;1,51&gt;)</code></pre>
</div>
</div>
<div class="paragraph">
<p>First extract our overview model</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-rascal-shell" data-lang="rascal-shell">rascal&gt;myModel = createM3FromEclipseProject(|project://example-project|);
[error] Name createM3FromEclipseProject is not in scope</code></pre>
</div>
</div>
<div class="paragraph">
<p>Now let&#8217;s focus on the methods</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-rascal-shell" data-lang="rascal-shell">rascal&gt;myMethods = methods(myModel);
[error] Name myModel is not in scope</code></pre>
</div>
</div>
<div class="paragraph">
<p>What is the source code for a method?</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-rascal-shell" data-lang="rascal-shell">rascal&gt;import IO;
ok
rascal&gt;methodSrc = readFile(|java+method:///HelloWorld/main(java.lang.String%5B%5D)|);
IO("Unsupported scheme java+method")
Call stack (most recent first):
	readFile(|java+method:///HelloWorld/main(java.lang.String%5B%5D)|, {}) at |std:///IO.rsc|(12600,1747,&lt;540,0&gt;,&lt;576,43&gt;)
	main([]) at |test-modules:///ConsoleInput.rsc|(76,66,&lt;5,15&gt;,&lt;5,81&gt;)

ok</code></pre>
</div>
</div>
<div class="paragraph">
<p>let&#8217;s print it:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-rascal-shell" data-lang="rascal-shell">rascal&gt;println(methodSrc)
[error] Name methodSrc is not in scope</code></pre>
</div>
</div>
<div class="paragraph">
<p>how many words in this method?</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-rascal-shell" data-lang="rascal-shell">rascal&gt;(0 | it + 1 | /\W+/ := methodSrc)
[error] Name methodSrc is not in scope</code></pre>
</div>
</div>
<div class="paragraph">
<p>let&#8217;s get its AST</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-rascal-shell" data-lang="rascal-shell">rascal&gt;methodAST = getMethodASTEclipse(|java+method:///HelloWorld/main(java.lang.String%5B%5D)|, model=myModel);
[error] Name getMethodASTEclipse is not in scope
[error] Name myModel is not in scope</code></pre>
</div>
</div>
<div class="paragraph">
<p>Now we count the number of expressions:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-rascal-shell" data-lang="rascal-shell">rascal&gt;(0 | it + 1 | /Expression _ := methodAST)
[error] Name methodAST is not in scope</code></pre>
</div>
</div>
<div class="paragraph">
<p>or give us the locations of all expressions:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-rascal-shell" data-lang="rascal-shell">rascal&gt;[m@src | /Expression m := methodAST]
[error] Name methodAST is not in scope</code></pre>
</div>
</div>
<div class="paragraph">
<p>the size should be the same, right?</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-rascal-shell" data-lang="rascal-shell">rascal&gt;import List;
ok
rascal&gt;size([m@src | /Expression m := methodAST]) == (0 | it + 1 | /Expression _ := methodAST)
[error] Name methodAST is not in scope
[error] Name methodAST is not in scope</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="Recipes-Visualization">5. Visualization</h2>
<div class="sectionbody">
<div class="paragraph">
<div class="title">Synopsis</div>
<p>Recipes for creating visualizations.</p>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
<div class="title">Description</div>
The visualization library is being reimplemented and reorganized;
the information provided here maybe inaccurate or even incorrect
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>We cover the following topics:</p>
</div>
<div class="sect2">
<h3 id="Visualization-ADT">5.1. ADT</h3>
<div class="paragraph">
<div class="title">Synopsis</div>
<p>Visualize an Algebraic Datatype as a tree.</p>
</div>
<div class="paragraph">
<div class="title">Description</div>
<p>In <a href="#ColoredTrees">[ColoredTrees]</a> we have discussed the Algebraic Data Type <code>ColoredTree</code>.
Here we show how to create a visualization for them. The global approach is:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Define a function <code>visColoredTree</code> that has a ColoredTree as argument and
creates a <code>Figure</code> for it.</p>
</li>
<li>
<p>Display the resulting figure using [$Rascal:Render/render].</p>
</li>
</ul>
</div>
<div class="paragraph">
<div class="title">Examples</div>
<p>Here is our solution:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-rascal" data-lang="rascal">module demo::vis::VisADT

import vis::Figure;
import vis::Render;

data ColoredTree = leaf(int N)
                 | red(ColoredTree left, ColoredTree right)
                 | black(ColoredTree left, ColoredTree right)
                 | green(ColoredTree left, ColoredTree right)
                 ;

Figure visColoredTree(leaf(int N)) =
	box(text("&lt;N&gt;"), gap(2), fillColor("lightyellow")); <i class="conum" data-value="1"></i><b>(1)</b>

Figure visColoredTree(red(ColoredTree left, ColoredTree right)) =
	visNode("red", left, right); <i class="conum" data-value="2"></i><b>(2)</b>

Figure visColoredTree(black(ColoredTree left, ColoredTree right)) =
	visNode("black", left, right);

Figure visColoredTree(green(ColoredTree left, ColoredTree right)) =
	visNode("green", left, right);

Figure visNode(str color, ColoredTree left, ColoredTree right) = <i class="conum" data-value="3"></i><b>(3)</b>
	tree(ellipse(fillColor(color)), [visColoredTree(left), visColoredTree(right)]);

ColoredTree  rb = red(black(leaf(1), red(leaf(2),leaf(3))), green(leaf(3), leaf(4)));</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>A <code>leaf</code> is represented as its number converted to text, surrounded by a lightyellow box.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>The figure for non-leaf nodes of a ColoredTree is generated by the auxiliary function <code>visNode</code>.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td><code>visNode</code> represents the node itself as a [$Rascal:Figures/tree] that has a colored ellipse as root and the visualization of
two ColoredTrees as children.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>For the example <code>ColoredTree</code> <code>rb</code> we can set a standard
(see <a href="../Libraries/Libraries.html#std" class="bare">../Libraries/Libraries.html#std</a>) <a href="../Libraries/Libraries.html#Properties-size">size</a> and standard <a href="../Libraries/Libraries.html#Properties-gap">gap</a>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-rascal-shell" data-lang="rascal-shell">rascal&gt;render(space(visColoredTree(rb), std(size(30)), std(gap(30))));</code></pre>
</div>
</div>
<div class="paragraph">
<p>and the result is:</p>
</div>
<div class="imageblock">
<div class="content">
<img src="Visualization/ADT/a1.png" alt="a1">
</div>
</div>
<div class="paragraph">
<p>Note that:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>We place the Figure that is produced by <code>viscoloredTree</code> in a <code>space</code> for the sole purpose that add extra proerties to it.</p>
</li>
<li>
<p>We use <code>std(size(30))</code> and ` std(gap(30))` to achieve that these properties are set for all subfigures.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Some further custumizations are possible. By default, the tree visualization
uses <a href="../Libraries/Libraries.html#Properties-manhattan">manhattan</a> style. If we turn it off</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-rascal-shell" data-lang="rascal-shell">rascal&gt;render(space(visColoredTree(rb), std(size(30)), std(gap(30)), std(manhattan(false))));</code></pre>
</div>
</div>
<div class="paragraph">
<p>the result is:</p>
</div>
<div class="imageblock">
<div class="content">
<img src="Visualization/ADT/a2.png" alt="a2">
</div>
</div>
<div class="paragraph">
<p>It is also possible to change the <a href="../Libraries/Libraries.html#Properties-orientation">orientation</a> of the tree and draw it, for example, from left to right:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-rascal-shell" data-lang="rascal-shell">rascal&gt;render(space(visColoredTree(rb), std(size(30)), std(gap(30)), std(orientation(leftRight()))));</code></pre>
</div>
</div>
<div class="paragraph">
<p>the result is:</p>
</div>
<div class="imageblock">
<div class="content">
<img src="Visualization/ADT/a3.png" alt="a3">
</div>
</div>
</div>
<div class="sect2">
<h3 id="Visualization-DrawLogo">5.2. Draw a Logo</h3>
<div class="paragraph">
<div class="title">Synopsis</div>
<p>Draw the Rascal logo.</p>
</div>
<div class="paragraph">
<div class="title">Description</div>
<p>Given a 50x50 matrix containing the colors of the Rascal logo,
we can reproduce it as visualization.</p>
</div>
<div class="paragraph">
<div class="title">Examples</div>
<p>Here is the solution:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-rascal" data-lang="rascal">module demo::vis::Logo

import vis::Figure;
import vis::Render;

public list[int] LogoData = [
0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff,
0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff,
0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff,
0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff,
0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff,
0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff,
0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff,
0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff,
0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff,
0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff,
0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff,
0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff,
0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff,
0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff,
0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff,
0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff,
0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff,
0xfff9f9f9, 0xff9d9c9e, 0xff616063, 0xffa3a2a4, 0xfffcfcfc, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff,
0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff,
0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff,
0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xfffefefe,
0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff,
0xfff7f7f7, 0xff595759, 0xff121014, 0xff616063, 0xfffcfcfc, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff,
0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff,
0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff,
0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xfffefefe, 0xfffbfbfb, 0xff7f7e80, 0xff646163, 0xffc2c1c3, 0xfff7f7f7,
0xffffffff, 0xfffefefe, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff,
0xffffffff, 0xffdddddd, 0xff747375, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff,
0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff,
0xffffffff, 0xffffffff, 0xffffffff, 0xfffefefe, 0xfffefefe, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff,
0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffc1c0c1, 0xff8e8782, 0xffc6bdb2, 0xff908984, 0xff5b595a,
0xffcccccd, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff,
0xffffffff, 0xffffffff, 0xff565357, 0xffd7d7d7, 0xffffffff, 0xfffefefe, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff,
0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff,
0xffffffff, 0xffffffff, 0xffffffff, 0xfffefefe, 0xffffffff, 0xfff3f3f3, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff,
0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xff504e4f, 0xffd3c9be, 0xffe2d7cb, 0xffe1d7cb, 0xffdfd4c9,
0xff4c4848, 0xffb5b5b7, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff,
0xffffffff, 0xffffffff, 0xffdcdbdc, 0xff242226, 0xffdfdfdf, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff,
0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff,
0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xff7f7e80, 0xff131115, 0xff636264, 0xffffffff, 0xffffffff, 0xffffffff,
0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffc8c8c9, 0xff696360, 0xffeadfd2, 0xffbcb3aa, 0xffbbb2a9, 0xffdfd5c8,
0xffe5d9cd, 0xff645e5c, 0xffa09ea1, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff,
0xffffffff, 0xfffefefe, 0xffffffff, 0xff7c7b7d, 0xff161418, 0xff9d9c9e, 0xfff9f9f9, 0xffffffff, 0xfffefefe, 0xffffffff,
0xfffefefe, 0xffffffff, 0xffe4e4e4, 0xffe5e5e5, 0xffffffff, 0xffffffff, 0xfff7f7f7, 0xffffffff, 0xffffffff, 0xffffffff,
0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xff747274, 0xff0e0c10, 0xff09070c, 0xfffafafa, 0xffffffff, 0xffffffff,
0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xff58575a, 0xffd5cbc0, 0xffe0d5c9, 0xffdfd4c8, 0xffb5ada4, 0xff948d87,
0xffede1d5, 0xffded4c8, 0xff7c7672, 0xff8c8b8d, 0xffffffff, 0xfffefefe, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff,
0xfffefefe, 0xffffffff, 0xffffffff, 0xfff7f7f8, 0xff4a484b, 0xff151217, 0xff454447, 0xffe6e7e6, 0xffffffff, 0xffffffff,
0xffd8d7d8, 0xffd7d7d7, 0xffffffff, 0xffa3a2a4, 0xfff4f4f4, 0xffffffff, 0xffd5d4d5, 0xffffffff, 0xffffffff, 0xffffffff,
0xfffefefe, 0xffffffff, 0xffffffff, 0xffffffff, 0xfff7f7f7, 0xff939193, 0xff717072, 0xfffefefe, 0xffffffff, 0xffffffff,
0xffffffff, 0xffffffff, 0xffffffff, 0xfff5f5f6, 0xff504d4f, 0xffede2d4, 0xffdfd5c9, 0xffe1d6ca, 0xffe8ddd1, 0xffa8a099,
0xff817b76, 0xffdfd5ca, 0xffe4dace, 0xff6a6562, 0xffc2c2c2, 0xffffffff, 0xfffefefe, 0xffffffff, 0xfffdfdfd, 0xffffffff,
0xffffffff, 0xffe3e3e4, 0xfff2f2f3, 0xffffffff, 0xffffffff, 0xff403d41, 0xff141217, 0xff131116, 0xff9a999b, 0xffd3d3d4,
0xffdfdfdf, 0xff59575a, 0xffc6c6c7, 0xff3a373b, 0xffecebec, 0xffdfdfdf, 0xffbcbcbd, 0xffeaeaea, 0xffdddcdd, 0xffeeedee,
0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xfffefefe, 0xffe2e1e2, 0xffa3a2a4, 0xffffffff, 0xffffffff, 0xffffffff,
0xffffffff, 0xffffffff, 0xffffffff, 0xffd0d0d1, 0xff8a8480, 0xffe8ded1, 0xffcbc1b7, 0xffaca49c, 0xffebe1d3, 0xffe7ddd0,
0xffbab1a8, 0xff827b76, 0xffe9ded1, 0xffdacfc4, 0xff4f4b4b, 0xffcccccd, 0xffffffff, 0xffffffff, 0xfffcfcfc, 0xffc1c0c1,
0xffffffff, 0xfffefefe, 0xffb4b3b5, 0xffcccccc, 0xfff9f8f8, 0xff211f24, 0xff2c2924, 0xff373323, 0xff0a0a13, 0xff0f0c11,
0xff18161a, 0xff1d1b1f, 0xff18161a, 0xff323034, 0xff666568, 0xff4b494c, 0xff838183, 0xff878688, 0xfff6f6f6, 0xffffffff,
0xffffffff, 0xfffefefe, 0xffffffff, 0xfffefefe, 0xffffffff, 0xffabaaac, 0xffbcbbbc, 0xffffffff, 0xffffffff, 0xffffffff,
0xffffffff, 0xffffffff, 0xffffffff, 0xffb5b5b6, 0xffaba39d, 0xffe2d8cc, 0xffdfd4c8, 0xffcec4ba, 0xff6b6563, 0xffc1b9af,
0xffe3d8cc, 0xffb1a8a0, 0xff6d6764, 0xffe8dcd0, 0xffd9cfc3, 0xff3f3c3e, 0xffebebeb, 0xffffffff, 0xffffffff, 0xffedeced,
0xff5d5c5f, 0xfff0f0f0, 0xffffffff, 0xff5d5b5e, 0xff312f32, 0xff2e2b24, 0xffe3d54c, 0xffe7d42d, 0xff625122, 0xff211e24,
0xff403e42, 0xff1a181c, 0xff1a181c, 0xff1a181c, 0xff1a181c, 0xff19161b, 0xff151317, 0xffa6a4a6, 0xff838284, 0xffa3a2a4,
0xffcfced0, 0xffffffff, 0xffffffff, 0xffffffff, 0xffefeeef, 0xff312f33, 0xfff1f1f1, 0xffffffff, 0xffffffff, 0xffffffff,
0xffffffff, 0xffffffff, 0xffffffff, 0xffa3a2a4, 0xffc3b9b0, 0xffe4d9cd, 0xffe2d7cb, 0xffe4dacd, 0xffe4d9ce, 0xff89827e,
0xff817a75, 0xffa9a199, 0xffa39a93, 0xff938b86, 0xffe1d6ca, 0xffb9b0a7, 0xff777577, 0xffffffff, 0xfffefefe, 0xffffffff,
0xffcfcecf, 0xff323134, 0xff858385, 0xff8e8d8f, 0xff1a181c, 0xffcdc262, 0xfff4df32, 0xff786320, 0xff8b898e, 0xffffffff,
0xffffffff, 0xffb0b0b1, 0xff171519, 0xff383417, 0xffcdc45f, 0xffa9a8a8, 0xff6a653a, 0xff161413, 0xff6c6a6f, 0xffcfcfcf,
0xffffffff, 0xfffefefe, 0xffffffff, 0xffe8e8e8, 0xff302e32, 0xff919092, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff,
0xffffffff, 0xffffffff, 0xffffffff, 0xff9b9a9b, 0xffc4bbb1, 0xffe3d8cb, 0xffbab1a8, 0xff918a84, 0xffb3aba2, 0xffe9ded1,
0xffdbcfc4, 0xffbab1a8, 0xff736e6b, 0xff403b3c, 0xffa29992, 0xffe6dbcf, 0xff77706c, 0xffa9a8aa, 0xffffffff, 0xfff9f9f9,
0xfff2f2f2, 0xffdddcdd, 0xff262327, 0xff13111a, 0xff989260, 0xfffcea49, 0xff8f7b1f, 0xff747374, 0xffffffff, 0xffffffff,
0xffffffff, 0xffffffff, 0xff454346, 0xff131116, 0xffb2a947, 0xfffffb8f, 0xfffdee50, 0xffd7c826, 0xff26221a, 0xff211f24,
0xff5d5b5e, 0xfff6f6f7, 0xffdfdfe0, 0xff2e2c30, 0xff525154, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff,
0xffffffff, 0xffffffff, 0xffffffff, 0xff959394, 0xffc7bdb4, 0xffe0d6ca, 0xffe1d6ca, 0xffe1d6ca, 0xffa8a199, 0xff66615e,
0xffbab0a7, 0xffddd3c7, 0xffe4d9cd, 0xffc8bfb5, 0xff494545, 0xffbdb4ab, 0xffe6dbcf, 0xff363234, 0xffe1e0e1, 0xffffffff,
0xffa7a6a8, 0xff5f5d61, 0xff5e5d5f, 0xff2e2b20, 0xffe7dc7a, 0xffdfcb27, 0xff3b321c, 0xfff8f8f8, 0xffffffff, 0xffefefef,
0xfff9f9f9, 0xffffffff, 0xff9e9d9e, 0xff100e12, 0xff12111a, 0xffada123, 0xffcbbc25, 0xffaca125, 0xff474221, 0xff18161b,
0xff161419, 0xff2a282c, 0xff120f14, 0xff484649, 0xfff4f4f5, 0xfffefefe, 0xfffefefe, 0xffffffff, 0xffffffff, 0xffffffff,
0xffffffff, 0xffffffff, 0xffffffff, 0xff959495, 0xffc8beb4, 0xffe4d9cd, 0xffe1d7cb, 0xffdfd4c8, 0xffe7dccf, 0xffe1d6ca,
0xffa69e97, 0xff76706c, 0xffdfd5c8, 0xffe6dbcf, 0xffe4dace, 0xff7c7572, 0xffcac1b7, 0xffcbc1b7, 0xff636264, 0xfff9f9f9,
0xffffffff, 0xffc6c6c7, 0xff838284, 0xff635e38, 0xfffbee60, 0xffae9925, 0xff5a585a, 0xffffffff, 0xffffffff, 0xff545356,
0xff69686a, 0xfffcfcfc, 0xff939194, 0xff3f3418, 0xff19171b, 0xff14121b, 0xff161314, 0xff1c191d, 0xff151319, 0xff17151a,
0xff13111c, 0xff1c1819, 0xff2f2d30, 0xffc7c6c7, 0xffaeacae, 0xffe3e3e4, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff,
0xffffffff, 0xffffffff, 0xffffffff, 0xff9b9a9b, 0xffc4bab0, 0xffe3d8cc, 0xffded3c7, 0xffe3d9cc, 0xffe0d5ca, 0xffddd3c7,
0xffe2d7cb, 0xffccc3b9, 0xff3b3839, 0xffd5cbc0, 0xffdfd5c9, 0xffcfc4ba, 0xff847d79, 0xffe4d9cc, 0xff817a76, 0xffc3c2c3,
0xffffffff, 0xffffffff, 0xffabaaab, 0xff999351, 0xfffcec4a, 0xff7f6b23, 0xff85848b, 0xffffffff, 0xffffffff, 0xff383639,
0xff1b191d, 0xffc1c1c1, 0xff575558, 0xff947d21, 0xff23201c, 0xff1a181c, 0xff817f82, 0xffffffff, 0xffdfdee0, 0xff3d3a30,
0xffa59120, 0xff4c3a20, 0xff29262b, 0xff8b898b, 0xffededee, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff,
0xffffffff, 0xffffffff, 0xffffffff, 0xffa5a5a7, 0xffc0b7ad, 0xffe3d8cb, 0xffe0d5c9, 0xffdacfc4, 0xffbfb5ad, 0xffb5ada4,
0xffd3c8bd, 0xffebdfd2, 0xffd0c6bb, 0xff55504f, 0xffc3bab0, 0xffe7dccf, 0xff97908a, 0xff918a84, 0xffdad0c4, 0xff484446,
0xfffafafa, 0xffffffff, 0xff676468, 0xffcbc375, 0xfff8e645, 0xff625122, 0xffa5a5aa, 0xffdad9d9, 0xfff5f5f5, 0xff323034,
0xff161418, 0xff939295, 0xff2f2920, 0xffd4bc2d, 0xff29261a, 0xff6c6a6d, 0xffffffff, 0xffffffff, 0xffffffff, 0xff575444,
0xffe9d223, 0xff33271c, 0xff413f43, 0xff89888a, 0xffa1a0a2, 0xffbfbfbf, 0xfff3f3f4, 0xffffffff, 0xfffefefe, 0xfffefefe,
0xffffffff, 0xffffffff, 0xffffffff, 0xffbcbcbe, 0xffa29b94, 0xffe4dacd, 0xffdfd5c9, 0xffe3d8cb, 0xffdcd2c6, 0xffd5cbc0,
0xff968f8a, 0xff645f5d, 0xff827b76, 0xff958e87, 0xff403d3d, 0xffc5bbb2, 0xffeadfd2, 0xff726b69, 0xffb2aaa1, 0xffa8a098,
0xff636266, 0xffffffff, 0xff2b292d, 0xffe4dd96, 0xfff9e744, 0xff655423, 0xffb3b3b8, 0xff727174, 0xff525054, 0xff1e1c20,
0xff18161a, 0xff4a4a52, 0xff665722, 0xffefdc30, 0xff2e2b1d, 0xfffdfdfd, 0xffeaeaea, 0xff515052, 0xfff0f0f2, 0xff535146,
0xffd5be24, 0xff140f13, 0xff858486, 0xffc7c7c8, 0xffdddcdd, 0xfff4f4f4, 0xffd7d7d8, 0xff838184, 0xffffffff, 0xffffffff,
0xffffffff, 0xffffffff, 0xffffffff, 0xffe0e0e0, 0xff6c6866, 0xffebe0d3, 0xffe1d6ca, 0xffd9d0c4, 0xffdad0c4, 0xffd9cfc4,
0xffeadfd2, 0xffeee2d6, 0xffc6beb5, 0xff96908a, 0xff87817d, 0xff605a58, 0xffc1b8ae, 0xffe5d9ce, 0xff5f5a58, 0xffdfd4c9,
0xff64605e, 0xffd2d1d3, 0xff19171b, 0xffece7ac, 0xfffded54, 0xff856f23, 0xffa0a0a6, 0xff9d9c9e, 0xff0d0b0f, 0xff19171b,
0xff1b191e, 0xff1d1a1f, 0xffd3bb1f, 0xffecdd40, 0xff656256, 0xffffffff, 0xffd7d6d7, 0xff18161a, 0xff6a696e, 0xff6c683c,
0xff9b8822, 0xff3b3b44, 0xff464347, 0xffa5a5a6, 0xfffbfbfb, 0xffe9e9e9, 0xff656262, 0xff1b191d, 0xffffffff, 0xffffffff,
0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xff4d4b4f, 0xffd8cec2, 0xffe0d5ca, 0xffd2c8bd, 0xffc8bfb5, 0xffa8a199,
0xffa29a94, 0xff9d958e, 0xff928985, 0xffded3c8, 0xffe3d8cb, 0xffded3c8, 0xff6d6764, 0xffcbc1b6, 0xff9e968f, 0xff847d78,
0xffcdc3b8, 0xff6a686a, 0xff19171c, 0xffe4dfaf, 0xfffef587, 0xffc0a920, 0xff504d4e, 0xffe8e7e8, 0xff4d4c4f, 0xff16151b,
0xff16131a, 0xffa49311, 0xfffbe923, 0xffe4d764, 0xff444241, 0xff5a585b, 0xff7d7b7e, 0xff1a181c, 0xff23212b, 0xff9d9129,
0xff3a321f, 0xffababad, 0xffffffff, 0xffffffff, 0xffffffff, 0xff666466, 0xffa79f97, 0xff403e42, 0xffffffff, 0xfffefefe,
0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffc1c2c3, 0xff655e5c, 0xffe6dccf, 0xffe4d9cd, 0xffe2d7cb, 0xffe8ded2,
0xff726c67, 0xff524f49, 0xff97936f, 0xff3a3632, 0xffc5bcb2, 0xffdfd4c8, 0xffe3d8cd, 0xff3d3a3a, 0xffdacfc3, 0xff3c383a,
0xffbdb4aa, 0xff686261, 0xff19171b, 0xffcdc789, 0xfffffde9, 0xfff1e36f, 0xff504822, 0xff1a171b, 0xff17141b, 0xff37331a,
0xffd3c627, 0xfffff252, 0xfffbeb49, 0xffd6cd7f, 0xff29272b, 0xff1a181c, 0xff1a181c, 0xff19171b, 0xff1f1d1c, 0xffa09020,
0xff23232e, 0xffe2e1e2, 0xffffffff, 0xffffffff, 0xff6d6d6f, 0xff99938e, 0xffa09890, 0xff838284, 0xffffffff, 0xffffffff,
0xffffffff, 0xffffffff, 0xffffffff, 0xfffefefe, 0xffffffff, 0xff636163, 0xffbab1a7, 0xffded4c8, 0xffddd3c7, 0xff534e53,
0xff7d7725, 0xffffffd1, 0xfffef47d, 0xffe6db55, 0xff565134, 0xff9e9694, 0xffe5dacd, 0xffd2c8bd, 0xff5b5655, 0xffbcb3aa,
0xff363234, 0xffb5aca4, 0xff1a181c, 0xffa59f62, 0xfff8f3c5, 0xff8d864b, 0xffd7ca62, 0xffbcb036, 0xff9e941d, 0xff6f6717,
0xff6a663f, 0xffaeab97, 0xfffffacc, 0xffbfbb9e, 0xff5c595c, 0xff1c1a1e, 0xff19171b, 0xff312f35, 0xff615a1d, 0xff403a19,
0xff69676b, 0xffffffff, 0xfffbfafb, 0xff7e7d7f, 0xff9a938e, 0xffb7afa6, 0xff6c6561, 0xffcdcdce, 0xffffffff, 0xffffffff,
0xffffffff, 0xffffffff, 0xffffffff, 0xfffefefe, 0xffffffff, 0xffe2e2e2, 0xff5a5556, 0xffe6dbce, 0xff7f797a, 0xff6d6413,
0xfffff02c, 0xffedd933, 0xffb59d25, 0xffbfb228, 0xffe7d730, 0xff605b2d, 0xff605a5c, 0xffe8ddd0, 0xff98908a, 0xff756f6b,
0xff87807b, 0xff847c78, 0xff18161b, 0xff736f47, 0xfff2e891, 0xff242117, 0xff776f24, 0xffd4c626, 0xffecdb28, 0xffbfb224,
0xff544d19, 0xff13121b, 0xff646265, 0xffadaba4, 0xff777678, 0xffeeedee, 0xff92919c, 0xff4d4928, 0xffa19521, 0xff181517,
0xfff7f6f7, 0xfff3f3f3, 0xff444246, 0xffbab1a9, 0xff857e79, 0xffd2c9be, 0xff595453, 0xfffcfcfc, 0xffffffff, 0xffffffff,
0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffabaaac, 0xff585453, 0xff302c21, 0xffe6db55,
0xfffef8c6, 0xffe3d04b, 0xff3e3a2a, 0xff2f2c23, 0xff7d7628, 0xffcbbc19, 0xff58534f, 0xff575251, 0xffd4cabf, 0xff413e3e,
0xff8c8480, 0xff423d3e, 0xff292629, 0xff47442b, 0xfff3ea90, 0xff80761d, 0xfff8e60c, 0xffe2d548, 0xfffbeb3d, 0xfff9e92e,
0xffefdf25, 0xff847b24, 0xff1e1b1a, 0xff2a272a, 0xff252218, 0xff393418, 0xff958b26, 0xffecdc28, 0xff2c2919, 0xffa3a2a5,
0xffdededf, 0xff514f50, 0xffd7cdc4, 0xffada59c, 0xffaba39c, 0xffcbc1b7, 0xff737171, 0xffffffff, 0xffffffff, 0xffffffff,
0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xfffefefe, 0xffffffff, 0xff7d7d7e, 0xff564f0c, 0xfffaf291,
0xfffdf59e, 0xfffbed44, 0xfff2e43c, 0xffc1b74d, 0xff4a472e, 0xff433e1e, 0xff534f3f, 0xff423d41, 0xff312d32, 0xff585354,
0xff111016, 0xff221f24, 0xff1c1a1d, 0xff1a181a, 0xffdcd15f, 0xffe4d52a, 0xffcdc026, 0xff26242d, 0xffc2ba77, 0xfffff250,
0xfffae82d, 0xffe1d121, 0xff898127, 0xff211e1c, 0xffa1951d, 0xfffcf5a0, 0xfff4e763, 0xff4b461f, 0xff535259, 0xff908f92,
0xff696564, 0xffd8cec3, 0xffaca49b, 0xff7e7875, 0xffcac1b7, 0xffaca39b, 0xff9c9b9d, 0xffffffff, 0xffffffff, 0xffffffff,
0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xff5e5c5f, 0xff938813, 0xffffed17,
0xffe5d518, 0xffc0ae24, 0xffc9bb22, 0xffdccc1d, 0xfffeeb17, 0xff544f19, 0xffc9bf5f, 0xfff6efa1, 0xffbdb888, 0xff989371,
0xff8f8b66, 0xff676450, 0xff36332c, 0xff1b171b, 0xff776e20, 0xfffef05f, 0xfffff344, 0xff504a1f, 0xff19171e, 0xff8a866a,
0xfff6ee8c, 0xfffaee63, 0xffe2d338, 0xffa1951b, 0xffdace4b, 0xffefe79b, 0xff5d561e, 0xff232024, 0xff6b6a6d, 0xff8f8a86,
0xffe5d9ce, 0xff978f88, 0xff686462, 0xffa59d96, 0xffdcd1c6, 0xff65605e, 0xffd0d0d1, 0xffffffff, 0xffffffff, 0xffffffff,
0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xff3f3d40, 0xffc0b546, 0xfffffab0,
0xffd7c138, 0xff352f22, 0xff2f2b21, 0xff534d24, 0xff807720, 0xff4a441d, 0xffe6d625, 0xfff2e223, 0xffe7d726, 0xff978c20,
0xff39341e, 0xff6b641f, 0xffbda71e, 0xffd9bd1f, 0xff6a5c1c, 0xffdfd264, 0xfffdef67, 0xffe8d935, 0xff2b281b, 0xff100e16,
0xff100e14, 0xff3b392f, 0xff6d6629, 0xfffbe812, 0xffd5c736, 0xff5e5719, 0xff241d1b, 0xff383538, 0xffa59e97, 0xffcec4b9,
0xff75706c, 0xff4b4848, 0xff8f8983, 0xffb7afa7, 0xffd5cbc0, 0xff3e3c40, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff,
0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xff504e51, 0xffcab420, 0xfffef153,
0xfff9eb55, 0xffe1d64c, 0xffd3c41e, 0xff8a801e, 0xff191719, 0xff4e4820, 0xffa59b2e, 0xff7c7527, 0xff2d291c, 0xff18161b,
0xff2a271b, 0xffd4c728, 0xfffaef62, 0xfffdf594, 0xfff1e558, 0xff726c3b, 0xfffffcb6, 0xffeedd37, 0xffbeb232, 0xff151317,
0xff85826d, 0xffebe16e, 0xffecdb1e, 0xffa39824, 0xff2e2c1d, 0xff211d1c, 0xff8f7120, 0xff3c383b, 0xff76706b, 0xff565151,
0xffc1b8b0, 0xffcbc0b7, 0xff706a68, 0xffddd3c7, 0xff5e5956, 0xffaeadaf, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff,
0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffa3a2a4, 0xff6c5d1d, 0xffa19120,
0xff9f931f, 0xff988d1f, 0xff807727, 0xff484429, 0xff5d5c5e, 0xff737177, 0xff241f1d, 0xff755c23, 0xff3e381b, 0xff19171b,
0xff302c1b, 0xffeade66, 0xfffdfdfd, 0xfffdfdff, 0xfffff9a8, 0xffbaae33, 0xffccc9af, 0xfff7efb0, 0xffe0d033, 0xffddd048,
0xffe0d677, 0xffbfb124, 0xff5f5924, 0xff26211d, 0xff6c5821, 0xff342c1d, 0xffcba721, 0xff372c1e, 0xff746f6f, 0xffe5dace,
0xffaea69d, 0xff605c5a, 0xffded5ca, 0xffcbc1b6, 0xff403c3f, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff,
0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xfffefefe, 0xffffffff, 0xffb6b6bb, 0xff969497,
0xff918f8f, 0xff9a999d, 0xffacacb3, 0xffcbcbce, 0xffffffff, 0xff807b71, 0xffa58d24, 0xffe3ce31, 0xfff1e13a, 0xff8f841b,
0xff564e1e, 0xfff9ec5c, 0xfffdf8c3, 0xfffbf6c9, 0xfffbf5c0, 0xfff2e240, 0xff938c4a, 0xffffffda, 0xffe5db78, 0xff8f8521,
0xff49421c, 0xff4c461f, 0xff80761e, 0xffad9524, 0xff43381f, 0xff3c351b, 0xfff4da17, 0xff977925, 0xff5d5a5f, 0xff807a76,
0xffa69f98, 0xffaaa29a, 0xffd4cac0, 0xff827b76, 0xffbcbbbd, 0xffffffff, 0xfffefefe, 0xffffffff, 0xffffffff, 0xffffffff,
0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff,
0xffffffff, 0xffffffff, 0xffffffff, 0xfffcfcfc, 0xff494852, 0xffab8f2a, 0xffead942, 0xfffefad1, 0xfffdfdf8, 0xfffaed69,
0xffcdb722, 0xffe8d62e, 0xfffbed61, 0xfffbee6d, 0xfffbee7d, 0xfffbeb46, 0xffc2b428, 0xff4c4629, 0xff524b22, 0xff938824,
0xffddcd28, 0xffd3c522, 0xffc3b523, 0xff443e1e, 0xff13121c, 0xff82771b, 0xffffef20, 0xffd4be20, 0xff4a4240, 0xffc3bab0,
0xff56514f, 0xff9f9792, 0xffdbd1c5, 0xff525052, 0xfff5f5f5, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff,
0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff,
0xffffffff, 0xfffefefe, 0xffffffff, 0xff777577, 0xff0d0c18, 0xffc4ac32, 0xffffffc7, 0xffa0a6a4, 0xffa0b39d, 0xfff6ea97,
0xffead926, 0xffd8c924, 0xfff9e937, 0xfffbea35, 0xfffae932, 0xfffcec33, 0xfff0df25, 0xffb0a41f, 0xff9f973a, 0xff847c30,
0xff776e1d, 0xffc8ba22, 0xffa19723, 0xff2a261e, 0xff12111b, 0xffccbe1e, 0xfffcea2e, 0xffe8d918, 0xff4c401e, 0xff484447,
0xffbfb7ae, 0xffe9ded1, 0xff454040, 0xffc4c3c4, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff,
0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff,
0xfffefefe, 0xffffffff, 0xff8a898b, 0xff151317, 0xff12101b, 0xffa89b29, 0xfffffb91, 0xffceca7e, 0xff157688, 0xff44756b,
0xffe1cb24, 0xffd7c826, 0xfff0df28, 0xfffbe92a, 0xfffbea1f, 0xffe2d214, 0xff7e793c, 0xffded894, 0xffecece0, 0xfff4f3e7,
0xffb5aa39, 0xff5d571c, 0xffada22a, 0xff7a6627, 0xff554820, 0xffdacb23, 0xfffbeb4f, 0xfff4e222, 0xff70621b, 0xff908986,
0xffe3d8cc, 0xff5f5956, 0xffa7a6a7, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff,
0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xfffefefe,
0xffffffff, 0xffbcbcbe, 0xff241e18, 0xff1c1a1c, 0xff11101c, 0xff95891b, 0xfffff854, 0xffb9b155, 0xff24899c, 0xff07a9ba,
0xff25574d, 0xffdecb25, 0xffd4c525, 0xfffae828, 0xfff3e216, 0xff686335, 0xffeee587, 0xffddc62f, 0xfffcee55, 0xfffbf06b,
0xfffdf28a, 0xff998f2b, 0xff514723, 0xff655325, 0xffa68b25, 0xffd4c424, 0xfffbec5a, 0xfff7e841, 0xff86781c, 0xff696361,
0xff8a827d, 0xff807e81, 0xffffffff, 0xfffefefe, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff,
0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xfffefefe,
0xfff1f1f2, 0xff4c433c, 0xffb49723, 0xffac9f12, 0xff544d16, 0xff57501d, 0xffdcc81c, 0xff617c76, 0xff17aebd, 0xff00616e,
0xff56562a, 0xffb9ac2f, 0xffb4a019, 0xfff3e023, 0xff79701f, 0xffddcf2d, 0xff655e23, 0xff352d15, 0xffe7dd68, 0xfffefce7,
0xfffaf2a0, 0xffffee2f, 0xffbaad2a, 0xff463f20, 0xffaa8e25, 0xffdccd25, 0xfffbee62, 0xfff8ea4d, 0xff94861e, 0xff2c2828,
0xff979798, 0xfffdfdfd, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff,
0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff,
0xff797779, 0xff7b651d, 0xffecdd4d, 0xfffffbd3, 0xfffcf057, 0xffd4c418, 0xff6d7b60, 0xff28adbb, 0xff008694, 0xff13656f,
0xff317c84, 0xff319ca7, 0xff369da8, 0xff70772c, 0xff645c1b, 0xff8b8124, 0xff2d2a24, 0xffe1d873, 0xfffbed5e, 0xfffbec35,
0xfff7e948, 0xfff8ea50, 0xfffae81a, 0xffeddc24, 0xff6c641f, 0xff8f8521, 0xfff6eb75, 0xfffaed5b, 0xff9a8919, 0xff5d5b5a,
0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff,
0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffc3c2c3,
0xff171210, 0xffb09d25, 0xfffbf8da, 0xfff7f1c9, 0xffebe18f, 0xff7e8a5e, 0xff2ca7b9, 0xff007a89, 0xff414b28, 0xffc1ae21,
0xffdfc913, 0xff556e39, 0xff007485, 0xff626a2a, 0xff413c1e, 0xff3e3a24, 0xffdcd268, 0xffa89d35, 0xff87750f, 0xfff9ec68,
0xfffdf8bb, 0xfffaee64, 0xfffae924, 0xfffbe91f, 0xfffff55b, 0xfff5e647, 0xfff9f193, 0xfffbf286, 0xff9b8915, 0xff6f6b6b,
0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff,
0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xfff2f2f2, 0xff3a383b,
0xff17151b, 0xff8e8222, 0xff808568, 0xff6d9a93, 0xff7ea19b, 0xff28a8b7, 0xff007f8f, 0xff273427, 0xffcfbf24, 0xfffae92e,
0xfff3e12a, 0xff4f7753, 0xff4d5523, 0xffe6d519, 0xff3e3920, 0xffab9f20, 0xff887f2b, 0xff1e1c1d, 0xff837f52, 0xfff7f0a3,
0xfff7ea60, 0xfff1e037, 0xfff7e726, 0xfffbe90e, 0xfffbed52, 0xfffcf9e1, 0xfffdfdff, 0xfffaf17f, 0xff927e15, 0xff8b8888,
0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff,
0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xfffefefe, 0xffffffff, 0xffa2a1a3, 0xff27221d,
0xff1a181a, 0xff29261d, 0xffc7b913, 0xff0a6c7b, 0xff01a0b1, 0xff008e9e, 0xff234137, 0xffeede29, 0xffe3d326, 0xffe1d029,
0xfff8e72d, 0xffb9a923, 0xfff1df1d, 0xffcabb16, 0xff25221b, 0xff625b23, 0xff4d471a, 0xfff9eb4c, 0xfffffa7d, 0xfff2e12f,
0xffbfaa1e, 0xff7c6522, 0xffbba51f, 0xffe2ce19, 0xfff2df0f, 0xfff7e62b, 0xfff8eb56, 0xffecd91c, 0xff856b1c, 0xffafadad,
0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff,
0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xfffefefe, 0xff3f3932, 0xffa89321,
0xffada447, 0xff655d19, 0xff8a7e1e, 0xff838225, 0xff016b7a, 0xff037c88, 0xffab9f23, 0xfffbea2d, 0xfff9e82a, 0xffd0ba23,
0xffcaba28, 0xfff0df1f, 0xffe5d41a, 0xffdacb1b, 0xff645b23, 0xff13111b, 0xff4f491d, 0xffaea220, 0xffbcad20, 0xff928021,
0xff3f351c, 0xff606068, 0xff352e26, 0xff4b3e15, 0xff7a691c, 0xff93811d, 0xff95821a, 0xff79661a, 0xff4c3d26, 0xffdfdedf,
0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff,
0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xff848385, 0xff504216, 0xffe5d87a,
0xfffefef9, 0xfffbf3a2, 0xfff4e32d, 0xffd7c025, 0xff7b6f1d, 0xff054a57, 0xff24645a, 0xfff9e82c, 0xfffae92a, 0xffe5d51e,
0xff211e1e, 0xff887e23, 0xffc5b322, 0xffc6b724, 0xffaa8b29, 0xff11111b, 0xff1a181c, 0xff19171b, 0xff18161a, 0xff2f2d30,
0xffb2b1b3, 0xffffffff, 0xfffcfcfc, 0xffb1b1b1, 0xff6b696c, 0xff4f4d50, 0xff5b5a5c, 0xff9d9c9d, 0xfff3f3f3, 0xffffffff,
0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff,
0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffe3e3e4, 0xff18161a, 0xff887324, 0xfff6eec2,
0xfffcf6c6, 0xfffbf4b7, 0xfffaec66, 0xfff7e628, 0xffe1cb24, 0xffb09c1c, 0xff79731b, 0xfff5e423, 0xffeada21, 0xffb4a427,
0xff0f0e1b, 0xff11101b, 0xff14121c, 0xff342c1f, 0xff513c1f, 0xff111117, 0xff525053, 0xffc9c8c9, 0xffffffff, 0xffffffff,
0xffffffff, 0xfffefefe, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xfffefefe,
0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff,
0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xfffefefe, 0xff727073, 0xff19171b, 0xff675721, 0xfff4e15a,
0xfffaeb42, 0xfffae93e, 0xfffae933, 0xfffae931, 0xfff2e124, 0xffb9a720, 0xff322d1c, 0xff625b1f, 0xffaa9827, 0xff776325,
0xff15141b, 0xff1a181c, 0xff171519, 0xff0d0a0f, 0xff474649, 0xffc7c6c8, 0xfff8f8f8, 0xffffffff, 0xffffffff, 0xffffffff,
0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff,
0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff,
0xffffffff, 0xfffefefe, 0xffffffff, 0xffffffff, 0xffffffff, 0xffdcdcdc, 0xff252326, 0xff1a181c, 0xff312a1d, 0xffd3c122,
0xfff7e72d, 0xfff5e42d, 0xfff3e22d, 0xffecdb2d, 0xffd3c423, 0xffaf9f25, 0xff261f1d, 0xff15131a, 0xff141119, 0xff1a171a,
0xff232125, 0xff302e32, 0xff626063, 0xffd0d0d1, 0xffffffff, 0xffffffff, 0xfffefefe, 0xffffffff, 0xffffffff, 0xffffffff,
0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff,
0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff,
0xffffffff, 0xffffffff, 0xfffdfdfd, 0xffe0e0e1, 0xffb1b0b2, 0xff39373a, 0xff0a070c, 0xff0e0b10, 0xff0b0910, 0xff332e12,
0xff797019, 0xff96891d, 0xff93831d, 0xff817219, 0xff716217, 0xff62511f, 0xff373233, 0xff525053, 0xff777679, 0xffa6a5a7,
0xffc9c9ca, 0xfff1f1f1, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff,
0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff,
0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff,
0xffffffff, 0xffffffff, 0xffffffff, 0xffe2e2e2, 0xffc0bfc0, 0xffbcbbbc, 0xffbcbcbd, 0xffbab9ba, 0xffb6b5b6, 0xffb4b3b4,
0xffb4b3b5, 0xffb7b6b7, 0xffbfbfc0, 0xffd4d4d5, 0xffeeeeee, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff,
0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff,
0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff,
0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff,
0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff,
0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xfffefefe, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff,
0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff,
0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff,
0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff,
0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff,
0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff,
0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff,
0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff,
0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff];

int width = 50;
int height = 50;

Figure logo(){
	list[list[Figure]] boxes;
	boxes = for(i &lt;- [0..height]){
		        append for(j &lt;- [0..width]){
			               append box(fillColor(LogoData[i*50+j]),lineWidth(0));
		}
	}
	return grid(boxes,aspectRatio(1.0));
}

void renderLogo() {
  render(logo());
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>We can use it as follows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-rascal-shell" data-lang="rascal-shell">rascal&gt;render(logo());</code></pre>
</div>
</div>
<div class="paragraph">
<p>will produce:</p>
</div>
<div class="imageblock">
<div class="content">
<img src="Visualization/DrawLogo/logo1.png" alt="Rascal logo">
</div>
</div>
<div class="paragraph">
<p>or as a screenshot:</p>
</div>
<div class="imageblock">
<div class="content">
<img src="Visualization/DrawLogo/Screenshot1.png" alt="Screen shot">
</div>
</div>
</div>
<div class="sect2">
<h3 id="Visualization-InteractiveBoxHeight">5.3. Interactive Box Height</h3>
<div class="paragraph">
<div class="title">Synopsis</div>
<p>Control the height of a box with user input.</p>
</div>
<div class="ulist">
<div class="title">Description</div>
<ul>
<li>
<p>A text entry field to enter numbers.</p>
</li>
<li>
<p>A box, whose height is controlled by the numer entered in the text field.</p>
</li>
</ul>
</div>
<div class="paragraph">
<div class="title">Examples</div>
<p>Here is a solution:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-rascal" data-lang="rascal">module demo::vis::Higher

import vis::Figure;
import vis::Render;
import String;

bool intInput(str s){
	return /^[0-9]+$/ := s;
}

Figure higher(){
	int H = 100;
    return vcat( [ textfield("&lt;H&gt;", void(str s){H = toInt(s);}, intInput),
	               box(width(100), vresizable(false), vsize(num(){return H;}), fillColor("red"))
	             ], shrink(0.5), resizable(false));
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The auxiliary function <code>intInput</code> checks that a strings consists solely of digits.
Function <code>higher</code> can be understood as follows:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>A local variable <code>H</code> is used to maintain the current height.</p>
</li>
<li>
<p>It returns a vertical concatenation of two elements: a [Rascal:textfield] and a [Rascal:box].</p>
</li>
<li>
<p>The textfield has three arguments:</p>
<div class="ulist">
<ul>
<li>
<p>A string that is the initial value of the text field.</p>
</li>
<li>
<p>A call back function <code>void(str s){H = toInt(s);}</code> that is called when text entry is complete:
argument <code>s</code> is the text entered and the effect is to convert that text to a number and assign it to <code>H</code>.</p>
</li>
<li>
<p>Function <code>intInput</code> that checks that only numbers are entered.</p>
</li>
<li>
<p>The box has</p>
</li>
<li>
<p>a fixed width</p>
</li>
<li>
<p>it is not vertically resizable.</p>
</li>
<li>
<p>It has a vertical size that that depends on an anonymous function <code>vsize(num(){return H;})</code> that returns the value of <code>H</code>.</p>
</li>
<li>
<p>Its color is red.</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
<div class="paragraph">
<p>Rendering this figure:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-rascal-shell" data-lang="rascal-shell">rascal&gt;render(higher());</code></pre>
</div>
</div>
<div class="paragraph">
<p>gives</p>
</div>
<div class="imageblock">
<div class="content">
<img src="Visualization/InteractiveBoxHeight/h1.png" alt="h1">
</div>
</div>
<div class="paragraph">
<p>Unfortunately we cannot show the interaction here, so run this example from the <code>demo</code> directory and watch how the height of the box changes when you enter a new number in the text field.</p>
</div>
</div>
<div class="sect2">
<h3 id="Visualization-MyFirstBox">5.4. My First Box</h3>
<div class="paragraph">
<div class="title">Synopsis</div>
<p>Drawing a box in many variations.</p>
</div>
<div class="paragraph">
<div class="title">Examples</div>
<p>Drawing a red <a href="../Libraries/Libraries.html#Figure-box">box</a> is as simple as this:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-rascal-shell" data-lang="rascal-shell">rascal&gt;render(b);</code></pre>
</div>
</div>
<div class="paragraph">
<p>and it will look like this:</p>
</div>
<div class="imageblock">
<div class="content">
<img src="Visualization/MyFirstBox/b1.png" alt="Box 1">
</div>
</div>
<div class="literalblock">
<div class="content">
<pre>or rather, it will look like this:</pre>
</div>
</div>
<div class="imageblock">
<div class="content">
<img src="Visualization/MyFirstBox/Screenshot1.png" alt="Screenshot 1">
</div>
</div>
<div class="paragraph">
<p>Wow, the box fills the whole window! So lets give our box a <a href="../Libraries/Libraries.html#Properties-size">size</a>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-rascal-shell" data-lang="rascal-shell">rascal&gt;render(b);</code></pre>
</div>
</div>
<div class="paragraph">
<p>and it will look like this:</p>
</div>
<div class="imageblock">
<div class="content">
<img src="Visualization/MyFirstBox/b2.png" alt="Box 2">
</div>
</div>
<div class="paragraph">
<p>On screen however, it still fills the whole window as shown above.
The lesson here is that size is to be taken as <strong>minimum size</strong> (and probably we should
rename <code>size</code> to <code>minSize</code> to emphasize this).</p>
</div>
<div class="paragraph">
<p>So how can we produce a box that does <em>not</em> fill the whole window? The answer is to define the size of the box
<em>relative</em> to its surroundings by using <a href="../Libraries/Libraries.html#Properties-shrink">shrink</a>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-rascal-shell" data-lang="rascal-shell">rascal&gt;render(b);</code></pre>
</div>
</div>
<div class="paragraph">
<p>which says: <em>I am a red box and I want to occupy 50% of the available space.</em> The result is:</p>
</div>
<div class="imageblock">
<div class="content">
<img src="Visualization/MyFirstBox/Screenshot2.png" alt="Screen shot 2">
</div>
</div>
<div class="paragraph">
<p>Shrinking can also be limited to one dimension using <a href="../Libraries/Libraries.html#Properties-hshrink">hshrink</a>
or <a href="../Libraries/Libraries.html#Properties-vshrink">vshrink</a>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-rascal-shell" data-lang="rascal-shell">rascal&gt;render(b);</code></pre>
</div>
</div>
<div class="paragraph">
<p>which says:_ I am a red box and I want to occupy 50% of the available space in the horizontal direction and 100% of the available space in the vertical direction._ The result is:</p>
</div>
<div class="imageblock">
<div class="content">
<img src="Visualization/MyFirstBox/Screenshot3.png" alt="Screen shot 3">
</div>
</div>
<div class="paragraph">
<p>Relative sizes can also be used when figures are nested.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-rascal-shell" data-lang="rascal-shell">rascal&gt;render(b2);</code></pre>
</div>
</div>
<div class="imageblock">
<div class="content">
<img src="Visualization/MyFirstBox/b5.png" alt="Box 5">
</div>
</div>
<div class="paragraph">
<div class="title">Pitfalls</div>
<p>In the above examples we have consistently added the two imports:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-rascal" data-lang="rascal">import vis::Figure;
import vis::Render;</code></pre>
</div>
</div>
<div class="paragraph">
<p>In other recipes and the Rascal documentation we omit these two imports to avoid cluttering our examples with irrelevant details.
Be aware that you will always need them when creating a visualisation.</p>
</div>
</div>
<div class="sect2">
<h3 id="Visualization-ParseTree">5.5. ParseTree</h3>
<div class="paragraph">
<div class="title">Synopsis</div>
<p>Visualize a parse tree.</p>
</div>
<div class="paragraph">
<div class="title">Description</div>
<p>A parse tree is a (usually large) internal representation of  a parsed text.
In the rare situation that it is necessary to read or inspect a parse tree,
a visualization can be useful.</p>
</div>
<div class="paragraph">
<div class="title">Examples</div>
<p>We embark on visualizing parse trees for the language Exp:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-rascal-shell" data-lang="rascal-shell">rascal&gt;import demo::lang::Exp::Concrete::WithLayout::Syntax;
ok
rascal&gt;import ParseTree;
ok
rascal&gt;parse(#Exp, "1+2*3");
Exp: (Exp) `1+2*3`</code></pre>
</div>
</div>
<div class="paragraph">
<p>As can be seen, even for such a trivial example, the details in the parse tree representation become sizeable.</p>
</div>
<div class="paragraph">
<p>We can visualize it as follows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-rascal-shell" data-lang="rascal-shell">rascal&gt;render(visParsetree(parse(#Exp, "1+2*3")));</code></pre>
</div>
</div>
<div class="paragraph">
<p>With as result:</p>
</div>
<div class="imageblock">
<div class="content">
<img src="Visualization/ParseTree/t1.png" alt="t1">
</div>
</div>
<div class="paragraph">
<p>The figure is interactive (not available here):</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Rectangles with blue text are terminal symbols.</p>
</li>
<li>
<p>Little circles represent non-terminals: hovering over them shows the corresponding grammar rule.</p>
</li>
<li>
<p>Little grey rectangles represent layout: hovering over them also shows the corresponding lexical rule.</p>
</li>
</ul>
</div>
<div class="ulist">
<div class="title">Benefits</div>
<ul>
<li>
<p>A dense, structured, representation of a parse tree that provides extra information via interaction.</p>
</li>
</ul>
</div>
<div class="ulist">
<div class="title">Pitfalls</div>
<ul>
<li>
<p>This visualization does not scale to huge trees.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="Visualization-PlayingWithProperties">5.6. Playing With Properties</h3>
<div class="paragraph">
<div class="title">Synopsis</div>
<p>Illustrate the effect of various figure properties.</p>
</div>
<div class="paragraph">
<div class="title">Examples</div>
<p>Here is an ellipse with minimum size 200x300 that occupies 80% of the available space:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-rascal-shell" data-lang="rascal-shell">rascal&gt;render(e);</code></pre>
</div>
</div>
<div class="imageblock">
<div class="content">
<img src="Visualization/PlayingWithProperties/e1.png" alt="e1">
</div>
</div>
<div class="paragraph">
<p>(we add the shrink to leave some space for thick lines and shadows below).</p>
</div>
<div class="paragraph">
<p>Change the style of its border using <a href="../Libraries/Libraries.html#Properties-lineStyle">lineStyle</a>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-rascal-shell" data-lang="rascal-shell">rascal&gt;render(e);</code></pre>
</div>
</div>
<div class="imageblock">
<div class="content">
<img src="Visualization/PlayingWithProperties/e2.png" alt="e2">
</div>
</div>
<div class="paragraph">
<p>Change the thickness of its border using <a href="../Libraries/Libraries.html#Properties-lineWidth">lineWidth</a>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-rascal-shell" data-lang="rascal-shell">rascal&gt;render(e);</code></pre>
</div>
</div>
<div class="imageblock">
<div class="content">
<img src="Visualization/PlayingWithProperties/e3.png" alt="e3">
</div>
</div>
<div class="paragraph">
<p>Change the color of its border using <a href="../Libraries/Libraries.html#Properties-lineColor">lineColor</a>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-rascal-shell" data-lang="rascal-shell">rascal&gt;render(e);</code></pre>
</div>
</div>
<div class="imageblock">
<div class="content">
<img src="Visualization/PlayingWithProperties/e4.png" alt="e4">
</div>
</div>
<div class="paragraph">
<p>Change the color of its area using <a href="../Libraries/Libraries.html#Properties-fillColor">fillColor</a>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-rascal-shell" data-lang="rascal-shell">rascal&gt;render(e);</code></pre>
</div>
</div>
<div class="imageblock">
<div class="content">
<img src="Visualization/PlayingWithProperties/e5.png" alt="e5">
</div>
</div>
<div class="paragraph">
<p>Add a shadow using <a href="../Libraries/Libraries.html#Properties-shadow">shadow</a>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-rascal-shell" data-lang="rascal-shell">rascal&gt;render(e);</code></pre>
</div>
</div>
<div class="imageblock">
<div class="content">
<img src="Visualization/PlayingWithProperties/e6.png" alt="e6">
</div>
</div>
<div class="paragraph">
<p>Add the color of the shadow using <a href="../Libraries/Libraries.html#Properties-shadowColor">shadowColor</a>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-rascal-shell" data-lang="rascal-shell">rascal&gt;render(e);</code></pre>
</div>
</div>
<div class="imageblock">
<div class="content">
<img src="Visualization/PlayingWithProperties/e7.png" alt="e7">
</div>
</div>
<div class="paragraph">
<p>Finally, enjoy the grande finale:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-rascal-shell" data-lang="rascal-shell">rascal&gt;render(e);</code></pre>
</div>
</div>
<div class="imageblock">
<div class="content">
<img src="Visualization/PlayingWithProperties/e8.png" alt="e8">
</div>
</div>
</div>
</div>
</div>
</div>
<div id="footer">
<div id="footer-text">
Last updated 2016-06-01 00:30:51 CEST
</div>
</div>
</body>
</html>